<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>物质点法--学习笔记(一)</title>
      <link href="/2024/07/af38f644.html"/>
      <url>/2024/07/af38f644.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-物质点法"><a href="#1-物质点法" class="headerlink" title="1. 物质点法"></a>1. 物质点法</h2><p>​    物质点法(MPM)将连续体离散成一组质点. 每个质点代表一块材料区域并携带该区域材料的所有物质信息, 如质量, 速度, 应力和应变等. 计算网格仅用于动量方程的求解和空间导数的计算, 它不携带任何物质信息. 在每一个时间步中, 质点与计算网格完全固连(拉格朗日计算步), 可以用标准的有限元法在计算网格上求解物体的运动方程. 计算网格结点的运动方程可以通过将质点的运动量映射到计算网格得到, 求解后将计算网格结点的运动量映射回各质点, 从而得到这些质点在下一时刻的运动量(对流计算步). </p><p>​    物质点法是一种完全的拉格朗日质点类方法, 在每步中质点和计算网格没有相对运动, 避免了欧拉法因非线性对流项产生的数值困难. 质点已经携带了连续体的所有物质信息, 因此物质点法在每个时间步结束时抛弃变形后的计算网格, 在新的时间步中仍可以采用未变形的计算网格. </p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202407/12/20240712103901.png" alt="image-20240712103857244" style="zoom:33%;" /></p><p>​    在并行算法方面, 主要基于消息传递模型(MPI)和信息共享模型(OpenMP)实现. </p><h2 id="2-控制方程"><a href="#2-控制方程" class="headerlink" title="2. 控制方程"></a>2. 控制方程</h2><h3 id="2-1-物体运动和变形的描述"><a href="#2-1-物体运动和变形的描述" class="headerlink" title="2.1 物体运动和变形的描述"></a>2.1 物体运动和变形的描述</h3><p>​    物体在 t = 0 时刻所占据的空间区域称为<code>初始构形</code>. 物体在 t 时刻所占据的空间区域成为<code>现时构形</code>. 为了度量物体的运动, 需要选取一个特定的构形作为基准, 称为<code>参考构形</code>. </p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202407/12/20240712105211.png" alt="image-20240712105208694" style="zoom: 33%;" /></p><p>​    在参考构形中质点的矢径 $X$ 可以表示为</p><script type="math/tex; mode=display">\begin{equation} \label{eq21} X = X_i e_i, i = 1,2,3 \end{equation}</script><p>​    其中 $e_i$ 为直角坐标系的基矢量, $X_i$ 为参考构形中质点矢径 $X$ 在 $e_i$ 上的投影. 质点在参考构形中的矢径 $X$ 不随时间 $t$ 变化, $X_i$ 称为<code>物质坐标</code>或<code>拉格朗日坐标</code>, 它可以作为该质点的标记. </p><p>​    在现时构形中质点 $X$ 的矢径 $x$ 可以表示为</p><script type="math/tex; mode=display">x = x_i e_i , i = 1, 2, 3</script><p>​    其中 $x_i$ 为矢径 $x$ 在 $e_i$ 上的投影, 坐标 $x_i$ 给出了质点 $X$ 在空间中的位置,称为<code>空间坐标</code>或<code>欧拉坐标</code>. 质点 $X$ 的运动方程可以表示为</p><script type="math/tex; mode=display">x_i = x_i(X,t)</script><p>​    在拉格朗日描述中, 质点 $X$ 的位移为</p><script type="math/tex; mode=display">u_i = x_i (X, t) - X_i</script><p>​    在欧拉描述中, 质点 $X$ 的位移为</p><script type="math/tex; mode=display">u_i = x_i - X_i(x,t)</script><p>​    质点的速度等于其矢径 $x$ 的变化率, 即令 $X$ 保持不变时矢径 $x$ 对时间的偏导数. 令 $X$ 保持不变时物理量对时间的导数称为<code>物质导数</code>, 也称为<code>全导数</code>或<code>拉格朗日导数</code>. 可以得到质点的速度为</p><script type="math/tex; mode=display">v_i = \frac{\partial x_i(X, t)}{\partial t} = \frac{\partial u_i(X, t)}{\partial t} \equiv \dot{u}_i</script><p>​    质点的加速度为其速度的物质导数, 即</p><script type="math/tex; mode=display">\alpha_i = \frac{\partial v_i(X,t)}{\partial t} = \frac{\partial^2 u_i (X, t)}{\partial t^2} \equiv \ddot{u}_i</script><p>​    </p><p>​    如果物理量 $F$ 是用空间坐标 $x$ 和时间 $t$ 描述的, 即 $F = F(x,t)$, 可以把它变换为复合函数 $F = F(x(X, t), t)$, 它的物质导数为</p><script type="math/tex; mode=display">\frac{DF(x, t)}{Dt} = \frac{\partial F(x, t)}{\partial t} + \frac{\partial F(x, t)}{\partial x_i}\frac{\partial x_i(X, t)}{\partial t}\\= \frac{\partial F(x, t)}{\partial t} + \frac{\partial F(x, t)}{\partial x_i}v_i</script><p>​     $F(x, t)$ 描述的是时刻 $t$  空间点 $x$ 处的物理量, 因此 $\partial F(x, t)/\partial t$ 表示的是物理量在空间固定点 $x$ 处的变化率, 称为<code>空间时间导数</code>, 也称为<code>局部导数</code>或<code>欧拉导数</code>. 它反映了物理量的非定常性.</p><h3 id="2-2-变形梯度"><a href="#2-2-变形梯度" class="headerlink" title="2.2 变形梯度"></a>2.2 变形梯度</h3><p>质点的现时坐标 $x_i$ 相对于物质坐标 $X_j$ 的偏导数 $F_{ij} = \partial x_i / \partial X_j$ 称为变形梯度, 它是一个非对称的二阶张量. 初始构形中由相邻质点 $X$ 和 $X+dX$ 构成的无限小线元 $dX$ 在现时构形中变为</p><script type="math/tex; mode=display">dx_i = x_i(X + dX, t) - x_i(X, t)</script><p>对 $x_i(X + dX, t)$ 在 $X$ 处作泰勒展开, 并略去高阶小项得</p><script type="math/tex; mode=display">dx_i = \frac{\partial x_i}{\partial X_j} dX_j</script><p>变形梯度的行列式</p><script type="math/tex; mode=display">J = \begin{vmatrix} \frac{\partial x_i}{\partial X_j}\end{vmatrix}=\begin{vmatrix} \frac{\partial x_1}{\partial X_1} & \frac{\partial x_1}{\partial X_2} & \frac{\partial x_1}{\partial X_3}\\\frac{\partial x_2}{\partial X_1} & \frac{\partial x_2}{\partial X_2} & \frac{\partial x_2}{\partial X_3}\\\frac{\partial x_3}{\partial X_1} & \frac{\partial x_3}{\partial X_2} & \frac{\partial x_3}{\partial X_3}\\\end{vmatrix}</script><p>称为<code>雅可比行列式</code>. </p><p>引入<strong>排列张量</strong> $e_{ijk}$, 可将上式展开为</p><script type="math/tex; mode=display">J = e_{ijk}\frac{\partial x_i}{\partial X_1} \frac{\partial x_j}{\partial X_2} \frac{\partial x_k}{\partial X_3}</script><p>由行列式的性质和 $J$ 的定义可得</p><script type="math/tex; mode=display">e_{plm}J = e_{ijk}\frac{\partial x_i}{\partial X_p} \frac{\partial x_j}{\partial X_l} \frac{\partial x_j}{\partial X_m}</script><p>设初始构形中的平行六面体体元的三个线元分别是 $dX$, $\delta X$ 和 $\Delta X$, 它们在现时构形中分别为 $dx$, $\delta x$ 和 $\Delta x$, 且</p><script type="math/tex; mode=display">dx_i = \frac{\partial x_i}{\partial X_p}dX_p,\ \delta x_j = \frac{\partial x_j}{\partial X_l}\delta X_l,\ \Delta x_k = \frac{\partial x_k}{\partial X_m} \Delta X_m</script><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202407/14/20240714111451.png" alt="image-20240714111448284" style="zoom:50%;" /></p><p>现时构形中由 $dx$, $\delta x$ 和 $\Delta x$ 构成的六面体体元的体积为</p><script type="math/tex; mode=display">dV = \begin{vmatrix}dx_1 & dx_2 & dx_3\\\delta x_1 & \delta x_2 & \delta x_3\\\Delta x_1 & \Delta x_2 & \Delta x_3\\\end{vmatrix}= JdV_0</script><p>因此变形梯度矩阵的行列式 $J$ 可用来表示变形过程中体元的体积变化, 即</p><script type="math/tex; mode=display">J = \frac{dV}{dV_0}</script><p>可见 $J$ 表示变形前后体元体积之比. </p><h3 id="2-3-变形率"><a href="#2-3-变形率" class="headerlink" title="2.3 变形率"></a>2.3 变形率</h3><p>考察一个典型的质点 $P$, 它在时刻 $t$ 的坐标为 $x_j$, 瞬时速度为 $v_i(x_j, t)$. 与 $P$ 点相邻的质点 $P’$ 的坐标为 $x_j+dx_j$, 它相对于 $P$ 点的相对速度为</p><script type="math/tex; mode=display">dv_i = v_i(x_j + dx_j, t) - v_i(x_j, t) = \frac{\partial v_i}{\partial x_j} dx_j</script><p>式中 $\partial v_i/\partial x_j$ 为<strong>速度梯度张量</strong>. 它可分解为对称部分和反对称部分之和, 即</p><script type="math/tex; mode=display">\frac{\partial v_i}{\partial x_j} = \frac{1}{2}\left( \frac{\partial v_i}{\partial x_j} - \frac{\partial v_j}{\partial x_i} \right) + \frac{1}{2}\left( \frac{\partial v_i}{\partial x_j} + \frac{\partial v_j}{\partial x_i} \right)\\= \Omega_{ij} + D_{ij}</script><p>式中</p><script type="math/tex; mode=display">\Omega_{ij} = \frac{1}{2}\left( \frac{\partial v_i}{\partial x_j} - \frac{\partial v_j}{\partial x_i} \right)\\D_{ij} = \frac{1}{2}\left( \frac{\partial v_i}{\partial x_j} + \frac{\partial v_j}{\partial x_i} \right)</script><p>分别为<strong>旋律张量</strong>和<strong>变形率张量</strong>. </p><p>与速度梯度分解相似， 相对速度式</p>]]></content>
      
      
      <categories>
          
          <category> MPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 物质点法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo和Github部署个人博客完整教程</title>
      <link href="/2024/06/4a79202d.html"/>
      <url>/2024/06/4a79202d.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><ol><li><p>安装node.js</p></li><li><p><a href="https://fireflye.asia/2024/05/cbf708ce.html">安装Git</a></p></li><li><p>安装Hexo</p></li><li><p>创建Github仓库</p></li><li><p>安装上传插件</p></li><li><p>更改配置</p></li><li><p>上传网页</p></li></ol><h2 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1. 安装node.js"></a>1. 安装node.js</h2><p>打开node.js官网<a href="https://nodejs.org/en">Node.js — Run JavaScript Everywhere (nodejs.org)</a>点击下载</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/16/20240616123133.png" alt="image-20240616123122227" style="zoom: 25%;" /></p><p>打开安装至<strong>默认位置</strong>即可</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/16/20240616133443.png" alt="image-20240616133442122" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/16/20240616133515.png" alt="image-20240616133513544" style="zoom: 50%;" /></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/16/20240616134516.png" alt="image-20240616134514733" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/16/20240616134543.png" alt="image-20240616134540912" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/16/20240616134642.png" alt="image-20240616134640367" style="zoom:50%;" /></p><p>自动安装一些工具, 可以选上, 然后安装. 等待安装完成</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/16/20240616134808.png" alt="image-20240616134806827" style="zoom:50%;" /></p><p>点击完成, 会弹出一些窗口</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/16/20240616134924.png" alt="image-20240616134922113" style="zoom:50%;" /></p><p>按<strong>任意键</strong>继续即可, 等待安装完成. </p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/16/20240616135112.png" alt="image-20240616135110217" style="zoom:33%;" /></p><p>过程较长, 耐心等待安装完成. </p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/16/20240616214419.png" alt="image-20240616214328211" style="zoom: 33%;" /></p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h2><p>查看往期教程<a href="https://fireflye.asia/2024/05/cbf708ce.html">Git 安装及配置教程 | Firefly Blog | 萤火虫博客 (fireflye.asia)</a></p><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h2><p>完成上面的安装后, 可以使用以下命令检查是否安装成功.</p><p>打开<code>git bash</code>,输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">git -v</span><br></pre></td></tr></table></figure><p>显示版本信息, 说明安装成功.</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630103342.png" alt="image-20240630103326908"></p><p>之后再输入以下命令安装hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>等待安装完成, 网络问题请自学寻找代理, 或寻找可用镜像源. 显示以下信息说明安装完成</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630103804.png" alt="image-20240630103802987" style="zoom:50%;" /></p><p>还可以使用以下命令来查看安装情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>若显示版本信息, 说明已成功安装</p><p>打开一个要存放网站文件的位置, 例如<code>F:\web\</code>. 打开此文件夹, 右键选择<code>open git bash here</code></p><blockquote><p>或者 直接打开<code>git bash</code> 输入<code>cd f:\web</code>. 路径替换为自己的路径. </p></blockquote><p>打开后会显示(我使用的虚拟机放在了桌面. 不建议这样做. 文件夹需要妥善保存.)</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630111136.png" alt="image-20240630111134467" style="zoom:50%;" /></p><p>输入以下命令初始化hexo(一定要在刚刚的文件夹内-路径显示)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>保证网络畅通, 耐心等待初始化完成. </p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630111546.png" alt="image-20240630111544780" style="zoom: 67%;" /></p><p>到此, hexo初始化完成. 下面配置github仓库. </p><h2 id="4-创建Github仓库"><a href="#4-创建Github仓库" class="headerlink" title="4. 创建Github仓库"></a>4. 创建Github仓库</h2><p>打开<a href="https://github.com/">Github</a>注册一个自己的账号</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630135454.png" alt="image-20240630104651171" style="zoom: 33%;" /></p><p>输入自己的邮箱, 密码等</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630105025.png" alt="image-20240630104946194" style="zoom:50%;" /></p><p>用户名建议设置简单易记一些, 待会创建的网站域名与自己的用户名有关</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630105356.png" alt="image-20240630105354804" style="zoom:50%;" /></p><p>总览</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630105538.png" alt="image-20240630105536614" style="zoom:50%;" /></p><p>点击继续, 通过验证码和邮箱数字验证就可以注册成功.</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630110321.png" alt="image-20240630110310020" style="zoom: 25%;" /></p><p>点击左侧的绿色按钮新建仓库<code>Create repository</code>. </p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630112222.png" alt="image-20240630112211721" style="zoom: 33%;" /></p><p>到此, 仓库已经创建完成</p><hr><p>接下来还需要配置一下上传的密钥对</p><p>打开<code>git bash</code>, 输入以下命令 (“email”替换为自己的邮箱)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;email&quot;</span></span><br></pre></td></tr></table></figure><p>然后按三下回车键, 即均保持默认不设置密码. 也可根据自己需要修改</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630113042.png" alt="image-20240630113030731" style="zoom: 67%;" /></p><blockquote><p>第一次是保存位置</p><p>第二次是密码</p><p>第三次是重复密码</p></blockquote><p>创建完成后, 打开保存的目录. 默认在<code>C:\Users\用户名\.ssh</code></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630113309.png" alt="image-20240630113306685" style="zoom: 50%;" /></p><p>第一个是私钥, 自己一定要保存好, 不能给别人.</p><p>将第二个pub结尾的用<code>记事本</code>打开, 将里面的内容复制出来.</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630113557.png" alt="image-20240630113555419" style="zoom:50%;" /></p><p>复制好后, 返回Github</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630113804.png" alt="image-20240630113747970" style="zoom: 33%;" /></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630113926.png" alt="image-20240630113916419" style="zoom:33%;" /></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630114019.png" alt="image-20240630114006001" style="zoom:33%;" /></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630114156.png" alt="image-20240630114146715" style="zoom:33%;" /></p><p>密钥添加完成</p><h2 id="5-安装上传插件"><a href="#5-安装上传插件" class="headerlink" title="5. 安装上传插件"></a>5. 安装上传插件</h2><p>打开<code>git bash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630125113.png" alt="image-20240630125111158" style="zoom:50%;" /></p><p>安装完成</p><h2 id="6-更改配置"><a href="#6-更改配置" class="headerlink" title="6. 更改配置"></a>6. 更改配置</h2><p>打开网站文件夹</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630125231.png" alt="image-20240630125228295" style="zoom:50%;" /></p><p>用记事本打开<code>_config.yml</code></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630125343.png" alt="image-20240630125338327" style="zoom: 33%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"># 配置说明, 不要复制. 按说明修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: Hexo  # 网站的大标题</span><br><span class="line">subtitle: &#x27;&#x27;  # 副标题</span><br><span class="line">description: &#x27;&#x27; # 描述</span><br><span class="line">keywords:  # 网站的关键词</span><br><span class="line">author: John Doe # 作者</span><br><span class="line">language: en  # 语言 中文 zh-CN</span><br><span class="line">timezone: &#x27;&#x27; # 时区 Asia/Shanghai</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: https://fireflyblog.github.io # 改成自己网址 https://用户名.github.io # 注意是https</span><br><span class="line">permalink: :year/:month/:day/:title/  # 其他默认转到最后一项</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link:</span><br><span class="line">  enable: true # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: &#x27;&#x27;</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">syntax_highlighter: highlight.js</span><br><span class="line">highlight:</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace: &#x27;&#x27;</span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br><span class="line">prismjs:</span><br><span class="line">  preprocess: true</span><br><span class="line">  line_number: true</span><br><span class="line">  tab_replace: &#x27;&#x27;</span><br><span class="line"></span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -date</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Metadata elements</span><br><span class="line">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span><br><span class="line">meta_generator: true</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span><br><span class="line">updated_option: &#x27;mtime&#x27;</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Include / Exclude file(s)</span><br><span class="line">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class="line">include:</span><br><span class="line">exclude:</span><br><span class="line">ignore:</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: landscape</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: &#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一部分单拿出来修改(注意缩进为2个空格, 冒号后面一个空格)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository:</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>仓库地址在<a href="https://github.com/dashboard">Github</a>, 打开找到自己的仓库</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630131332.png" alt="image-20240630131146011" style="zoom: 33%;" /></p><p>复制好后粘贴到仓库参数后面, 完整的配置修改如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:fireflyblog/fireflyblog.github.io.git #替换为自己的链接</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><h2 id="7-上传网页"><a href="#7-上传网页" class="headerlink" title="7. 上传网页"></a>7. 上传网页</h2><p>一切配置好之后, 打开网站文件夹. 右键选择<code>open git bash here</code></p><p>输入以下命令生成和上传网页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630132526.png" alt="image-20240630132524270" style="zoom:50%;" /></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630132738.png" alt="image-20240630132736169" style="zoom:50%;" /></p><p>上传成功之后, 等待一会. 就可以打开自己网页查看了(替换自己的用户名)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://fireflyblog.github.io</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202406/30/20240630133040.png" alt="image-20240630132950741" style="zoom:33%;" /></p><p>至此, 网站已经搭建完成</p><hr><p>还有一些其他常使用的命令</p><p>新建文章</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;title&quot;</span></span><br></pre></td></tr></table></figure><p>本地部署预览</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>清理生成文件(一般切换主题需要先清理再生成. 新建文章之类的不需要此操作.)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><hr><p>文章保存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网站文件夹\source\_posts</span><br></pre></td></tr></table></figure><hr><p>文章格式说明以及主题美化待更新…</p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 教程及说明 </tag>
            
            <tag> Hexo </tag>
            
            <tag> 静态网页 </tag>
            
            <tag> Blog </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fortran转C++的一些注意事项</title>
      <link href="/2024/05/5a883584.html"/>
      <url>/2024/05/5a883584.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、命名"><a href="#一、命名" class="headerlink" title="一、命名"></a>一、命名</h2><p>在Fortran中, 所有的字符都是<code>不区分大小写</code>的. 在编译时, 全部使用小写字符. 但是, 在C++中是会<code>区分大小写</code>的. 因此, 在转换时要注意统一大小写. </p><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><h3 id="1-可直接转换的参数类型"><a href="#1-可直接转换的参数类型" class="headerlink" title="1. 可直接转换的参数类型"></a>1. 可直接转换的参数类型</h3><ul><li>整型: <code>integer</code>  = <code>int</code></li><li>浮点数: <code>real</code>  = <code>float</code></li><li>双浮点数: <code>real(8)</code>  = <code>double</code></li><li>逻辑: <code>logical</code> = <code>bool</code></li></ul><blockquote><p>对于科学计数法, Fortran中<code>d</code>表示双精度浮点数, 如<code>1.2d3</code>. 在C++中并不能直接识别, 但是C++中默认使用双精度浮点数. 因此可直接使用<code>1.2e3</code>来代替.</p></blockquote><h3 id="2-可代替的参数类型"><a href="#2-可代替的参数类型" class="headerlink" title="2. 可代替的参数类型"></a>2. 可代替的参数类型</h3><ul><li>字符串<code>character</code>: 可使用<code>std::string</code>代替 (须<code>#indlude &lt;string&gt;</code>)</li></ul><blockquote><p>在c++中<code>char</code>只能储存一个字符, 需要使用数组来保存字符串. 因此在使用上<code>character</code>和<code>string</code>更类似</p><p>对于字符串的连接, Fortran中使用<code>//</code>, C++中使用<code>+</code></p></blockquote><ul><li>复数<code>complex</code>: 可使用<code>std::complex</code>代替 (须<code>#include &lt;complex&gt;</code>)</li></ul><blockquote><p>C++的<code>std::complex</code>内提供了一些用于复数运算的函数, </p><p>例如: </p><p><code>std::real</code>(获取复数的实部)</p><p><code>std::imag</code>(获取复数的虚部)</p><p><code>std::abs</code>(获取复数的模)</p><p><code>std::arg</code>(获取复数的辐角)</p><p><code>std::norm</code>(获取复数的模的平方)</p><p><code>std::conj</code>(获取复数的共轭复数)</p></blockquote><ul><li>自定义类型<code>type</code>: 可使用结构体<code>struct</code>代替</li></ul><blockquote><p>对于参数的访问, 在Fortran中使用<code>%</code>在c++中使用<code>.</code></p></blockquote><ul><li>动态数组<code>allocatable</code>: 可使用向量<code>vector</code>代替 (须<code>#include &lt;vector&gt;</code>)</li></ul><blockquote><p>对于结构体类型的向量, 使用<code>vecname.assign(quantity, vecname());</code>来调整向量的大小. 但是注意这会清除向量中原有的内容</p><p>对于数值类型的向量, 使用<code>vecname.resize()</code>来调整大小</p><p>使用<code>vecname.size()</code>可以得到向量当前的大小</p></blockquote><ul><li>动态<code>type</code>数组: 使用<code>std::vector&lt;structname&gt;</code>来定义</li></ul><blockquote><p>对于动态type数组这类变量, 在Fortran中的初始化: </p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!在Fortran2003以后的标准中, type可以直接给定默认值</span></span><br><span class="line"><span class="keyword">type</span> material</span><br><span class="line"><span class="keyword">real</span> :: mass = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">real</span> :: speed = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">real</span> :: Vx(<span class="number">3</span>) = <span class="number">0.0</span>, Vy(<span class="number">3</span>) = <span class="number">0.0</span>, Vz(<span class="number">3</span>)=<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>(material),<span class="keyword">allocatable</span>::material_list(:)</span><br><span class="line"><span class="built_in">allocate</span>(material_list(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">!对于之前的标准, 或者没有定义默认值, 再或者需要再次初始化, 可以使用以下方式</span></span><br><span class="line"><span class="keyword">type</span> material</span><br><span class="line"><span class="keyword">real</span> mass</span><br><span class="line"><span class="keyword">real</span> speed</span><br><span class="line"><span class="keyword">real</span> Vx(<span class="number">3</span>), Vy(<span class="number">3</span>), Vz(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>(material),<span class="keyword">allocatable</span>::material_list(:)</span><br><span class="line"><span class="built_in">allocate</span>(material_list(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">material_list(i)%mass = <span class="number">0.0</span></span><br><span class="line">material_list(i)%speed = <span class="number">0.0</span></span><br><span class="line">material_list(i)%Vx = (/<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>/)</span><br><span class="line">material_list(i)%Vy = (/<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>/)</span><br><span class="line">material_list(i)%Vz = (/<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>/)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="comment">! 特别的,在Fortran中,不加索引号会对数组内的全部元素赋值</span></span><br><span class="line"><span class="keyword">type</span> material</span><br><span class="line"><span class="keyword">real</span> mass</span><br><span class="line"><span class="keyword">real</span> speed</span><br><span class="line"><span class="keyword">real</span> Vx(<span class="number">3</span>), Vy(<span class="number">3</span>), Vz(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>(material),<span class="keyword">allocatable</span>::material_list(:)</span><br><span class="line"><span class="built_in">allocate</span>(material_list(<span class="number">3</span>))</span><br><span class="line">material_list%mass = <span class="number">0.0</span></span><br><span class="line">material_list%speed = <span class="number">0.0</span></span><br><span class="line">material_list%Vx = (/<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>/)</span><br><span class="line">material_list%Vy = (/<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>/)</span><br><span class="line">material_list%Vz = (/<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>/)</span><br><span class="line"><span class="comment">!与上面带索引号的方式,效果相同, C++中不能这样做</span></span><br></pre></td></tr></table></figure><p>在c++中: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在C++11以后的标准中可以直接对结构体设置默认值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">material</span> <span class="comment">//定义结构体</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">float</span> mass = <span class="number">0.0f</span>; <span class="comment">//0.0默认是double类型, 浮点数的0.0要加上f</span></span><br><span class="line"> <span class="type">float</span> speed = <span class="number">0.0f</span>;</span><br><span class="line"> <span class="type">float</span> Vx[<span class="number">3</span>] = &#123;<span class="number">0.0f</span>&#125;, Vy[<span class="number">3</span>] = &#123;<span class="number">0.0f</span>&#125;, Vz[<span class="number">3</span>] = &#123;<span class="number">0.0f</span>&#125;;<span class="comment">//此处c++会将数组里的其他值也初始化为0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;material&gt; material_list; <span class="comment">//创建结构体向量</span></span><br><span class="line">material_list.<span class="built_in">assign</span>(<span class="number">3</span>,<span class="built_in">material</span>()); <span class="comment">//修改向量大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于之前的标准或者没有定义默认值, 再或者想要填充为其他值</span></span><br><span class="line">material temp; </span><br><span class="line">temp.mass = <span class="number">0.0</span>;</span><br><span class="line">temp.speed = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; i++ )</span><br><span class="line">&#123;</span><br><span class="line"> temp.Vx[i] = <span class="number">0.0</span>;</span><br><span class="line"> temp.Vy[i] = <span class="number">0.0</span>;</span><br><span class="line"> temp.Vz[i] = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">material_list.<span class="built_in">assign</span>(<span class="number">3</span>,temp); </span><br><span class="line"><span class="comment">//assign函数会将material的大小调整为3, 并将所有值填充为temp</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="3-需要注意的参数类型"><a href="#3-需要注意的参数类型" class="headerlink" title="3. 需要注意的参数类型"></a>3. 需要注意的参数类型</h3><ul><li>数组: 在Fortran中,数组的索引序号默认是从<code>1</code>开始, 而在C++中序号是从<code>0</code>开始. 这要求我们在使用循环操作数组时要注意索引序号. 其次, 在存储数据时, Fortran是使用列主序, 即一个二维数组(3,4)表示的是3列4行. 而在c++中二维数组[3,4]表示的是3行4列</li></ul><blockquote><p>Fortran和C++数组主要的区别：</p><ol><li><strong>索引起始位置</strong>：在Fortran中, 数组的索引默认从1开始, 并且可以自定义索引序号. 而在C++中, 数组的索引始终从0开始. </li><li><strong>内存布局</strong>：Fortran使用列优先(column-major)顺序存储多维数组, 而C++(和大多数其他C风格的语言)使用行优先(row-major)顺序存储多维数组. </li><li><strong>动态数组</strong>：在Fortran中, 可以很容易地创建动态数组, 而在C++中, 创建动态数组需要更多的工作. 不过, C++提供了<code>std::vector</code>这样的容器类, 可以方便地创建和管理动态数组. </li><li><strong>数组作为函数参数</strong>：在Fortran中, 当数组作为函数参数时, 会传递数组的引用, 而不是数组本身. 这意味着, 如果在函数内部修改了数组, 那么在函数外部的数组也会被修改. 在C++中, 如果你直接将数组作为函数参数, 那么实际上传递的是数组的指针, 如果你想要达到和Fortran相同的效果, 你需要显式地使用引用或者指针. </li><li><strong>数组大小</strong>：在Fortran中, 数组本身知道其大小, 而在C++中, 原生数组不知道其大小, 你需要自己保持对数组大小的跟踪. 不过, C++的<code>std::array</code>和<code>std::vector</code>等容器类知道它们的大小. </li></ol></blockquote><ul><li>数组的运算: 在Fortran中, 对于<code>数组</code>可以直接使用<code>+ - * / **</code>等运算符号, 其意义为数组中对应位置的元素相加, 减, 赋值. </li></ul><p>例如:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>:: i(<span class="number">3</span>),j(<span class="number">3</span>)</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line">j = i</span><br><span class="line">i = i - j</span><br></pre></td></tr></table></figure><p>在这段代码中, 定义了两个长度为3的一维数组. </p><blockquote><p>第2行, 将<code>i</code>中的元素全部赋值为<code>1</code>. </p><p>第3行, 将<code>i</code>中的每一个元素都加<code>1</code>, <code>i</code>中所有元素变为<code>2</code>.  </p><p>第4行, 将<code>i</code>中元素的值,对应赋值给<code>j</code>数组, <code>j</code>中元素也都变为了<code>2</code>.  </p><p>第5行, 将<code>i</code>中的元素对应减去<code>j</code>中的元素并赋值给<code>i</code>,  这时, <code>i</code>中的元素全部变为了<code>1</code>.  </p></blockquote><p>这些在C++中是无法直接做到的, 可以借助一些库或者使用循环或者STL中的一些标准函数来完成这些操作. </p><ul><li><p><code>copy</code>从一个数组复制到另一个数组 (std::copy(first,last,dest)前两个参数控制复制到数组的开始和结尾, 第三个为要复制的数组)</p></li><li><p><code>fill</code>填充数组,用于数组的初始化 (std::fill(first,last,init)前两个控制范围,最后一个为填充值)</p></li><li><p><code>transform</code>转换</p><blockquote><p><code>transform</code>算法接受一个或两个输入范围, 以及一个输出范围, 并根据提供的一元函数对象或二元函数对象对”输入范围内的元素” 进行转换;</p><ul><li><code>InputIt first1</code>参数: 输入容器的起始迭代器(包含);</li><li><code>InputIt last1</code>参数: 输入容器的终止迭代器(不包含);</li><li><code>InputIt2 first2</code>参数: 第二个输入容器的起始迭代器(包含);</li><li><code>OutputIt d_first</code>参数: 输出容器的开始迭代器, 输出元素个数根据输入元素的范围确定,transform会将变换结果存储到输出容器中;</li><li><code>UnaryOperation unary_op</code>参数: 一元函数对象, 将输入容器的每个元素输入到该一元函数对象中, 将计算结果输出到输出容器中;</li></ul></blockquote></li></ul><h2 id="三、运算符号"><a href="#三、运算符号" class="headerlink" title="三、运算符号"></a>三、运算符号</h2><ul><li><p><code>+</code> <code>-</code> <code>*</code> <code>/</code> 都可以直接转换, 除了上面提到的应用在数组的计算上时</p></li><li><p><code>**</code>幂乘运算在c++中可使用<code>#include &lt;cmath&gt;</code>库中的<code>pow</code>来代替</p></li></ul><blockquote><p>用法: <code>std::pow(底数,指数)</code></p></blockquote><ul><li>求余<code>mod()</code>在c++中为<code>%</code></li><li>在c++中, 还有<code>--</code>和<code>++</code>等自减和自增运算, 注意其在使用时前缀和后缀的区别: 可以理解为<code>前缀既算值又变, 后缀只算值不变</code>. 当然这句话仅对其所在的一个语句生效, 无论是自增还是自减, 在这条语句结束后, 数值都发生了改变. </li></ul><blockquote><p>例如: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">b = ++a; <span class="comment">//前缀自增a变为了11, 其参与计算的值也变为11, b=11, a=11</span></span><br><span class="line">b = a++; <span class="comment">//后缀自增a从上面的11变为了12, 但在这条语句中a参与计算的值还是11, b=11, a=11, 结束后a=12</span></span><br><span class="line">b = a; <span class="comment">//在上面的语句结束后a参与计算的值变为了12, b=12, a=12</span></span><br></pre></td></tr></table></figure><p>在上面的基础上, <code>b=++a--;</code>中的a b参与计算的值分别为多少? 该语句结束后a b的值又是多少? </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b=<span class="number">13</span> a=<span class="number">13</span>;</span><br><span class="line">b=<span class="number">13</span> a=<span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>同时这两个运算符的优先级是要高于其它的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">1</span> + a--; <span class="comment">//先计算a--再计算+1</span></span><br></pre></td></tr></table></figure><p>三个运算符相连时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = a++<span class="number">-1</span>; <span class="comment">//等价于b=(a++)-1</span></span><br><span class="line">b = a+++<span class="number">1</span>; <span class="comment">//等价于b=(a++)+1, 但不建议这样做</span></span><br></pre></td></tr></table></figure></blockquote><p>C++中内置了(cmath)一些数学运算函数, 下面是常用的一些函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cos</span><span class="params">(<span class="type">double</span>)</span></span>; <span class="comment">//返回弧度角的余弦</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sin</span><span class="params">(<span class="type">double</span>)</span></span>; <span class="comment">//正弦</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">tan</span><span class="params">(<span class="type">double</span>)</span></span>; <span class="comment">//正切</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">log</span><span class="params">(<span class="type">double</span>)</span></span>; <span class="comment">//返回输入参数的自然对数-ln</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>; <span class="comment">//返回第一个参数的第二个参数次方</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hypot</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>; <span class="comment">//返回两个参数平方和的平方根</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span>)</span></span>; <span class="comment">//返回参数的平方根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">//返回整数的绝对值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fabs</span><span class="params">(<span class="type">double</span>)</span></span>; <span class="comment">//返回浮点数的绝对值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">floor</span><span class="params">(<span class="type">double</span>)</span></span>; <span class="comment">//返回小于或等于传入的参数的最大整数</span></span><br></pre></td></tr></table></figure><h2 id="四、控制结构"><a href="#四、控制结构" class="headerlink" title="四、控制结构"></a>四、控制结构</h2><h3 id="1-循环结构"><a href="#1-循环结构" class="headerlink" title="1. 循环结构"></a>1. 循环结构</h3><p>在Fortran中, 循环结构有两种<code>do</code>和<code>do while</code>. 分别对应着c++中的<code>for</code>和<code>while</code>. 除此之外, c++还有一种结构<code>do ... while</code>. 它与<code>while</code>的区别在于: <code>while</code>是先判断后执行, <code>do ... while</code>是先执行后判断. </p><p>循环控制语句对应关系:</p><ul><li><code>exit</code>: 在c++中为<code>break</code></li><li><code>cycle</code>: 在c++中为<code>continue</code></li></ul><blockquote><p>此外, 在c++中还有一种控制语句<code>goto</code>即跳转到某一被标记的语句执行. 但是, 在程序中<code>不建议</code>使用该语句! </p></blockquote><h3 id="2-判断语句"><a href="#2-判断语句" class="headerlink" title="2. 判断语句"></a>2. 判断语句</h3><p>在Fortran中, 判断语句有<code>if-then</code>, <code>if-then-else</code> 和<code>if-else if-else</code>. 这与c++中的<code>if</code>, <code>if-else</code>以及<code>if-else if-else</code>是一一对应的. 他们的用法相同.</p><p>需要注意的是, 在Fortran中的<code>select case</code>语句与c++中的<code>switch</code>语句有一些使用上的差别.</p><blockquote><p><code>select case</code>语句在运行选择的<code>case</code>后会结束<code>select</code>也就是只进行一次选择. 而在c++的<code>switch</code>语句中, 如果不使用<code>break</code>语句, 会一直进行<code>switch</code>. </p><p>相当于Fortran的选择语句中, 所有的<code>case</code>都带有一个<code>break</code>. </p><p>如果将<code>do while(.true.)</code>与<code>select case()</code>语句结合, 当某个case中有一个<code>exit</code>语句, 它会结束do while的循环. 而在c++中, <code>while</code>和<code>switch</code>都使用<code>break</code>来打断, 所以case中的<code>break</code>只会结束switch而不会结束while(true). 因此, 在转换时需要增加while结束的条件.  </p><p>例如:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    key = Keyord(kw,nbkw)</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">case</span>(key)</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">exit</span></span><br><span class="line">        <span class="keyword">case</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">call</span> GetString(Title)</span><br><span class="line">        <span class="keyword">case</span>(<span class="number">3</span>)</span><br><span class="line">        nb_particle = GetInt()</span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(a,i12)&quot;</span>) <span class="string">&#x27;Number of particles = &#x27;</span>,nb_particle</span><br><span class="line">        <span class="built_in">write</span>(<span class="keyword">iomsg</span>,<span class="string">&quot;(a,i12)&quot;</span>) <span class="string">&#x27;Number of particles = &#x27;</span>,nb_particle</span><br><span class="line">       <span class="built_in">allocate</span>(particle_list(nb_particle))</span><br><span class="line">        <span class="keyword">call</span> InitParticle()</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">        <span class="keyword">stop</span> <span class="string">&#x27;STOP - Error encountered in reading data&#x27;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br></pre></td></tr></table></figure><p>改为c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    key = <span class="built_in">KeyWord</span>(kw, nbkw);</span><br><span class="line">    <span class="keyword">switch</span> (key + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            Title = <span class="built_in">GetString</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            nb_particle = <span class="built_in">GetInt</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Number of particles = &quot;</span> &lt;&lt; nb_particle &lt;&lt; endl;</span><br><span class="line">            outfile &lt;&lt; <span class="string">&quot;Number of particles = &quot;</span> &lt;&lt; nb_particle &lt;&lt; endl;</span><br><span class="line">            particle_list.<span class="built_in">assign</span>(nb_particle, <span class="built_in">Particle</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;STOP - Error encountered in reading data&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用<code>do...while</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">key = <span class="built_in">KeyWord</span>(kw, nbkw);</span><br><span class="line">   <span class="keyword">switch</span> (key + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(key != <span class="number">0</span>);</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、子程序和函数子程序"><a href="#五、子程序和函数子程序" class="headerlink" title="五、子程序和函数子程序"></a>五、子程序和函数子程序</h2><p>对于独立的子程序 (不引用其他的module) 可直接使用<code>void</code>函数替代. 对于<code>function</code>函数子程序可以对应类型的函数替代, 即有返回值的函数. </p><p>例子:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sum100(sum_)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">out</span>)::sum_</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line">sum_ = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">100</span></span><br><span class="line">sum_ = sum_ +i</span><br><span class="line">endo</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sum100</span><br></pre></td></tr></table></figure><p>这个程序会计算1~100的和并输出到sum这个量</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> sum100(sum1)</span><br></pre></td></tr></table></figure><p>转换成c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sum100</span> <span class="params">(<span class="type">int</span> &amp;sum_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) <span class="comment">//在循环体中Fortran判断结束的条件默认是小于等于</span></span><br><span class="line">&#123;</span><br><span class="line">sum_ += i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sum100</span>(sum);</span><br></pre></td></tr></table></figure><blockquote><p> 这类子程序的特点: 有明确的输入的输出, 全部工作都在子程序内完成, 不牵扯其他的module或子程序. </p></blockquote><hr><h3 id="关于参数的传递"><a href="#关于参数的传递" class="headerlink" title="关于参数的传递"></a>关于参数的传递</h3><p>在Fortran的子程序中, 参数的传递默认按照<code>引用</code>来传递. 即, 如果你在子程序内改变了这一变量(未规定为<code>in</code>类型), 外部的变量也会改变. 这与C++中使用<code>&amp;</code>符号传递参数的作用相同.</p><p>有些子程序, 在编写时, 未规定传入参数的类型为输入(<code>in</code>)还是输出(<code>out</code>). 在转换为C++时, 需要注意分辨是否需要改变外部的变量.</p><blockquote><p>在转换时, <code>in</code>类型的变量在子程序中是无法改变的, 因此我们在写c++的函数时, 不需要加<code>&amp;</code>. 而对于<code>out</code>类型的变量, 必须要加上<code>&amp;</code>, 否则不能改变外部的变量.</p><p>对于全局变量而言, 不需要作为传入参数. 可以直接使用并改变该变量的值.</p></blockquote><h2 id="六、模块-Module"><a href="#六、模块-Module" class="headerlink" title="六、模块(Module)"></a>六、模块(Module)</h2><p>对于这类文件, 可以使用<code>头文件</code>+<code>全局变量</code>+<code>源文件</code>的模式</p><p>对于<code>全局常量和结构体</code>, 只需要定义在<code>头文件</code>内即可. 在头文件中, 结构体的定义和常量的定义不使用<code>extern</code>声明. </p><p>在编写代码时, 可以使用<code>namespace</code>对不同文件的参数作区分, 防止出现命名上的冲突 (可不使用). 在c++中, 还可以使用<code>class</code>来更好的组织和封装数据及函数. </p><p>如果原模块没有私有变量, 可直接使用<code>namespace</code>.</p><blockquote><h3 id="以下是GPT对两种方式的优缺点的判断"><a href="#以下是GPT对两种方式的优缺点的判断" class="headerlink" title="以下是GPT对两种方式的优缺点的判断:"></a>以下是GPT对两种方式的优缺点的判断:</h3><p><strong>使用<code>namespace</code>的优点：</strong></p><ol><li><code>namespace</code>可以用来避免命名冲突. 你可以在不同的<code>namespace</code>中定义同名的函数或变量, 而不会产生冲突. </li><li><code>namespace</code>可以嵌套, 这使得你可以更好地组织你的代码. </li><li><code>namespace</code>可以在多个文件中定义, 这使得你可以将相关的代码和数据分散在多个文件中. </li></ol><p><strong>使用<code>namespace</code>的缺点：</strong></p><ol><li><code>namespace</code>不能用来封装数据. 在<code>namespace</code>中定义的所有函数和变量都是公开的, 任何人都可以访问. </li><li><code>namespace</code>不能用来实现面向对象编程的特性, 如继承和多态. </li></ol><p><strong>使用<code>class</code>的优点：</strong></p><ol><li><code>class</code>可以用来封装数据和函数. 你可以控制哪些数据和函数是公开的(<code>public</code>), 哪些是私有的(<code>private</code>). </li><li><code>class</code>可以用来实现面向对象编程的特性, 如继承和多态. </li><li><code>class</code>可以用来创建对象, 这使得你可以在运行时动态地创建和销毁数据和函数. </li></ol><p><strong>使用<code>class</code>的缺点：</strong></p><ol><li><code>class</code>不能像<code>namespace</code>那样用来避免命名冲突. 在同一个<code>namespace</code>中, 不能有两个同名的<code>class</code>. </li><li><code>class</code>不能在多个文件中定义. 一个<code>class</code>的所有成员都必须在同一个文件中定义. </li></ol></blockquote><hr><p>欢迎补充和指正</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fortran </tag>
            
            <tag> C++ </tag>
            
            <tag> 语言转换 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 安装及配置教程</title>
      <link href="/2024/05/cbf708ce.html"/>
      <url>/2024/05/cbf708ce.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1. 下载安装包"></a>1. 下载安装包</h2><p>打开<a href="https://git-scm.com/downloads">Git官网</a>下载安装包, 嫌速度慢可以使用下面的链接下载</p><p>蓝奏云(不限速)：<a href="https://wwt.lanzoul.com/b00rn0x92b密码:gdo1">https://wwt.lanzoul.com/b00rn0x92b密码:gdo1</a></p><p>百度云(会员)：<a href="https://pan.baidu.com/s/1QRxu8qYWI0rAOFqX9PT01g?pwd=1111提取码">https://pan.baidu.com/s/1QRxu8qYWI0rAOFqX9PT01g?pwd=1111提取码</a>: 1111</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071352070.png" alt="image-20240507135225158"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071355950.png" alt="image-20240507135511255"></p><p>下载完成后，双击打开安装包</p><h2 id="2-开始安装"><a href="#2-开始安装" class="headerlink" title="2. 开始安装"></a>2. 开始安装</h2><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071437531.png" alt="image-20240507143702625"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071438756.png" alt="image-20240507143826832"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071442644.png" alt="image-20240507144255668"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071443653.png" alt="image-20240507144334722"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071446143.png" alt="image-20240507144644121"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071449923.png" alt="image-20240507144955949"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071451220.png" alt="image-20240507145114067"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071455747.png" alt="image-20240507145517679"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071456870.png" alt="image-20240507145603852"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071502727.png" alt="image-20240507150213743"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071504531.png" alt="image-20240507150434447"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071515269.png" alt="image-20240507151557254"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071518820.png" alt="image-20240507151819793"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071520714.png" alt="image-20240507152039835"></p><p>点击安装, 等待安装完成</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071523934.png" alt="image-20240507152351881"></p><h2 id="3-配置Git"><a href="#3-配置Git" class="headerlink" title="3. 配置Git"></a>3. 配置Git</h2><h3 id="1-配置用户信息"><a href="#1-配置用户信息" class="headerlink" title="(1). 配置用户信息"></a>(1). 配置用户信息</h3><p>输入以下命令配置用户信息, 修改成自己的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;liudh&quot;</span><br><span class="line">git config --global user.email &quot;xxxxxxx@xx.com&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071525435.png" alt="image-20240507152545795"></p><p>可以使用以下命令查看配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><h3 id="2-设置代理-需自备代理"><a href="#2-设置代理-需自备代理" class="headerlink" title="(2). 设置代理(需自备代理)"></a>(2). 设置代理(需自备代理)</h3><p>在向<code>Github</code>推送时, 经常会遇到443等连接问题, 即时自己打开了代理软件依旧不能成功上传. 这是因为Git没有配置代理</p><p>使用以下命令查看代理配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --get http.proxy</span><br><span class="line">git config --global --get https.proxy</span><br></pre></td></tr></table></figure><p>如果没有内容说明没有代理</p><p>下面使用以下命令配置代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy 127.0.0.1:7890</span><br><span class="line">git config --global https.proxy 127.0.0.1:7890</span><br></pre></td></tr></table></figure><blockquote><p>具体地址和端口在系统代理的位置查看</p></blockquote><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405071538016.png" alt="image-20240507153841415"></p><p>如果不想使用代理, 使用以下命令取消</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><hr><p>至此, 就可以愉快地开始使用Git了</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 安装教程 </tag>
            
            <tag> Windows </tag>
            
            <tag> 教程及说明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu搭建Webdav</title>
      <link href="/2024/05/e8755f24.html"/>
      <url>/2024/05/e8755f24.html</url>
      
        <content type="html"><![CDATA[<p>参考文章: <a href="https://colzry.github.io/posts/linux服务/linux搭建webdav服务/">Linux搭建WebDav服务 - Colzry’s Blog</a></p><blockquote><p>以下操作如出现无权限的情况, 可根据自己实际情况, 使用sudo提权解决</p></blockquote><h2 id="步骤一-安装WebDAV服务"><a href="#步骤一-安装WebDAV服务" class="headerlink" title="步骤一: 安装WebDAV服务"></a>步骤一: 安装WebDAV服务</h2><p>首先, 我们需要安装<a href="https://github.com/hacdias/webdav">WebDAV Server</a>, 打开页面下载合适的版本, 本文以<a href="https://github.com/hacdias/webdav/releases/download/v4.2.0/linux-amd64-webdav.tar.gz"><code>linux-amd64-webdav.tar.gz</code></a>为例, 其中<code>amd64</code>表示<code>x64</code>架构</p><p>然后, 解压并移动文件到<code>/usr/bin/</code>, 其余的README和LICENSE文件可删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf linux-amd64-webdav.tar.gz</span><br><span class="line">mv webdav /usr/bin/</span><br></pre></td></tr></table></figure><h2 id="步骤二-配置WebDAV服务"><a href="#步骤二-配置WebDAV服务" class="headerlink" title="步骤二: 配置WebDAV服务"></a>步骤二: 配置WebDAV服务</h2><p>安装完成后, 我们需要对WebDAV服务进行配置. 首先, 我们需要创建一个目录用于存储WebDAV文件. 可以使用以下命令创建一个名为 <code>/home/liudh/webdav</code>的目录, 注意修改用户名<code>liudh</code>为自己的用户名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/liudh/webdav</span><br></pre></td></tr></table></figure><p>然后, 我们需要编辑WebDAV服务的配置文件. 可以使用以下命令打开配置文件进行编辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/webdav_config.yaml</span><br></pre></td></tr></table></figure><p>在配置文件中, 我们需要添加以下内容. </p><blockquote><p>注意根据自己的实际修改, 端口号可修改, 用户名, 密码, 用户空间均修改为自己的内容</p><p>注意缩进, <code>cors</code>和<code>users</code>后的参数均需要两个空格的缩进, 带<code>-</code>的参数需再缩进两个空格(四个)</p><p>每一个参数<code>:</code>后均有一个空格</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># Server related settings</span><br><span class="line">address: 0.0.0.0</span><br><span class="line">port: 10101</span><br><span class="line"># 如果无需验证填 false</span><br><span class="line">auth: true</span><br><span class="line"># 如果不需要 https 则填 false</span><br><span class="line">tls: false</span><br><span class="line"># https证书和密钥，如果 tls 为 false，cert 和 key 不需要</span><br><span class="line"># cert: cert_path</span><br><span class="line"># key: key_path</span><br><span class="line"># 访问前缀，建议默认</span><br><span class="line">prefix: /</span><br><span class="line">debug: false</span><br><span class="line"># 如果 auth 为 false 生效，文件共享的路径</span><br><span class="line">scope: .</span><br><span class="line">modify: true</span><br><span class="line">rules: []</span><br><span class="line"># 跨域设置</span><br><span class="line">cors:</span><br><span class="line">  enabled: true</span><br><span class="line">  credentials: true</span><br><span class="line">  allowed_headers:</span><br><span class="line">    - Depth</span><br><span class="line">  allowed_hosts:</span><br><span class="line">    - http://localhost:10101</span><br><span class="line">  allowed_methods:</span><br><span class="line">    - GET</span><br><span class="line">  exposed_headers:</span><br><span class="line">    - Content-Length</span><br><span class="line">    - Content-Range</span><br><span class="line"># 用户信息，如果 auth 为 true 生效</span><br><span class="line">users:</span><br><span class="line">  - username: liudh</span><br><span class="line">    password: passwd</span><br><span class="line">    scope: /home/liudh/webdav/</span><br><span class="line">    # 是否允许修改</span><br><span class="line">    modify: true</span><br><span class="line"># 可以根据此模板继续添加其他用户</span><br></pre></td></tr></table></figure><p>保存并关闭配置文件后, 使用以下命令启动服务, 显示地址和端口即为启动成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/webdav -c /opt/webdav_config.yaml</span><br></pre></td></tr></table></figure><h2 id="步骤三-添加守护进程"><a href="#步骤三-添加守护进程" class="headerlink" title="步骤三: 添加守护进程"></a>步骤三: 添加守护进程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/webdav.service</span><br></pre></td></tr></table></figure><p>将以下内容添加到文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=WebDAV server</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/usr/bin/webdav -c /opt/webdav_config.yaml</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>保存并关闭, 然后运行以下命令, 可能会要求输入用户密码验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start webdav.service</span><br><span class="line">systemctl status webdav.service</span><br><span class="line">systemctl enable webdav.service</span><br></pre></td></tr></table></figure><p>之后修改配置文件后, 可以使用以下命令重启服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart webdav.service</span><br></pre></td></tr></table></figure><h2 id="步骤四-挂载webdav测试服务"><a href="#步骤四-挂载webdav测试服务" class="headerlink" title="步骤四: 挂载webdav测试服务"></a>步骤四: 挂载webdav测试服务</h2><p>使用任意webdav挂载软件, 挂载测试, 注意填写参数如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">协议: http # 如果配置了ssl证书就用https</span><br><span class="line">主机: # 设备的ip地址或域名, 如果是本地设备就填局域网的IP   !!!域名或IP结尾要加上 / 这个符号</span><br><span class="line"># 例如: 192.168.1.100:10101/  如果端口是单独填写就填: 192.168.1.100/</span><br><span class="line">端口: 10101 # 注意配置防火墙开放端口, 本地设备一般不需要</span><br><span class="line">用户名: liudh # 都改成自己的</span><br><span class="line">密码: passwd</span><br></pre></td></tr></table></figure><p>之后就可以上传下载文件测试一下了, 如果有错误就用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status webdav.service</span><br></pre></td></tr></table></figure><p>查看错误日志. </p><blockquote><p>如果填对了账户还显示密码错误, 大概率是前面配置文件时缩进出错了, 回头检查一下</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webdav </tag>
            
            <tag> 云服务 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git撤销操作</title>
      <link href="/2024/05/a2778edb.html"/>
      <url>/2024/05/a2778edb.html</url>
      
        <content type="html"><![CDATA[<h2 id="Git-撤销操作"><a href="#Git-撤销操作" class="headerlink" title="Git 撤销操作"></a>Git 撤销操作</h2><p>学习视频：<a href="https://www.bilibili.com/video/BV1ne4y1S7S9/?share_source=copy_web&amp;vd_source=374d2addde246f63ad679abfc5ab707c">十分钟学会常用git撤销操作，全面掌握git的时光机</a> </p><h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><blockquote><ul><li><p>Disk</p><ul><li>Init</li></ul></li><li><p>Staging(add)</p><ul><li>Init</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><h2 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h2><p>仅对文件做了修改但未add, 想要返回到初始状态</p><p>状态如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><p>想要删除此修改, 只需使用以下命令, <code>&lt;filename&gt;</code>表示要恢复的文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;filename&gt;</span><br><span class="line">或者</span><br><span class="line">git restore &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>操作后恢复到原始状态</p><blockquote><ul><li><p>Disk</p><ul><li>Init~~ — change~~</li></ul></li><li><p>Staging(add)</p><ul><li>Init </li></ul></li><li><p>Local-git(commit)</p><ul><li>Init</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><h2 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h2><p>若文件已经add</p><p>状态如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init — change</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><ol><li>若仅取消暂存, 可以使用下面的命令恢复</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;filename&gt;</span><br><span class="line">或者</span><br><span class="line">git restore --staged &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>此操作仅会把文件重暂存区取出, 不会删除修改</p><p>操作后恢复到以下状态</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init~~ — change~~</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><ol><li>若想要连修改一起撤回, 使用以下命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>HEAD</code>表示最近的一次提交, 类似的<code>HEAD~1</code>表示倒数第二次提交</p></blockquote><h2 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h2><p>更改已经提交, 也就是如下状态</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init — change</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init — change</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><ol><li>此时要想仅取消此提交不撤销更改, 使用以下命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><p>此时状态如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init — change</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init<del>—change</del></li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><ol><li>若想要将暂存一起取消, 则不使用<code>--soft</code>参数, 即</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD~1</span><br><span class="line">等价于</span><br><span class="line">git reset --mixed HEAD~1</span><br></pre></td></tr></table></figure><p>此时状态如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init <del>— change</del></li></ul></li><li><p>Local-git(commit)</p><ul><li>Init<del>—change</del></li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><ol><li>若想完全回到上一次提交(本提交的前一次), 文件的修改也完全恢复到该次提交的状态. 使用以下命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~1</span><br></pre></td></tr></table></figure><p>此时恢复到如下状态</p><blockquote><ul><li><p>Disk</p><ul><li>Init <del>— change</del></li></ul></li><li><p>Staging(add)</p><ul><li>Init <del>— change</del></li></ul></li><li><p>Local-git(commit)</p><ul><li>Init<del>—change</del></li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><hr><p>对于以上的恢复, 还有一种方式, 即在<code>change</code>的基础上加一个<code>-change</code>使文件在结果上恢复到上一次提交的状态</p><p>使用以下命令可以实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure><p>效果如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change — <code>-change</code>    ==  Init</li></ul></li><li><p>Staging(add)</p><ul><li>Init — change— <code>-change</code></li></ul></li><li><p>Local-git(commit)</p><ul><li>Init—change— <code>-change</code></li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><p>此命令还可以用于撤销之前的某一次提交的修改</p><p>例如, 当前状态如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change1 —change2</li></ul></li><li><p>Staging(add)</p><ul><li>Init — change1 —change2</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init — change1 —change2</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><p>使用如下命令, 撤销<code>change1</code>, <code>&lt;hash&gt;</code>指要撤销提交的hash值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD~1</span><br><span class="line">或者</span><br><span class="line">git revert &lt;hash&gt;</span><br></pre></td></tr></table></figure><p>达到如下效果</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change1 —change2 —<code>-change1</code></li></ul></li><li><p>Staging(add)</p><ul><li>Init — change1 —change2—<code>-change1</code></li></ul></li><li><p>Local-git(commit)</p><ul><li>Init — change1 —change2—<code>-change1</code></li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><p>此命令在远程提交的撤销中起着重要作用, 见下文</p><hr><h2 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h2><p>修改已经push到了Github上</p><p>状态如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init — change</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init — change</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init — change</li></ul></li></ul></blockquote><ol><li>对于公有分支(不止一人使用该分支的情况), 只能使用<code>revert</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure><p>恢复到如下状态</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change — <code>-change</code> </li></ul></li><li><p>Staging(add)</p><ul><li>Init — change— <code>-change</code></li></ul></li><li><p>Local-git(commit)</p><ul><li>Init—change— <code>-change</code></li></ul></li><li><p>Remote-git(push)</p><ul><li>Init —change— <code>-change</code></li></ul></li></ul></blockquote><ol><li>对于个人分支, <code>reset</code>和<code>revert</code>均可, 但若使用<code>reset</code>恢复了提交, 在push时需要加上<code>-f</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><blockquote><p><code>-f</code>表示强制, 在共有分支应避免使用, 或者禁止使用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
            <tag> 工作流程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu22.04双系统安装教程</title>
      <link href="/2024/05/deb026e9.html"/>
      <url>/2024/05/deb026e9.html</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote><p>良好的网络环境</p><p>一块8g以上的U盘(注意备份数据, 该U盘会被格式化)</p><p>Windows电脑</p></blockquote><h2 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h2><blockquote><ul><li>双核2 GHz处理器或更高</li><li>4 GB系统内存</li><li>25 GB磁盘存储空间</li></ul></blockquote><h2 id="装机需谨慎-做好数据备份"><a href="#装机需谨慎-做好数据备份" class="headerlink" title="装机需谨慎, 做好数据备份"></a>装机需谨慎, 做好数据备份</h2><h2 id="1-系统镜像的下载"><a href="#1-系统镜像的下载" class="headerlink" title="1. 系统镜像的下载"></a>1. 系统镜像的下载</h2><p>打开<a href="https://cn.ubuntu.com/download">Ubuntu系统下载 | Ubuntu</a> 此页面,点击<strong>下载Ubuntu桌面版</strong>, </p><p>或者从网盘中下载: </p><p>百度云：<a href="https://pan.baidu.com/s/1QRxu8qYWI0rAOFqX9PT01g?pwd=1111">https://pan.baidu.com/s/1QRxu8qYWI0rAOFqX9PT01g?pwd=1111</a> 提取码: 1111</p><p><img title="" src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051039370.png" alt="" data-align="center"></p><p>再选择Ubuntu22.04.4 LTS,点击<strong>下载22.04.4</strong></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051041029.png" title="" alt="" data-align="center"></p><p>将此文件下载保存至<strong>易寻找的位置</strong>, 以<code>F:/Ubuntu</code>为例, 稍后会使用. </p><p>其他版本可在官网下载<a href="https://ubuntu.com/download">Get Ubuntu | Download | Ubuntu</a> 安装步骤大致相同</p><h2 id="2-安装写盘工具Rufus"><a href="#2-安装写盘工具Rufus" class="headerlink" title="2. 安装写盘工具Rufus"></a>2. 安装写盘工具Rufus</h2><p>打开<a href="https://rufus.ie/zh/">Rufus - 轻松创建 USB 启动盘</a> 页面, 找到下载,选择Windows x64平台的便携版, 下载打开即用. </p><p><img title="" src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051041560.png" alt="Rufus" width="427" data-align="center"></p><p>插入U盘,打开软件</p><p><img title="" src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051042395.png" alt="rufus" data-align="center" width="330"></p><p>点击选择, 设备选择刚刚插入的U盘, 镜像文件点击右侧<strong>选择</strong>, 选中刚刚下载的镜像文件, 我的是位于<code>F:/Ubuntu</code>, 选项如下图即可, 点击开始, 等待写入完成, 点击关闭, 弹出U盘</p><p><img title="" src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051042474.png" alt="写盘例子" data-align="center" width="343"></p><h2 id="3-关闭Bitlocker或者备份Bitlocker恢复密钥"><a href="#3-关闭Bitlocker或者备份Bitlocker恢复密钥" class="headerlink" title="3. 关闭Bitlocker或者备份Bitlocker恢复密钥"></a>3. 关闭Bitlocker或者备份Bitlocker恢复密钥</h2><p>如果硬盘设置了Bitlocker, 一定要提前找到恢复密钥, 可以先保存到手机上, 一般在微软账户里会有备份<a href="https://account.microsoft.com/devices/recoverykey">恢复密钥</a></p><p>如果找不到了, 开始前一定要关闭Bitlocker. 改动引导顺序和安全启动选项会触发BitLocker, 要求输入恢复密钥. 否则你将无法打开Windows系统或已加密数据</p><p>关闭过程时间可能较长</p><h2 id="4-压缩硬盘空间-双系统需要-若全新安装不需要"><a href="#4-压缩硬盘空间-双系统需要-若全新安装不需要" class="headerlink" title="4. 压缩硬盘空间(双系统需要,若全新安装不需要)"></a>4. 压缩硬盘空间(双系统需要,若全新安装不需要)</h2><p>打开Windows的磁盘管理工具, 右键开始菜单图标, 选择磁盘管理</p><p><img title="" src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051042717.png" alt="磁盘管理" data-align="center" width="99"></p><p>找到需要压缩的分区, 右键点击压缩卷</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051042369.png" title="" alt="" data-align="center"></p><p>输入合适的空间, 建议40GB以上, 最低不低于官网要求的25GB, 点击压缩即可</p><p><img title="" src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051042487.png" alt="压缩盘" data-align="center" width="523"></p><h2 id="5-关闭安全启动-设置U盘启动"><a href="#5-关闭安全启动-设置U盘启动" class="headerlink" title="5. 关闭安全启动, 设置U盘启动"></a>5. 关闭安全启动, 设置U盘启动</h2><p>网络上搜索自己的电脑进入BIOS的方法, surface go系列是按音量加键, 一般电脑是按F2或者F10, 以自己的电脑为准, 进入BIOS,关闭安全启动, 设置启动顺序, 将<strong>USB设备</strong>设置到最上面, 由于每台设备情况不同, 此处设置请自行搜索自己电脑的教程. </p><blockquote><p>surface go系列安全启动会有三个选项</p><ul><li><p>微软</p></li><li><p>微软和第三方</p></li><li><p>关闭</p></li></ul><p>选择微软和第三方即可</p></blockquote><h2 id="6-插入U盘-启动电脑"><a href="#6-插入U盘-启动电脑" class="headerlink" title="6. 插入U盘, 启动电脑"></a>6. 插入U盘, 启动电脑</h2><p>在上一步设置完成之后, 若处于开机状态就插入U盘, 重启电脑, 引导位置选择</p><blockquote><p> Try or Install Ubuntu</p></blockquote><p><img title="" src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051042783.png" alt="" data-align="center" width="411"></p><p>等待进入安装界面, 选择中文</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051042996.png" title="" alt="" data-align="center"></p><p>如果出现窗口显示不全, 点击试用Ubuntu,如果像我一样可以看到全部窗口, 就点击安装Ubuntu, 跳转到下面<a href="#开始安装">开始安装</a>教程</p><hr><p>点击试用之后, 会出现如下界面</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051043674.png" title="" alt="" data-align="center"></p><p>点击该图标, 再打开设置, 找到显示器, 缩放比例选择100%, 点击保存(我使用的虚拟机没有该选项, 就在红框的位置. 保存在夜灯右边位置, 修改后会出现)</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051043419.png" title="" alt="" data-align="center"></p><p>保存之后再选择安装Ubuntu就可以了</p><hr><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><p>键盘布局默认即可</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051043870.png" title="" alt="" data-align="center"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051043577.png" title="" alt="" data-align="center"></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051043254.png" title="" alt="" data-align="center"></p><hr><p>双系统手动分区</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051043453.png" title="" alt="" data-align="center"></p><p>建议分区</p><ol><li>创建交换空间</li></ol><blockquote><p>填写大小: 建议与内存大小相同, 4G 8G 16G都可</p><p>分区类型: 逻辑分区</p><p>新分区位置:空间起始分区(下面也都是这个不用改)</p><p>用于: 交换空间</p></blockquote><ol><li>创建根目录分区</li></ol><blockquote><p>填写大小: 如果空间太小就把剩下的全给根目录, 方便后面扩容, 如果空间充足就给20GB以上均可,主要存放系统文件和安装软件</p><p>分区类型: 主分区</p><p>新分区位置:空间起始分区(下面也都是这个不用改)</p><p>用于: Ext4 日志文件系统</p><p>挂载点: /</p></blockquote><p>可选分区</p><ol><li>创建引导分区(双系统同盘可不创建, 放置在Windows系统的引导分区里即可)</li></ol><blockquote><p>填写大小: 建议200MB-1024MB根据个人情况来,这里我给了500MB</p><p>分区类型: 主分区</p><p>新分区位置: 空间起始分区(下面也都是这个不用改)</p><p>用于: EFI</p></blockquote><ol><li>如果空间充足可给/home分区单独设置, 后面想扩容之类的就上面三个分区就可以了, 后面扩容完可以再分</li></ol><blockquote><p>填写大小: 20GB以上均可, 看个人使用情况, 存放用户文件, 类似Windows的Users目录</p><p>分区类型: 主分区</p><p>新分区位置:空间起始分区(下面也都是这个不用改)</p><p>用于: Ext4 日志文件系统</p><p>挂载点: /home</p></blockquote><p>最终效果如下</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051043246.png" title="" alt="" data-align="center"></p><hr><p> 点击<strong>现在安装</strong>  —&gt; <strong>继续</strong>, 时区选择上海, 点击<strong>继续</strong></p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051043725.png" title="" alt="" data-align="center"></p><p>用户信息按自己的填写即可. 可以勾选自动登录, 每次开机不需要选择用户, 自动登录.</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051043618.png" title="" alt="" data-align="center"></p><p>点击<strong>继续</strong>即可安装, 安装之后选择重启, 根据提示会让你拔掉U盘, 按ENTER(回车键)</p><hr><p>至此双系统就安装好了. 每次启动时, 系统会提示选择Ubuntu还是Windows系统一般是4个选项</p><blockquote><p>Ubuntu</p><p>Ubuntu高级设置</p><p>Windows</p><p>EFI</p></blockquote><p>顺序可能不同,名称仅为示例, 很容易识别</p><blockquote><p>若未关闭Bitlocker, 进入Windows系统需要输入一次恢复密钥, 下次进入就不需要了.</p></blockquote><p>如果安装没有什么问题, 之前下载的镜像文件就可以清理了</p>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 硬盘分区 </tag>
            
            <tag> 教程及说明 </tag>
            
            <tag> 系统安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 工作流程</title>
      <link href="/2024/04/5dbdb580.html"/>
      <url>/2024/04/5dbdb580.html</url>
      
        <content type="html"><![CDATA[<h2 id="Git-工作流程——以Github为例"><a href="#Git-工作流程——以Github为例" class="headerlink" title="Git 工作流程——以Github为例"></a>Git 工作流程——以Github为例</h2><p><strong>适用于个人和小团队的标准工作模式</strong></p><p>学习视频：<a href="https://www.bilibili.com/video/BV19e4y1q7JJ/?share_source=copy_web&amp;vd_source=374d2addde246f63ad679abfc5ab707c">十分钟学会正确的github工作流，和开源作者们使用同一套流程</a></p><p>假设项目初始内容如下</p><blockquote><ul><li><p>Github: </p><ul><li>main(master) 分支 Init 内容</li></ul></li><li><p>Loacl git: </p><ul><li>main(master) 分支 Init 内容</li></ul></li><li><p>DIsk: </p><ul><li>main(master) 分支 Init 内容（仅作理解）</li></ul></li></ul></blockquote><h2 id="1-建立个人工作分支"><a href="#1-建立个人工作分支" class="headerlink" title="1. 建立个人工作分支"></a>1. 建立个人工作分支</h2><p>使用如下命令创建一个个人工作的分支并切换到该分支上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b my-feature</span><br></pre></td></tr></table></figure><p>当前状态如下</p><blockquote><ul><li><p>Github: </p><ul><li>main(master) 分支 Init 内容</li></ul></li><li><p>Loacl git: </p><ul><li>main(master) 分支 Init 内容</li><li><code>my-feature分支 Init 内容</code></li></ul></li><li><p>DIsk: </p><ul><li><code>my-feature分支</code> Init 内容</li></ul></li></ul></blockquote><h2 id="2-对本地内容进行修改、提交、推送"><a href="#2-对本地内容进行修改、提交、推送" class="headerlink" title="2. 对本地内容进行修改、提交、推送"></a>2. 对本地内容进行修改、提交、推送</h2><h3 id="1-当前状态如下"><a href="#1-当前状态如下" class="headerlink" title="(1) 当前状态如下"></a>(1) 当前状态如下</h3><blockquote><ul><li><p>Github: </p><ul><li>main(master) 分支 Init 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 Init 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 <code>Init-changes</code> 内容</li></ul></li></ul></blockquote><p>使用<code>git diff</code>可查看对比做出修改的内容</p><h3 id="2-暂存更改内容"><a href="#2-暂存更改内容" class="headerlink" title="(2) 暂存更改内容"></a>(2) 暂存更改内容</h3><p>使用<code>git add &lt;filename&gt;</code>暂存已做出的修改</p><p>此时状态如下</p><blockquote><ul><li><p>Github: </p><ul><li>main(master) 分支 Init 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 <code>Init-changes</code> 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 Init-changes 内容</li></ul></li></ul></blockquote><h3 id="3-提交已暂存的更改"><a href="#3-提交已暂存的更改" class="headerlink" title="(3) 提交已暂存的更改"></a>(3) 提交已暂存的更改</h3><p>使用<code>git commit</code>命令提交</p><p>若想添加注释可使用如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;text&quot;</span><br></pre></td></tr></table></figure><p>此时状态如下</p><blockquote><ul><li><p>Github: </p><ul><li>main(master) 分支 Init 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 <code>Init-f-commit</code> 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 Init-f-commit 内容</li></ul></li></ul></blockquote><h3 id="4-将内容push到Github上"><a href="#4-将内容push到Github上" class="headerlink" title="(4) 将内容push到Github上"></a>(4) 将内容<code>push</code>到Github上</h3><p>使用<code>git push origin my-feature</code>将内容push到Github中自己的分支</p><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 <code>Init-f-commit</code> 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 Init-f-commit 内容</li></ul></li></ul></blockquote><p><strong>若此时GitHub中的main(master)分支有其他的修改或提交，须进行第三步<a href="#处理主分支的改变">处理主分支的改变</a></strong></p><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 <code>Init-update</code> 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 Init-f-commit 内容</li></ul></li></ul></blockquote><h2 id="3-处理主分支的改变"><a href="#3-处理主分支的改变" class="headerlink" title="3. 处理主分支的改变"></a>3. 处理主分支的改变</h2><h3 id="1-本地返回main-master-分支"><a href="#1-本地返回main-master-分支" class="headerlink" title="(1) 本地返回main(master)分支"></a>(1) 本地返回main(master)分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init-update 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li><code>main(master)分支 Init 内容</code></li></ul></li></ul></blockquote><h3 id="（2）拉取远程改变"><a href="#（2）拉取远程改变" class="headerlink" title="（2）拉取远程改变"></a>（2）拉取远程改变</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init-update 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 <code>Init-update</code> 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li>main(master)分支 <code>Init-update</code> 内容</li></ul></li></ul></blockquote><h3 id="3-切换回my-feature分支并合并代码"><a href="#3-切换回my-feature分支并合并代码" class="headerlink" title="(3) 切换回my-feature分支并合并代码"></a>(3) 切换回my-feature分支并合并代码</h3><p>使用以下命令切换回<code>my-feature</code>分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout my-feature</span><br></pre></td></tr></table></figure><p>再使用以下命令合并代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase main</span><br></pre></td></tr></table></figure><p>此时可能会出现<code>rebase conflict</code>，需要手动选择要保留的代码</p><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init-update 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init-update 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li><code>my-feature</code>分支 <code>Init-update-f-commit</code> 内容</li></ul></li></ul></blockquote><h3 id="4-推送my-feature分支"><a href="#4-推送my-feature分支" class="headerlink" title="(4) 推送my-feature分支"></a>(4) 推送<code>my-feature</code>分支</h3><p>使用以下命令推送</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin my-feature</span><br></pre></td></tr></table></figure><p><strong><code>-f</code>表示强制，切忌在push<code>main</code>分支时使用，须谨慎谨慎再谨慎!!!!!!!!!</strong></p><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init-update 内容</li><li>my-feature分支 <code>Init-update-f-commit</code> 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init-update 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 Init-update-f-commit 内容</li></ul></li></ul></blockquote><h3 id="5-审查并合并到main分支"><a href="#5-审查并合并到main分支" class="headerlink" title="(5) 审查并合并到main分支"></a>(5) 审查并合并到<code>main</code>分支</h3><p><strong>此时生成新的<code>pull request</code>,项目管理员审查代码之后<code>Squash and merge</code>合并分支的改变并同步到<code>main</code>分支，简化提交内容，此时状态如下</strong></p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 <code>Init-update-update2</code> 内容</li><li><del><code>my-feature 分支</code></del></li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init-uodate 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 Init-update-f-commit 内容</li></ul></li></ul></blockquote><h3 id="6-清理本地分支"><a href="#6-清理本地分支" class="headerlink" title="(6) 清理本地分支"></a>(6) 清理本地分支</h3><p>a. 切换到main(master)分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure><p>b. 删除my-feature分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D my-feature</span><br></pre></td></tr></table></figure><p><strong><code>-D</code>表示强制删除，切忌使用在main分支上，须谨慎谨慎再谨慎!!!!!!!!</strong></p><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init-update-update2 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init-update 内容</li><li><del><code>my-feature分支 Init-f-commit 内容</code></del></li></ul></li><li><p>DIsk: </p><ul><li><code>main(master)分支 Init-update 内容</code></li></ul></li></ul></blockquote><p>c. 拉取最新main(master)分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init-update-update2 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init-update<code>-update2</code> 内容</li></ul></li><li><p>DIsk: </p><ul><li>main(master)分支 Init-update<code>-update2</code> 内容</li></ul></li></ul></blockquote><p>至此一个工作环节结束</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
            <tag> 工作流程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记——流体力学基本方程 (一)</title>
      <link href="/2024/04/98e90823.html"/>
      <url>/2024/04/98e90823.html</url>
      
        <content type="html"><![CDATA[<h2 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h2><h3 id="Bilibili-流体力学基础科普-北斗导航Compass"><a href="#Bilibili-流体力学基础科普-北斗导航Compass" class="headerlink" title="Bilibili-流体力学基础科普-北斗导航Compass"></a><a href="https://www.bilibili.com/video/BV1Ty4y1M7Fx/?share_source=copy_web&amp;vd_source=374d2addde246f63ad679abfc5ab707c">Bilibili-流体力学基础科普-北斗导航Compass</a></h3><p>参考教材：<a href="https://pan.baidu.com/s/1fbj6e9Xk6LmWW2Vjmu0oIw?pwd=eavw">Fundamentals of AERODYNAMICS by John D. Anderson, Jr.</a></p><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-什么是流体？"><a href="#1-什么是流体？" class="headerlink" title="1. 什么是流体？"></a>1. 什么是流体？</h3><ul><li>对比固体和流体的区别</li></ul><blockquote><p>对于固体剪切力与<strong>形变量</strong>成正比</p><p>对于流体剪切力与<strong>形变量的时间变化率</strong>成正比</p></blockquote><ul><li>解释流体为什么能流起来？</li></ul><blockquote><p>对于流体如果流体中的<strong>剪切力</strong>是常数，则其形变量的时间变化率也应为常数，即流体一直发生形变（流动）</p></blockquote><ul><li>流体在抗压时可以静止，在抗剪时一定在运动</li></ul><h3 id="2-流体质点"><a href="#2-流体质点" class="headerlink" title="2. 流体质点"></a>2. 流体质点</h3><p>将流体看作无穷多的质点的结合，符合连续介质假设</p><h3 id="3-描述流体的物理量"><a href="#3-描述流体的物理量" class="headerlink" title="3. 描述流体的物理量"></a>3. 描述流体的物理量</h3><blockquote><p>包括速度、密度、压强、温度等等</p></blockquote><ul><li>压强(压力) Pressure 单位Pa</li></ul><script type="math/tex; mode=display">P=\frac{F}{A}\ \ \ \ 当A\rightarrow0时\ \ \ P=frac{dF}{dA}</script><ul><li>密度 单位 $kg/m^3$ </li></ul><script type="math/tex; mode=display">\rho=\frac{m}{V}\ \ \ 当V\rightarrow0时\ \ \ \rho=\frac{dm}{dV}</script><ul><li>温度 单位K</li></ul><script type="math/tex; mode=display">0°C=273.15K</script><h3 id="4-描述流体运动的方法"><a href="#4-描述流体运动的方法" class="headerlink" title="4. 描述流体运动的方法"></a>4. 描述流体运动的方法</h3><ul><li>拉格朗日法</li></ul><blockquote><p>以质点为研究对象,跟踪质点的运动</p></blockquote><ul><li>欧拉法</li></ul><blockquote><p>以确定空间为研究对象,研究某一空间点不同时间下,在此空间点的质点的运动</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">积分方法</th><th style="text-align:center">微分方法</th></tr></thead><tbody><tr><td style="text-align:center">拉格朗日法</td><td style="text-align:center">一坨流体</td><td style="text-align:center">质点</td></tr><tr><td style="text-align:center">欧拉法</td><td style="text-align:center">控制体</td><td style="text-align:center">空间点</td></tr></tbody></table></div><h2 id="二、基本方程"><a href="#二、基本方程" class="headerlink" title="二、基本方程"></a>二、基本方程</h2><h3 id="1-质量守恒方程-连续方程"><a href="#1-质量守恒方程-连续方程" class="headerlink" title="1. 质量守恒方程(连续方程)"></a>1. 质量守恒方程(连续方程)</h3><p> <strong>控制体内流体总质量的增量 = 流入控制体的流体质量</strong></p><p>欧拉法连续方程的微分形式</p><script type="math/tex; mode=display">\frac{\partial \rho}{\partial t}+\frac{\partial (\rho u)}{\partial x}+\frac{\partial (\rho v)}{\partial y}+\frac{\partial (\rho w)}{\partial z}=0</script><p>其中 $\rho,u,v,w$ 均是 $x,y,z,t$ 的函数,如 $\rho(x,y,z,t)$ </p><p><strong>方程左边:</strong> 单位时间 控制体内流体总质量的增量(为负数就是减量)</p><p>首先,表示总质量</p><script type="math/tex; mode=display">m={\iiint}_{cv}\rho dV</script><p>对时间t求偏导,得</p><script type="math/tex; mode=display">\frac{\partial m}{\partial t}=\frac{\partial ({\iiint}_{cv}\rho dV)}{\partial t}={\iiint}_{cv}\frac{\partial \rho}{\partial t}\ dV</script><p><strong>方程右边:</strong> 单位时间 流入控制体的流体质量</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051038892.png" alt="" style="zoom:50%;" center/></p><blockquote><p>质量=密度*体积</p></blockquote><script type="math/tex; mode=display">h=v*\Delta t\cos\theta</script><script type="math/tex; mode=display">V=Sh=Sv*\Delta t\cos\theta</script><p>则 $\Delta t$ 时间范围内</p><script type="math/tex; mode=display">m=\rho V=\rho Sv\Delta t\cos\theta</script><script type="math/tex; mode=display">m|_{单位时间}=\rho Sv\cos\theta</script><p>对控制体边界面积分</p><script type="math/tex; mode=display">{\iint}_{cs}\rho \vec{v}\cdot d\vec{S}</script><p>规定控制体表面的外法线方向为正,则方程右边应为添加负号</p><p>即</p><script type="math/tex; mode=display">-{\iint}_{cs}\rho \vec{v}\cdot d\vec{S}</script><p>则可得到积分形式的质量守恒方程</p><script type="math/tex; mode=display">{\iiint}_{cv}\frac{\partial \rho}{\partial t}\ dV=-{\iint}_{cs}\rho \vec{v}\cdot d\vec{S}</script><p>也即</p><script type="math/tex; mode=display">{\iiint}_{cv}\frac{\partial \rho}{\partial t}\ dV+{\iint}_{cs}\rho \vec{v}\cdot d\vec{S}=0</script><p>根据高斯定理</p><script type="math/tex; mode=display">{\iint}_{cs}\rho \vec{v}\cdot d\vec{S}={\iiint}_{cv}[\frac{\partial(\rho u)}{\partial x}+\frac{\partial(\rho v)}{\partial y}+\frac{\partial(\rho w)}{\partial z}]dV</script><p>则积分形式的质量守恒方程可以合并为</p><script type="math/tex; mode=display">{\iiint}_{cv}[\frac{\partial \rho}{\partial t}+\frac{\partial(\rho u)}{\partial x}+\frac{\partial(\rho v)}{\partial y}+\frac{\partial(\rho w)}{\partial z}]dV=0</script><p>可得微分形式的质量守恒方程</p><script type="math/tex; mode=display">\frac{\partial \rho}{\partial t}+\frac{\partial(\rho u)}{\partial x}+\frac{\partial(\rho v)}{\partial y}+\frac{\partial(\rho w)}{\partial z}=0</script><p>用哈密顿算子表示,可写为</p><script type="math/tex; mode=display">\frac{\partial \rho}{\partial t}+\vec{\nabla}\cdot(\rho\vec{v})=0</script><p>下期内容：</p><h3 id="2-动量守恒方程"><a href="#2-动量守恒方程" class="headerlink" title="2. 动量守恒方程"></a>2. 动量守恒方程</h3><p> <strong>控制体内流体总动量的增量 = 流入控制体的流体动量 + 外界的力产生的动量增量</strong></p><h3 id="3-能量守恒方程"><a href="#3-能量守恒方程" class="headerlink" title="3. 能量守恒方程"></a>3. 能量守恒方程</h3><p> <strong>控制体内流体的总能量的增量 = 流入控制体的流体能量 + 外界的作用产生的能量增量</strong></p>]]></content>
      
      
      <categories>
          
          <category> 流体力学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流体力学 </tag>
            
            <tag> 质量守恒方程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非饱和土手动迭代计算程序修改说明</title>
      <link href="/2024/04/863a85e0.html"/>
      <url>/2024/04/863a85e0.html</url>
      
        <content type="html"><![CDATA[<h2 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h2><h3 id="1、输入参数改变"><a href="#1、输入参数改变" class="headerlink" title="1、输入参数改变"></a>1、输入参数改变</h3><p>t(nl) 每层层底沉积年代(37 行)<br>土水特征参数 a、m、n 随沉积年代模型参数(54、55 行)<br>内摩擦角 粘聚力 重度 随沉积年代模型非线性(56、57 行)<br>水位位置（坡顶为 0，y 方向为负值）(58 行)<br>非饱和抗剪强度公式中 κ(59 行)</p><h3 id="2、输入所有节点孔压-53-行"><a href="#2、输入所有节点孔压-53-行" class="headerlink" title="2、输入所有节点孔压(53 行)"></a>2、输入所有节点孔压(53 行)</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">READ(<span class="number">12</span>,*)inpore  <span class="comment">!所有节点孔压</span></span><br></pre></td></tr></table></figure><h3 id="3、输出-prop-nprops-np-types-98-85-行"><a href="#3、输出-prop-nprops-np-types-98-85-行" class="headerlink" title="3、输出 prop(nprops,np_types)(98-85 行)"></a>3、输出 prop(nprops,np_types)(98-85 行)</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nprops=<span class="number">10</span> <span class="comment">!分别为内摩擦角、粘聚力、剪胀角、干密度、弹模、泊松比、a、m、n、饱和体积含水率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> g_prop(a1,a2,a3,a4,b1,a5,a6,a7,b2,b3,b4,c1,c2,c3,c4,d1,c5,c6,c7,d2,d3,d5,la_rwt1,   &amp;</span><br><span class="line">  la_rwt2,lm_rwt1,lm_rwt2,ln_rwt1,ln_rwt2,theta_r,zero,gam_w,np_types,nprops,nl,ny,t,   &amp;</span><br><span class="line">  nx1,nx2,ny1,ny2,nye,nod,nels,g_num,num,nn,h,inpore,prop,prop1,theta_w,pa_rwt1,        &amp;</span><br><span class="line">  pa_rwt2,pm_rwt1,pm_rwt2,pm_rwt3,pn_rwt1,pn_rwt2,pn_rwt3)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先，求prop1：一列单元的参数(其中重度为干重度)</span><br><span class="line">其次，求prop：所有单元参数(其中重度为干重度)</span><br><span class="line">之后，判断孔压正负，计算天然体积含水率/使用饱和体积含水率</span><br><span class="line">最后，利用含水率计算天然重度</span><br></pre></td></tr></table></figure><h3 id="4、输出-surf-2-nosurf-79-行"><a href="#4、输出-surf-2-nosurf-79-行" class="headerlink" title="4、输出 surf(2,nosurf) (79 行)"></a>4、输出 surf(2,nosurf) (79 行)</h3><p>根据水位计算水位线上各节点坐标</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> WTpoints(zero,nx1,nx2,nn,ny1,ny2,nod,nels,g_num,gam_w,inpore,g_coord,nosurf,surf,ndim)</span><br></pre></td></tr></table></figure><h3 id="5、绘制网格划分时，将所有网格设置为具有不同参数-81-85-行"><a href="#5、绘制网格划分时，将所有网格设置为具有不同参数-81-85-行" class="headerlink" title="5、绘制网格划分时，将所有网格设置为具有不同参数(81-85 行)"></a>5、绘制网格划分时，将所有网格设置为具有不同参数(81-85 行)</h3><h3 id="6、坡外水位所导致的重度荷载的变化，输出-gravlo-0-neq-119-行"><a href="#6、坡外水位所导致的重度荷载的变化，输出-gravlo-0-neq-119-行" class="headerlink" title="6、坡外水位所导致的重度荷载的变化，输出 gravlo(0:neq) (119 行)"></a>6、坡外水位所导致的重度荷载的变化，输出 gravlo(0:neq) (119 行)</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> water_loads</span><br></pre></td></tr></table></figure><h3 id="7、对于孔压-inpore-的处理"><a href="#7、对于孔压-inpore-的处理" class="headerlink" title="7、对于孔压 inpore 的处理"></a>7、对于孔压 inpore 的处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先，单元循环内提取该单元所有节点的孔压(172行)</span><br><span class="line">其次，利用Vanapalli公式计算吸应力suc_sig (174-176行)</span><br><span class="line">之后，高斯循环中计算高斯点吸应力pore (181行)</span><br><span class="line">最后，修正正应力(186-188行)</span><br></pre></td></tr></table></figure><h3 id="8、若收敛，对应力进行恢复-193-195-行"><a href="#8、若收敛，对应力进行恢复-193-195-行" class="headerlink" title="8、若收敛，对应力进行恢复(193-195 行)"></a>8、若收敛，对应力进行恢复(193-195 行)</h3><h3 id="9、奇偶分层下的变形图-224-行"><a href="#9、奇偶分层下的变形图-224-行" class="headerlink" title="9、奇偶分层下的变形图(224 行)"></a>9、奇偶分层下的变形图(224 行)</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> dismsh</span><br></pre></td></tr></table></figure><h2 id="输入说明"><a href="#输入说明" class="headerlink" title="输入说明"></a>输入说明</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">w1   s1   w2   h1   h2   nl <span class="comment">!分层数  用于划分黄土古土壤序列情况</span></span><br><span class="line"><span class="number">8</span>    <span class="number">4</span>     <span class="number">4</span>    <span class="number">14</span>   <span class="number">8</span>    <span class="number">4</span></span><br><span class="line">h(nl) <span class="comment">!每层层底距坡顶距离</span></span><br><span class="line"><span class="number">4</span>   <span class="number">12</span>   <span class="number">16</span>   <span class="number">22</span></span><br><span class="line">ny(nl) <span class="comment">!每层划分网格数</span></span><br><span class="line"><span class="number">2</span>    <span class="number">4</span>    <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">t(nl) <span class="comment">!每层层底沉积年代</span></span><br><span class="line"><span class="number">8</span>   <span class="number">12</span>   <span class="number">18</span>   <span class="number">33</span></span><br><span class="line">nx1    nx2   ny1    ny2</span><br><span class="line"><span class="number">4</span>       <span class="number">2</span>     <span class="number">7</span>    <span class="number">4</span></span><br><span class="line"><span class="comment">!土水特征参数a、m、n随沉积年代模型参数</span></span><br><span class="line"><span class="number">0.044</span>     <span class="number">7.062</span>      -<span class="number">0.0000724</span>      <span class="number">0.3318</span>              -<span class="number">0.000161</span>      <span class="number">1.5092</span></span><br><span class="line"><span class="number">24.4397</span>   -<span class="number">113.0186</span>   <span class="number">0.000000176</span>   -<span class="number">0.0000591</span>   <span class="number">0.2077</span>   <span class="number">0.000000331</span>   -<span class="number">0.000128</span>   <span class="number">1.2664</span></span><br><span class="line"><span class="comment">!内摩擦角     粘聚力        剪胀角     重度                    弹模 泊松比  比重</span></span><br><span class="line"><span class="number">0</span>  <span class="number">18.5</span>       <span class="number">0.17</span>    <span class="number">0</span>      <span class="number">0.0</span>        <span class="number">1.25</span>   <span class="number">0.018</span>    <span class="number">0.4623</span>   <span class="number">1.0e5</span>   <span class="number">0.3</span>  <span class="number">2.71</span></span><br><span class="line"><span class="number">0</span>  <span class="number">18.5</span>       <span class="number">3.56</span>   <span class="number">500</span>     <span class="number">0.0</span>        <span class="number">1.39</span>   <span class="number">0.0035</span>   <span class="number">0.6489</span>   <span class="number">1.0e5</span>   <span class="number">0.3</span>  <span class="number">2.72</span></span><br><span class="line"><span class="comment">!水位位置（坡顶为0，y方向为负值）</span></span><br><span class="line">-<span class="number">100</span></span><br><span class="line"><span class="comment">!非饱和抗剪强度公式中κ</span></span><br><span class="line"><span class="number">1.4</span></span><br><span class="line"><span class="comment">!收敛准则  计算次数</span></span><br><span class="line"><span class="number">0.0001</span>   <span class="number">500</span></span><br><span class="line"><span class="comment">!折减次数</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="comment">!折减系数</span></span><br><span class="line"><span class="number">0.8</span>  <span class="number">0.9</span>  <span class="number">1.0</span>  <span class="number">1.1</span>  <span class="number">1.2</span>  <span class="number">1.3</span>  <span class="number">1.4</span>  <span class="number">1.5</span>  <span class="number">1.6</span></span><br></pre></td></tr></table></figure><hr><p>非本人原创内容</p>]]></content>
      
      
      <categories>
          
          <category> 边坡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 边坡稳定性 </tag>
            
            <tag> Fortran </tag>
            
            <tag> 孔压 </tag>
            
            <tag> 有限元 </tag>
            
            <tag> 教程及说明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非饱和土边坡稳定性计算程序说明文件</title>
      <link href="/2024/04/71e392b0.html"/>
      <url>/2024/04/71e392b0.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、数据文件"><a href="#一、数据文件" class="headerlink" title="一、数据文件"></a>一、数据文件</h2><h3 id="注意：以下文件内不要输入注释文字"><a href="#注意：以下文件内不要输入注释文字" class="headerlink" title="注意：以下文件内不要输入注释文字"></a>注意：以下文件内不要输入注释文字</h3><h4 id="1-dat文件"><a href="#1-dat文件" class="headerlink" title="1. dat文件"></a>1. dat文件</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!dx  h2v</span></span><br><span class="line"><span class="number">1.0</span>  <span class="number">2.0</span></span><br><span class="line"><span class="comment">!nx1 nx2 ny1 ny2</span></span><br><span class="line"><span class="number">20</span>  <span class="number">20</span>  <span class="number">10</span>  <span class="number">5</span></span><br><span class="line"><span class="comment">!树荷载的左列和右列数，单位长度的树荷载kN/m</span></span><br><span class="line"><span class="number">27</span> <span class="number">32</span> <span class="number">10.0</span></span><br><span class="line"><span class="comment">!内摩擦角，粘聚力，剪胀角，重度，弹性模量，泊松比, a, m, n, theta_s 其中,重度=ρ_d*gam_w,theta_s=1-ρ_d/G_s</span></span><br><span class="line"><span class="number">20.0</span>  <span class="number">15.0</span>  <span class="number">0.0</span>  <span class="number">20.0</span>  <span class="number">1.0e5</span>  <span class="number">0.3</span> <span class="number">15</span> <span class="number">0.2</span> <span class="number">4</span> <span class="number">0.907749</span></span><br><span class="line"><span class="comment">!水位位置（坡顶为0，y方向为负值）</span></span><br><span class="line">-<span class="number">20</span></span><br><span class="line"><span class="comment">!非饱和抗剪强度公式中κ</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment">!收敛准则  计算次数</span></span><br><span class="line"><span class="number">0.0001</span> <span class="number">500</span></span><br><span class="line"><span class="comment">!折减次数</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="comment">!折减系数</span></span><br><span class="line"><span class="number">1.2</span>  <span class="number">1.3</span>  <span class="number">1.4</span>  <span class="number">1.5</span>  <span class="number">1.55</span> <span class="number">1.6</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051034316.png" alt="模型"></p><p>其中,第三行表示荷载的加荷位置和大小</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27</span> <span class="comment">! 表示起点在第27列（从左至右）</span></span><br><span class="line"><span class="number">32</span> <span class="comment">! 表示终点在第32列（从左至右）</span></span><br><span class="line"><span class="number">30</span> <span class="comment">! 表示荷载为30kN/m</span></span><br></pre></td></tr></table></figure><p>对应下图中的红色位置</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051036737.png" alt="加载位置"></p><h4 id="2-孔压文件x-f-txt"><a href="#2-孔压文件x-f-txt" class="headerlink" title="2. 孔压文件x_f.txt"></a>2. 孔压文件x_f.txt</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按节点列依次输入节点处的孔压</span><br><span class="line">每个单元格有<span class="number">3</span>列共<span class="number">8</span>个节点，呈<span class="number">323</span>分布，如下图所示，阴影部分为一个单元格，黄色为单元格号</span><br><span class="line">按照节点的<span class="number">1234.</span>..顺序竖向填写x_f.txt文件，每节点占一行 </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051036959.png" alt="17143576814081714357680903png"></p><h2 id="二、源代码"><a href="#二、源代码" class="headerlink" title="二、源代码"></a>二、源代码</h2><p>本程序单元格序号是从上至下，从左至右依次排序,如下例</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">6</span> </span><br><span class="line"><span class="number">2</span> <span class="number">7</span>  <span class="number">11</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span>  <span class="number">12</span> <span class="number">15</span></span><br><span class="line"><span class="number">4</span> <span class="number">9</span>  <span class="number">13</span> <span class="number">16</span> <span class="number">18</span> <span class="number">20</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span> <span class="number">14</span> <span class="number">17</span> <span class="number">19</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p>在叠加荷载时，因为所有单元格的g都是按照3 2 1 4 6 7 8 5 的顺序保存，因此我们仅需找到对应的单元格号以及146号节点的相对位置</p><p>146号节点的相对位置为g(6), g(8), g(10),下文有介绍</p><p>接下来只需找到单元格号即可。</p><h3 id="计算单元号"><a href="#计算单元号" class="headerlink" title="计算单元号"></a>计算单元号</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tree_load/=<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!荷载不为零再进行运算</span></span><br><span class="line">  <span class="built_in">allocate</span>(tree_nodes(nx1+nx2+ny1*ngrad))</span><br><span class="line"></span><br><span class="line">  tree_nodes=<span class="number">0</span></span><br><span class="line">   <span class="comment">! tree_nodes(nx1+nx2+ny1*ngrad)是储存表面单元格的单元号</span></span><br><span class="line"></span><br><span class="line">  itree = <span class="number">2</span> <span class="comment">!用于计数，记录需加荷的单元格数量</span></span><br><span class="line">  tree_nodes(<span class="number">1</span>)=<span class="number">1</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">! 顶面和斜面前ngrad行</span></span><br><span class="line">  <span class="keyword">do</span> i=<span class="number">2</span>,nx1+ngrad </span><br><span class="line">     tree_nodes(itree) = (i-<span class="number">1</span>)*nye+<span class="number">1</span></span><br><span class="line">     itree = itree + <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">! 斜面ngrad行以后</span></span><br><span class="line">  <span class="keyword">do</span> i=<span class="number">1</span>,ny1-<span class="number">1</span></span><br><span class="line">    <span class="keyword">do</span> j=<span class="number">1</span>,ngrad</span><br><span class="line">       <span class="keyword">if</span> (j==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">          tree_nodes(itree) = tree_nodes(itree-<span class="number">1</span>)+nye-i+<span class="number">1</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">          tree_nodes(itree) = tree_nodes(itree-<span class="number">1</span>)+nye-i</span><br><span class="line">       <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">       itree = itree + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">! 底面第一列</span></span><br><span class="line">  tree_nodes(itree) = tree_nodes(itree-<span class="number">1</span>)+ny2+<span class="number">1</span></span><br><span class="line">  itree = itree + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">! 底面以后</span></span><br><span class="line">  <span class="keyword">do</span> i=<span class="number">2</span>,nx2</span><br><span class="line">     tree_nodes(itree) = tree_nodes(itree-<span class="number">1</span>)+ny2</span><br><span class="line">     itree = itree + <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  tree_nodes_= tree_nodes(nel_left:nel_right) <span class="comment">! 储存实际需要加荷的单元格的序号</span></span><br></pre></td></tr></table></figure><h3 id="分配荷载到节点"><a href="#分配荷载到节点" class="headerlink" title="分配荷载到节点"></a>分配荷载到节点</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">ALLOCATE</span>(weight_load(<span class="number">8</span>),tree(ndof))</span><br><span class="line">  <span class="comment">!荷载在节点上的分布权重</span></span><br><span class="line">  weight_load = (/<span class="number">0.166667</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.666667</span>,<span class="number">0.0</span>,<span class="number">0.166667</span>,<span class="number">0.0</span>,<span class="number">0.0</span>/)</span><br><span class="line"></span><br><span class="line">  <span class="comment">!计算各节点荷载大小</span></span><br><span class="line">  tree=zero</span><br><span class="line">  tree(<span class="number">6</span>)=tree_load*weight_load(<span class="number">1</span>)</span><br><span class="line">  tree(<span class="number">8</span>)=tree_load*weight_load(<span class="number">4</span>)</span><br><span class="line">  tree(<span class="number">10</span>)=tree_load*weight_load(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">! 此处注意区分(见下图)</span></span><br><span class="line">  <span class="comment">! g数组按3x 3y 2x 2y 1x 1y 4x 4y 6x 6y 7x 7y 8x 8y 5x 5y的顺序保存</span></span><br><span class="line">  <span class="comment">! weight_load按1 2 3 4 5 6 7 8来保存</span></span><br><span class="line">  <span class="comment">! 则1 4 6号节点的y方向对应g(6),g(8),g(10)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051036468.png" title="" alt="单元节点" data-align="center"></p><h3 id="叠加荷载"><a href="#叠加荷载" class="headerlink" title="叠加荷载"></a>叠加荷载</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">itree=<span class="number">1</span> <span class="comment">! 作tree_nodes_数组的索引，将序号依次读出</span></span><br><span class="line"></span><br><span class="line">elements_2: <span class="keyword">DO</span> iel=<span class="number">1</span>,nels</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   gravlo(g)=gravlo(g)-eld*prop(<span class="number">4</span>,etype(iel))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (tree_load.ne<span class="number">.0</span><span class="number">.0</span>) <span class="keyword">then</span> <span class="comment">!荷载不为零时计算</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((iel==tree_nodes_(itree)).and.(itree.le.<span class="built_in">size</span>(tree_nodes_))) <span class="keyword">then</span> <span class="comment">!判断是否为需加荷的单元</span></span><br><span class="line"></span><br><span class="line">         gravlo(g) = gravlo(g) - tree <span class="comment">!根据自由度编号加到指定位置</span></span><br><span class="line"></span><br><span class="line">         itree=itree+<span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">DO</span> elements_2</span><br></pre></td></tr></table></figure><hr><h3 id="叠加外部水荷载"><a href="#叠加外部水荷载" class="headerlink" title="叠加外部水荷载"></a>叠加外部水荷载</h3><p>叠加外部水荷载的方式与上方叠加外部荷载的方法类似，将水的压力 $\gamma_w*h$ 叠加到相应的表面节点上</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span>(wl&gt;g_coord(<span class="number">2</span>,<span class="number">1</span>))<span class="keyword">THEN</span>  <span class="comment">! 水位淹没整个边坡</span></span><br><span class="line">      p3=(wl-g_coord(<span class="number">2</span>,<span class="number">1</span>))*gam_w</span><br><span class="line">      <span class="keyword">DO</span> i=<span class="number">1</span>,nx1</span><br><span class="line">         gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p3/d6</span><br><span class="line">         gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p3/d3</span><br><span class="line">         gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p3/d6</span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">DO</span></span><br><span class="line">      <span class="keyword">DO</span> i=nx1+<span class="number">1</span>,nx1+ny1*ngrad</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">mod</span>(i-nx1,ngrad)/=<span class="number">0</span>)<span class="keyword">then</span></span><br><span class="line">            y5=g_coord(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i)))</span><br><span class="line">            p5=(wl-y5)*gam_w</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p5/d3</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            y5=g_coord(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i)))</span><br><span class="line">            p5=(wl-y5)*gam_w</span><br><span class="line">            y7=g_coord(<span class="number">2</span>,g_num(<span class="number">7</span>,tree_nodes(i)))</span><br><span class="line">            p7=(wl-y7)*gam_w</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p5/d3</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">6</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">6</span>,tree_nodes(i))))-dx*(p5+p7)/d3</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">7</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">7</span>,tree_nodes(i))))-dx*p7/d6</span><br><span class="line">         <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">DO</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">IF</span>(ny2&gt;<span class="number">0</span>)<span class="keyword">THEN</span> <span class="comment">! 如果有破角台阶</span></span><br><span class="line">         p3=(wl-g_coord(<span class="number">2</span>,nn-<span class="number">2</span>*ny2))*gam_w <span class="comment">!p3==p5</span></span><br><span class="line">         <span class="keyword">DO</span> i=nx1+ny1*ngrad+<span class="number">1</span>,nx1+ny1*ngrad+nx2</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p3/d6</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p3/d3</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p3/d6</span><br><span class="line">         <span class="keyword">END</span> <span class="keyword">DO</span></span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">   <span class="keyword">ELSE</span> <span class="keyword">IF</span>(wl&gt;g_coord(<span class="number">2</span>,nn-<span class="number">2</span>*ny2))<span class="keyword">THEN</span> <span class="comment">! 水面在斜面位置(低于坡顶,高于坡脚)</span></span><br><span class="line">      nw=<span class="built_in">int</span>((-wl)/dx)</span><br><span class="line">      <span class="keyword">do</span> i=nx1+nw*ngrad+ngrad,nx1+ny1*ngrad</span><br><span class="line">         y5=g_coord(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i)))</span><br><span class="line">         y7=g_coord(<span class="number">2</span>,g_num(<span class="number">7</span>,tree_nodes(i)))</span><br><span class="line">         p5=(wl-y5)*gam_w</span><br><span class="line">         p7=(wl-y7)*gam_w</span><br><span class="line">         <span class="keyword">if</span>(i==nx1+nw*ngrad+ngrad)<span class="keyword">then</span> <span class="comment">! 如果水面恰好穿过某行单元格</span></span><br><span class="line">            cx=y5-wl</span><br><span class="line">            cy=cx</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i))))           &amp;</span><br><span class="line">               +p7*cy*(cy**<span class="number">2</span>-two*cy*dx+dx**<span class="number">2</span>)/(d6*dx**<span class="number">2</span>)</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">6</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">6</span>,tree_nodes(i))))           &amp;</span><br><span class="line">               -p7*(cy**<span class="number">3</span>-cy**<span class="number">2</span>*dx-cy*dx**<span class="number">2</span>+dx**<span class="number">3</span>)/(d3*dx**<span class="number">2</span>)</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">7</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">7</span>,tree_nodes(i))))           &amp;</span><br><span class="line">               -p7*(dx**<span class="number">3</span>-cy**<span class="number">3</span>)/(d6*dx*dx)</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">mod</span>(i-nx1,ngrad)/=<span class="number">0</span>)<span class="keyword">then</span> <span class="comment">! 方格斜面台阶内部(仅有上表面接触水)</span></span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p5/d3</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">         <span class="keyword">else</span> <span class="comment">! 方格斜面台阶最外部的单元格(上表面和右表面接触水)</span></span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p5/d3</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">6</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">6</span>,tree_nodes(i))))-dx*(p5+p7)/d3</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">7</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">7</span>,tree_nodes(i))))-dx*p7/d6</span><br><span class="line">         <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">DO</span></span><br><span class="line">      <span class="keyword">IF</span>(ny2&gt;<span class="number">0</span>)<span class="keyword">THEN</span> </span><br><span class="line">         p3=(wl-g_coord(<span class="number">2</span>,nn-<span class="number">2</span>*ny2))*gam_w</span><br><span class="line">         <span class="keyword">DO</span> i=nx1+ny1*ngrad+<span class="number">1</span>,nx1+ny1*ngrad+nx2</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p3/d6</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p3/d3</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p3/d6</span><br><span class="line">         <span class="keyword">END</span> <span class="keyword">DO</span></span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">   <span class="keyword">END</span> <span class="keyword">IF</span></span><br></pre></td></tr></table></figure><h3 id="叠加孔压"><a href="#叠加孔压" class="headerlink" title="叠加孔压"></a>叠加孔压</h3><p>根据Vanapalli公式, 使用体积含水率、孔压等参数计算出基质吸力项, 叠加到正应力上</p><p><img src="https://raw.githubusercontent.com/liudh56/img_readme/main/img/post/202405/202405051036317.png" alt="17143599364091714359936244png"></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">elements_3: <span class="keyword">DO</span> iel=<span class="number">1</span>,nels</span><br><span class="line">            bload=zero</span><br><span class="line">            phi=prop(<span class="number">1</span>,iel)</span><br><span class="line">            tnph=<span class="built_in">TAN</span>(phi*pi/d180)</span><br><span class="line">            phif=<span class="built_in">ATAN</span>(tnph/srf(iy))*d180/pi</span><br><span class="line">            psi=prop(<span class="number">3</span>,iel)</span><br><span class="line">            tnps=<span class="built_in">TAN</span>(psi*pi/d180)</span><br><span class="line">            psif=<span class="built_in">ATAN</span>(tnps/srf(iy))*d180/pi</span><br><span class="line">            cf=prop(<span class="number">2</span>,iel)/srf(iy)</span><br><span class="line">            e=prop(<span class="number">5</span>,iel)</span><br><span class="line">            v=prop(<span class="number">6</span>,iel)</span><br><span class="line">            <span class="keyword">CALL</span> deemat(dee,e,v)</span><br><span class="line">            num=g_num(:,iel)</span><br><span class="line">            coord=<span class="built_in">TRANSPOSE</span>(g_coord(:,num))</span><br><span class="line">            <span class="keyword">do</span> i=<span class="number">1</span>,nod</span><br><span class="line">               <span class="keyword">call</span> Vanapalli(i,iel,nprops,kapa,prop,theta_w,suc_sig,n_inpore) <span class="comment">! 计算基质吸力项</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">            g=g_g(:,iel)</span><br><span class="line">            eld=loads(g)</span><br><span class="line">            gauss_pts_2: <span class="keyword">DO</span> i=<span class="number">1</span>,nip</span><br><span class="line">               <span class="keyword">call</span> shape_fun(fun,points,i)</span><br><span class="line">               pore(iel,i)=<span class="built_in">dot_product</span>(fun,suc_sig)</span><br><span class="line">               <span class="keyword">CALL</span> bee8(bee,coord,points(i,<span class="number">1</span>),points(i,<span class="number">2</span>),det)</span><br><span class="line">               eps=<span class="built_in">MATMUL</span>(bee,eld)</span><br><span class="line">               eps=eps-evpt(:,i,iel)</span><br><span class="line">               sigma=<span class="built_in">MATMUL</span>(dee,eps)</span><br><span class="line">               sigma(<span class="number">1</span>)=sigma(<span class="number">1</span>)-pore(iel,i) <span class="comment">! 此处124为正应力项, 3为剪应力项</span></span><br><span class="line">               sigma(<span class="number">2</span>)=sigma(<span class="number">2</span>)-pore(iel,i)</span><br><span class="line">               sigma(<span class="number">4</span>)=sigma(<span class="number">4</span>)-pore(iel,i)</span><br><span class="line">               <span class="keyword">CALL</span> invar(sigma,sigm,dsbar,lode_theta)</span><br><span class="line">               <span class="comment">!-----------------------check whether yield is violated-------------------</span></span><br><span class="line">               <span class="keyword">CALL</span> mocouf(phif,cf,sigm,dsbar,lode_theta,f)</span><br><span class="line">               <span class="keyword">IF</span>(f&gt;fmax)fmax=f</span><br><span class="line">               <span class="keyword">IF</span>(converged.OR.iters==limit)<span class="keyword">THEN</span></span><br><span class="line">                  sigma(<span class="number">1</span>)=sigma(<span class="number">1</span>)+pore(iel,i)</span><br><span class="line">                  sigma(<span class="number">2</span>)=sigma(<span class="number">2</span>)+pore(iel,i)</span><br><span class="line">                  sigma(<span class="number">4</span>)=sigma(<span class="number">4</span>)+pore(iel,i)</span><br><span class="line">                  devp=sigma</span><br><span class="line">               <span class="keyword">ELSE</span></span><br><span class="line">                  <span class="keyword">IF</span>(f&gt;=zero.OR.(converged.OR.iters==limit))<span class="keyword">THEN</span></span><br><span class="line">                     <span class="keyword">CALL</span> mocouq(psif,dsbar,lode_theta,dq1,dq2,dq3)</span><br><span class="line">                     <span class="keyword">CALL</span> formm(sigma,m1,m2,m3)</span><br><span class="line">                     flow=f*(m1*dq1+m2*dq2+m3*dq3)</span><br><span class="line">                     erate=<span class="built_in">MATMUL</span>(flow,sigma)</span><br><span class="line">                     evp=erate*dt</span><br><span class="line">                     evpt(:,i,iel)=evpt(:,i,iel)+evp</span><br><span class="line">                     devp=<span class="built_in">MATMUL</span>(dee,evp)</span><br><span class="line">                  <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">               <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">               <span class="keyword">IF</span>(f&gt;=zero)<span class="keyword">THEN</span></span><br><span class="line">                  eload=<span class="built_in">MATMUL</span>(devp,bee)</span><br><span class="line">                  bload=bload+eload*det*weights(i)</span><br><span class="line">               <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">DO</span> gauss_pts_2</span><br><span class="line">            <span class="comment">!-----------------------compute the total bodyloads vector----------------</span></span><br><span class="line">            bdylds(g)=bdylds(g)+bload</span><br><span class="line">            bdylds(<span class="number">0</span>)=zero</span><br><span class="line">         <span class="keyword">END</span> <span class="keyword">DO</span> elements_3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 边坡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 边坡稳定性 </tag>
            
            <tag> 非饱和土 </tag>
            
            <tag> 方形网格 </tag>
            
            <tag> Fortran </tag>
            
            <tag> 有限元 </tag>
            
            <tag> 教程及说明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可靠度分析程序说明文件</title>
      <link href="/2024/04/74b4d97f.html"/>
      <url>/2024/04/74b4d97f.html</url>
      
        <content type="html"><![CDATA[<h2 id="非饱和黄土边坡失效概率计算程序"><a href="#非饱和黄土边坡失效概率计算程序" class="headerlink" title="非饱和黄土边坡失效概率计算程序"></a>非饱和黄土边坡失效概率计算程序</h2><p>本程序是基于有限元的边坡可靠度分析程序，改进自<a href="https://inside.mines.edu/~vgriffit">Griffith教授</a> 的非饱和黄土边坡稳定性计算程序</p><p>本程序使用强度折减法计算稳定系数，使用Monte-Carlo法计算失效概率；</p><p>将计算作业量，分成<strong>线程数量</strong>的段数，将作业量平均分配给每一个线程；</p><p><strong>本程序使用MPI实现并行运算</strong></p><p><strong>程序文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slope_new/Subroutine.py</span><br><span class="line">slope_new/slope2.f90</span><br></pre></td></tr></table></figure><p><strong>示例数据文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exmaple/1.dat</span><br><span class="line">exmaple/1_c.txt</span><br><span class="line">exmaple/1_phi.txt</span><br><span class="line">example/1_gamma.txt !未给出</span><br><span class="line">exmaple/1_mstd.txt</span><br><span class="line">exmaple/1_grid.txt</span><br></pre></td></tr></table></figure><p><strong>结果文件</strong> 未给出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1_fs.res</span><br><span class="line">1_fail.res</span><br></pre></td></tr></table></figure><h3 id="前置安装教程"><a href="#前置安装教程" class="headerlink" title="前置安装教程"></a>前置安装教程</h3><ol><li>Fortran程序前置安装：<a href="https://github.com/sourceryinstitute/OpenCoarrays">OpenCoarrays</a></li></ol><p>以Ubuntu22.04安装Open-coarrays 2.9.2为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cmake gfortran</span><br><span class="line">wget https://github.com/sourceryinstitute/OpenCoarrays/archive/refs/tags/2.9.2.tar.gz</span><br><span class="line">tar xf 2.9.2.tar.gz</span><br><span class="line">cd OpenCoarrays-2.9.2</span><br><span class="line">makedir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>！若<a href="https://github.com/sourceryinstitute/OpenCoarrays/archive/refs/tags/2.9.2.tar.gz">OpenCoarrays2.9.2</a> 下载失败可手动下载并上传到<code>/home/username/</code>再解压编译安装</p><ol><li>可选安装—后台运行<a href="https://www.gnu.org/software/screen/">Screen</a></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">安装：</span><br><span class="line">sudo apt-get install screen</span><br><span class="line">列出全部会话：</span><br><span class="line">screen -ls</span><br><span class="line">新建：</span><br><span class="line">screen</span><br><span class="line">screen -S name</span><br><span class="line">删除：</span><br><span class="line">screen -S name -X quit ! 或在窗口内使用快捷键ctrl + D</span><br><span class="line">放置后台：</span><br><span class="line">使用快捷键ctrl+A再ctrl+D </span><br><span class="line">返回窗口：</span><br><span class="line">screen -R</span><br><span class="line">screen -r name </span><br></pre></td></tr></table></figure><ol><li>Python程序须安装<a href="https://www.python.org/downloads/">Python3.x</a> ！无须安装在服务器中，仅做数据处理工作，在本地使用即可</li></ol><p>程序运行依赖<code>numpy</code>库，可使用pip安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure><h3 id="程序使用教程"><a href="#程序使用教程" class="headerlink" title="程序使用教程"></a>程序使用教程</h3><ol><li>运行<a href="https://github.com/liudh56/Slope/blob/main/Slope_new/Subroutine.py">Subroutine.py</a></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 代码所在目录</span><br><span class="line">python ./Subroutine.py</span><br></pre></td></tr></table></figure><p> 根据提示操作即可<a href="https://github.com/liudh56/Slope/tree/main/example">使用教程</a></p><ol><li>将生成文件与<code>slope2.f90</code>放在同一文件夹内（本文件夹即要上传的文件夹）</li></ol><p>文件包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx.dat</span><br><span class="line">xxx_c.txt xxx_phi.txt xxx_gamma.txt #具体文件数量与设为随机的参数有关</span><br></pre></td></tr></table></figure><p><a href="https://github.com/liudh56/Slope/blob/main/example/1.dat">dat文件详细</a> </p><p>其他python程序使用文件（无需上传）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx_mstd.txt</span><br><span class="line">xxx_grid.txt</span><br></pre></td></tr></table></figure><h4 id="Fortran程序—在服务器中运行"><a href="#Fortran程序—在服务器中运行" class="headerlink" title="Fortran程序—在服务器中运行"></a>Fortran程序—在服务器中运行</h4><ol><li><p>将上文中的文件夹上传至服务器并打开目录</p></li><li><p>编译命令：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caf slope2.f90 -o slope</span><br></pre></td></tr></table></figure><ol><li>运行：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cafrun -n 4 slope</span><br><span class="line">！ 4代表线程数，可更改，若线程数报错改用下面的命令</span><br></pre></td></tr></table></figure><p> 或者：使用下面命令适用于多主机的情况，根据主机实际情况分配线程数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mpirun --host host1:40 host2:40 -n 80 filename</span><br><span class="line">mpirun --host hostfile -n 80 filename !使用该命令须先创建hostfile文件</span><br></pre></td></tr></table></figure><ol><li>保存结果文件到本地与Subroutine.py文件放置在同一文件内</li></ol><p>运行Subroutine.py程序并选择功能3计算失效概率，结果保存在<code>xxx_fail.res</code>文件内。</p><h2 id="Subroutine-py程序使用方式"><a href="#Subroutine-py程序使用方式" class="headerlink" title="Subroutine.py程序使用方式"></a>Subroutine.py程序使用方式</h2><h3 id="1-输入项目名称xxx。"><a href="#1-输入项目名称xxx。" class="headerlink" title="1. 输入项目名称xxx。"></a>1. 输入项目名称xxx。</h3><h3 id="2-选择功能（输入序号）。"><a href="#2-选择功能（输入序号）。" class="headerlink" title="2. 选择功能（输入序号）。"></a>2. 选择功能（输入序号）。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. （首次使用）引导填写并重新生成xxx.dat和xxx_mstd.txt文件</span><br><span class="line">   </span><br><span class="line">2. 根据xxx_mstd.txt生成phi、c和gamma的值</span><br><span class="line">   </span><br><span class="line">3. 计算失效概率,并生成xxx_fail.res文件,储存失效概率</span><br><span class="line">   </span><br><span class="line">4. 生成xxx_grid.txt文件,储存网格点的序号(多层土的情况使用)</span><br><span class="line">   </span><br><span class="line">5. 根据xxx_mstd.txt重新生成某参数值</span><br><span class="line"></span><br><span class="line">0. 退出程序(默认)</span><br></pre></td></tr></table></figure><h3 id="功能使用教程"><a href="#功能使用教程" class="headerlink" title="功能使用教程"></a>功能使用教程</h3><ol><li>第一次使用选择<code>1</code>填写<code>xxx.dat</code>和<code>xxx_mstd.txt</code>文件（也可直接修改示例文件来使用）</li></ol><p><strong>建议先查看示例文件</strong></p><p><strong>若填写过程中出现填写错误，可继续填写，等待填写完成再从生成文件内修改错误</strong></p><p><strong>功能4，可协助填写<code>xxx.dat</code>文件，后文介绍</strong></p><ol><li>再选择<code>2</code>根据提示进行选择（以内摩擦角和粘聚力为随机参数为例）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请输入模拟次数:10000</span><br><span class="line">请输入参数类型(10:内摩擦角,20:粘聚力,30:重度) 10</span><br><span class="line">请输入分布类型(0:定值（默认）,1:正态分布,2:对数正态分布) 1</span><br><span class="line">已生成xxx_c.txt文件!</span><br><span class="line">请输入参数类型(10:内摩擦角,20:粘聚力,30:重度) 20</span><br><span class="line">请输入分布类型(0:定值（默认）,1:正态分布,2:对数正态分布): 1</span><br><span class="line">已生成xxx_phi.txt文件!</span><br></pre></td></tr></table></figure><ol><li><p>文件上传计算</p></li><li><p>计算完成后，将结果文件<code>xxx_fs.res</code>放置与本程序在同一文件夹内，运行程序选择<code>3</code>，结果保存在<code>xxx_fail.res</code>文件</p></li></ol><p><strong>功能4介绍（单层土不需要使用）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">！根据自己划分的每层土的单元格数（不是高度）填写即可，注意与ny1和ny2区分</span><br><span class="line">请输入第1层土的厚度(竖向单元格数): 16</span><br><span class="line">请输入第2层土的厚度(竖向单元格数): 5</span><br><span class="line">已生成xxx_grid.txt文件!</span><br></pre></td></tr></table></figure><p><code>xxx_grid.txt</code>的内容复制到<code>xxx.dat</code>文件的以下位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;Choose whether to set it as a random variable (the order is: phi c gamma,1 is random)&quot;</span><br><span class="line">1 1 0</span><br><span class="line"></span><br><span class="line">&quot;Property group assigned to each element (etype, data not needed if np_types=1)&quot;</span><br><span class="line">（--------此位置--------）</span><br><span class="line"></span><br><span class="line">&quot;Pseudo-static analysis: Horizontal acceleration factor (k_h)&quot;</span><br><span class="line">0.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 边坡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 边坡稳定性 </tag>
            
            <tag> Fortran </tag>
            
            <tag> 失效概率 </tag>
            
            <tag> Monte-Carlo </tag>
            
            <tag> Python </tag>
            
            <tag> 有限元 </tag>
            
            <tag> 教程及说明 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
