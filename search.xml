<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git撤销操作</title>
      <link href="/2024/05/04/2024-05-04-git-restore/"/>
      <url>/2024/05/04/2024-05-04-git-restore/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-撤销操作"><a href="#Git-撤销操作" class="headerlink" title="Git 撤销操作"></a>Git 撤销操作</h1><p>学习视频：<a href="https://www.bilibili.com/video/BV1ne4y1S7S9/?share_source=copy_web&amp;vd_source=374d2addde246f63ad679abfc5ab707c">十分钟学会常用git撤销操作，全面掌握git的时光机</a> </p><h2 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h2><blockquote><ul><li><p>Disk</p><ul><li>Init</li></ul></li><li><p>Staging(add)</p><ul><li>Init</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><h1 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h1><p>仅对文件做了修改但未add, 想要返回到初始状态</p><p>状态如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><p>想要删除此修改, 只需使用以下命令, <code>&lt;filename&gt;</code>表示要恢复的文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;filename&gt;</span><br><span class="line">或者</span><br><span class="line">git restore &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>操作后恢复到原始状态</p><blockquote><ul><li><p>Disk</p><ul><li>Init~~ — change~~</li></ul></li><li><p>Staging(add)</p><ul><li>Init </li></ul></li><li><p>Local-git(commit)</p><ul><li>Init</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><h1 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h1><p>若文件已经add</p><p>状态如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init — change</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><ol><li>若仅取消暂存, 可以使用下面的命令恢复</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;filename&gt;</span><br><span class="line">或者</span><br><span class="line">git restore --staged &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>此操作仅会把文件重暂存区取出, 不会删除修改</p><p>操作后恢复到以下状态</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init~~ — change~~</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><ol><li>若想要连修改一起撤回, 使用以下命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>HEAD</code>表示最近的一次提交, 类似的<code>HEAD~1</code>表示倒数第二次提交</p></blockquote><h1 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h1><p>更改已经提交, 也就是如下状态</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init — change</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init — change</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><ol><li>此时要想仅取消此提交不撤销更改, 使用以下命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><p>此时状态如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init — change</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init<del>—change</del></li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><ol><li>若想要将暂存一起取消, 则不使用<code>--soft</code>参数, 即</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD~1</span><br><span class="line">等价于</span><br><span class="line">git reset --mixed HEAD~1</span><br></pre></td></tr></table></figure><p>此时状态如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init <del>— change</del></li></ul></li><li><p>Local-git(commit)</p><ul><li>Init<del>—change</del></li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><ol><li>若想完全回到上一次提交(本提交的前一次), 文件的修改也完全恢复到该次提交的状态. 使用以下命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~1</span><br></pre></td></tr></table></figure><p>此时恢复到如下状态</p><blockquote><ul><li><p>Disk</p><ul><li>Init <del>— change</del></li></ul></li><li><p>Staging(add)</p><ul><li>Init <del>— change</del></li></ul></li><li><p>Local-git(commit)</p><ul><li>Init<del>—change</del></li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><hr><p>对于以上的恢复, 还有一种方式, 即在<code>change</code>的基础上加一个<code>-change</code>使文件在结果上恢复到上一次提交的状态</p><p>使用以下命令可以实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure><p>效果如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change — <code>-change</code>    ==  Init</li></ul></li><li><p>Staging(add)</p><ul><li>Init — change— <code>-change</code></li></ul></li><li><p>Local-git(commit)</p><ul><li>Init—change— <code>-change</code></li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><p>此命令还可以用于撤销之前的某一次提交的修改</p><p>例如, 当前状态如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change1 —change2</li></ul></li><li><p>Staging(add)</p><ul><li>Init — change1 —change2</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init — change1 —change2</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><p>使用如下命令, 撤销<code>change1</code>, <code>&lt;hash&gt;</code>指要撤销提交的hash值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD~1</span><br><span class="line">或者</span><br><span class="line">git revert &lt;hash&gt;</span><br></pre></td></tr></table></figure><p>达到如下效果</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change1 —change2 —<code>-change1</code></li></ul></li><li><p>Staging(add)</p><ul><li>Init — change1 —change2—<code>-change1</code></li></ul></li><li><p>Local-git(commit)</p><ul><li>Init — change1 —change2—<code>-change1</code></li></ul></li><li><p>Remote-git(push)</p><ul><li>Init</li></ul></li></ul></blockquote><p>此命令在远程提交的撤销中起着重要作用, 见下文</p><hr><h1 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h1><p>修改已经push到了Github上</p><p>状态如下</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change</li></ul></li><li><p>Staging(add)</p><ul><li>Init — change</li></ul></li><li><p>Local-git(commit)</p><ul><li>Init — change</li></ul></li><li><p>Remote-git(push)</p><ul><li>Init — change</li></ul></li></ul></blockquote><ol><li>对于公有分支(不止一人使用该分支的情况), 只能使用<code>revert</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure><p>恢复到如下状态</p><blockquote><ul><li><p>Disk</p><ul><li>Init — change — <code>-change</code> </li></ul></li><li><p>Staging(add)</p><ul><li>Init — change— <code>-change</code></li></ul></li><li><p>Local-git(commit)</p><ul><li>Init—change— <code>-change</code></li></ul></li><li><p>Remote-git(push)</p><ul><li>Init —change— <code>-change</code></li></ul></li></ul></blockquote><ol><li>对于个人分支, <code>reset</code>和<code>revert</code>均可, 但若使用<code>reset</code>恢复了提交, 在push时需要加上<code>-f</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><blockquote><p><code>-f</code>表示强制, 在共有分支应避免使用, 或者禁止使用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu22.04双系统安装教程</title>
      <link href="/2024/05/04/2024-05-04-ubuntu-22-04/"/>
      <url>/2024/05/04/2024-05-04-ubuntu-22-04/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><blockquote><p>良好的网络环境</p><p>一块8g以上的U盘(注意备份数据, 该U盘会被格式化)</p><p>Windows电脑</p></blockquote><h1 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h1><blockquote><ul><li>双核2 GHz处理器或更高</li><li>4 GB系统内存</li><li>25 GB磁盘存储空间</li></ul></blockquote><h1 id="装机需谨慎-做好数据备份"><a href="#装机需谨慎-做好数据备份" class="headerlink" title="装机需谨慎, 做好数据备份"></a>装机需谨慎, 做好数据备份</h1><h1 id="1-系统镜像的下载"><a href="#1-系统镜像的下载" class="headerlink" title="1. 系统镜像的下载"></a>1. 系统镜像的下载</h1><p>打开<a href="https://cn.ubuntu.com/download">Ubuntu系统下载 | Ubuntu</a> 此页面,点击<strong>下载Ubuntu桌面版</strong>, </p><p><img title="" src="../img/post/2024-05/17147917131721714791712490.png" alt="" data-align="center"></p><p>再选择Ubuntu22.04.4 LTS,点击<strong>下载22.04.4</strong></p><p><img src="/img/post/2024-05/17147917131721714791712490.png" title="" alt="" data-align="center"></p><p>将此文件下载保存至<strong>易寻找的位置</strong>, 以<code>F:/Ubuntu</code>为例, 稍后会使用. </p><p>其他版本可在官网下载<a href="https://ubuntu.com/download">Get Ubuntu | Download | Ubuntu</a> 安装步骤大致相同</p><h1 id="2-安装写盘工具Rufus"><a href="#2-安装写盘工具Rufus" class="headerlink" title="2. 安装写盘工具Rufus"></a>2. 安装写盘工具Rufus</h1><p>打开<a href="https://rufus.ie/zh/">Rufus - 轻松创建 USB 启动盘</a> 页面, 找到下载,选择Windows x64平台的便携版, 下载打开即用. </p><p><img title="" src="/img/post/2024-05/17147921031721714792103079.png" alt="Rufus" width="427" data-align="center"></p><p>插入U盘,打开软件</p><p><img title="" src="/img/post/2024-05/17147925571721714792556827.png" alt="rufus" data-align="center" width="330"></p><p>点击选择, 设备选择刚刚插入的U盘, 镜像文件点击右侧<strong>选择</strong>, 选中刚刚下载的镜像文件, 我的是位于<code>F:/Ubuntu</code>, 选项如下图即可, 点击开始, 等待写入完成, 点击关闭, 弹出U盘</p><p><img title="" src="/img/post/2024-05/17147928271751714792827027.png" alt="写盘例子" data-align="center" width="343"></p><h1 id="3-关闭Bitlocker或者备份Bitlocker恢复密钥"><a href="#3-关闭Bitlocker或者备份Bitlocker恢复密钥" class="headerlink" title="3. 关闭Bitlocker或者备份Bitlocker恢复密钥"></a>3. 关闭Bitlocker或者备份Bitlocker恢复密钥</h1><p>如果硬盘设置了Bitlocker, 一定要提前找到恢复密钥, 可以先保存到手机上, 一般在微软账户里会有备份<a href="https://account.microsoft.com/devices/recoverykey">恢复密钥</a></p><p>如果找不到了, 开始前一定要关闭Bitlocker. 改动引导顺序和安全启动选项会触发BitLocker, 要求输入恢复密钥. 否则你将无法打开Windows系统或已加密数据</p><p>关闭过程时间可能较长</p><h1 id="4-压缩硬盘空间-双系统需要-若全新安装不需要"><a href="#4-压缩硬盘空间-双系统需要-若全新安装不需要" class="headerlink" title="4. 压缩硬盘空间(双系统需要,若全新安装不需要)"></a>4. 压缩硬盘空间(双系统需要,若全新安装不需要)</h1><p>打开Windows的磁盘管理工具, 右键开始菜单图标, 选择磁盘管理</p><p><img title="" src="/img/post/2024-05/17147932811721714793280589.png" alt="磁盘管理" data-align="center" width="99"></p><p>找到需要压缩的分区, 右键点击压缩卷</p><p><img src="/img/post/2024-05/17148029131721714802912658.png" title="" alt="" data-align="center"></p><p>输入合适的空间, 建议40GB以上, 最低不低于官网要求的25GB, 点击压缩即可</p><p><img title="" src="/img/post/2024-05/17147936311721714793630731.png" alt="压缩盘" data-align="center" width="523"></p><h1 id="5-关闭安全启动-设置U盘启动"><a href="#5-关闭安全启动-设置U盘启动" class="headerlink" title="5. 关闭安全启动, 设置U盘启动"></a>5. 关闭安全启动, 设置U盘启动</h1><p>网络上搜索自己的电脑进入BIOS的方法, surface go系列是按音量加键, 一般电脑是按F2或者F10, 以自己的电脑为准, 进入BIOS,关闭安全启动, 设置启动顺序, 将<strong>USB设备</strong>设置到最上面, 由于每台设备情况不同, 此处设置请自行搜索自己电脑的教程. </p><blockquote><p>surface go系列安全启动会有三个选项</p><ul><li><p>微软</p></li><li><p>微软和第三方</p></li><li><p>关闭</p></li></ul><p>选择微软和第三方即可</p></blockquote><h1 id="6-插入U盘-启动电脑"><a href="#6-插入U盘-启动电脑" class="headerlink" title="6. 插入U盘, 启动电脑"></a>6. 插入U盘, 启动电脑</h1><p>在上一步设置完成之后, 若处于开机状态就插入U盘, 重启电脑, 引导位置选择</p><blockquote><p> Try or Install Ubuntu</p></blockquote><p><img title="" src="/img/post/2024-05/17147944191741714794418714.png" alt="" data-align="center" width="411"></p><p>等待进入安装界面, 选择中文</p><p><img src="/img/post/2024-05/2024-05-04-11-49-41-image.png" title="" alt="" data-align="center"></p><p>如果出现窗口显示不全, 点击试用Ubuntu,如果像我一样可以看到全部窗口, 就点击安装Ubuntu, 跳转到下面<a href="#开始安装">开始安装</a>教程</p><hr><p>点击试用之后, 会出现如下界面</p><p><img src="/img/post/2024-05/17147948611731714794860481.png" title="" alt="" data-align="center"></p><p>点击该图标, 再打开设置, 找到显示器, 缩放比例选择100%, 点击保存(我使用的虚拟机没有该选项, 就在红框的位置. 保存在夜灯右边位置, 修改后会出现)</p><p><img src="/img/post/2024-05/17147950071731714795006916.png" title="" alt="" data-align="center"></p><p>保存之后再选择安装Ubuntu就可以了</p><hr><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>键盘布局默认即可</p><p><img src="/img/post/2024-05/17147952601721714795259521.png" title="" alt="" data-align="center"></p><p><img src="/img/post/2024-05/17147954161721714795415388.png" title="" alt="" data-align="center"></p><p><img src="/img/post/2024-05/17147983241721714798323701.png" title="" alt="" data-align="center"></p><hr><p>双系统手动分区</p><p><img src="/img/post/2024-05/17147958441721714795843478.png" title="" alt="" data-align="center"></p><p>建议分区</p><ol><li>创建交换空间</li></ol><blockquote><p>填写大小: 建议与内存大小相同, 4G 8G 16G都可</p><p>分区类型: 逻辑分区</p><p>新分区位置:空间起始分区(下面也都是这个不用改)</p><p>用于: 交换空间</p></blockquote><ol><li>创建根目录分区</li></ol><blockquote><p>填写大小: 如果空间太小就把剩下的全给根目录, 方便后面扩容, 如果空间充足就给20GB以上均可,主要存放系统文件和安装软件</p><p>分区类型: 主分区</p><p>新分区位置:空间起始分区(下面也都是这个不用改)</p><p>用于: Ext4 日志文件系统</p><p>挂载点: /</p></blockquote><p>可选分区</p><ol><li>创建引导分区(双系统同盘可不创建, 放置在Windows系统的引导分区里即可)</li></ol><blockquote><p>填写大小: 建议200MB-1024MB根据个人情况来,这里我给了500MB</p><p>分区类型: 主分区</p><p>新分区位置: 空间起始分区(下面也都是这个不用改)</p><p>用于: EFI</p></blockquote><ol><li>如果空间充足可给/home分区单独设置, 后面想扩容之类的就上面三个分区就可以了, 后面扩容完可以再分</li></ol><blockquote><p>填写大小: 20GB以上均可, 看个人使用情况, 存放用户文件, 类似Windows的Users目录</p><p>分区类型: 主分区</p><p>新分区位置:空间起始分区(下面也都是这个不用改)</p><p>用于: Ext4 日志文件系统</p><p>挂载点: /home</p></blockquote><p>最终效果如下</p><p><img src="/img/post/2024-05/17147992621741714799261504.png" title="" alt="" data-align="center"></p><hr><p> 点击<strong>现在安装</strong>  —&gt; <strong>继续</strong>, 时区选择上海, 点击<strong>继续</strong></p><p><img src="/img/post/2024-05/17147994631731714799462725.png" title="" alt="" data-align="center"></p><p>用户信息按自己的填写即可. 可以勾选自动登录, 每次开机不需要选择用户, 自动登录.</p><p><img src="/img/post/2024-05/17147995742451714799574189.png" title="" alt="" data-align="center"></p><p>点击<strong>继续</strong>即可安装, 安装之后选择重启, 根据提示会让你拔掉U盘, 按ENTER(回车键)</p><hr><p>至此双系统就安装好了. 每次启动时, 系统会提示选择Ubuntu还是Windows系统一般是4个选项</p><blockquote><p>Ubuntu</p><p>Ubuntu高级设置</p><p>Windows</p><p>EFI</p></blockquote><p>顺序可能不同,名称仅为示例, 很容易识别</p><blockquote><p>若未关闭Bitlocker, 进入Windows系统需要输入一次恢复密钥, 下次进入就不需要了.</p></blockquote><p>如果安装没有什么问题, 之前下载的镜像文件就可以清理了</p>]]></content>
      
      
      <categories>
          
          <category> 教程及说明 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 安装教程 </tag>
            
            <tag> 硬盘分区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记——流体力学基本方程（二）（未完成）</title>
      <link href="/2024/04/27/2024-04-22-study-note-002/"/>
      <url>/2024/04/27/2024-04-22-study-note-002/</url>
      
        <content type="html"><![CDATA[<h1 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h1><h2 id="Bilibili-流体力学基础科普-北斗导航Compass"><a href="#Bilibili-流体力学基础科普-北斗导航Compass" class="headerlink" title="Bilibili-流体力学基础科普-北斗导航Compass"></a><a href="https://www.bilibili.com/video/BV1Ty4y1M7Fx/?share_source=copy_web&amp;vd_source=374d2addde246f63ad679abfc5ab707c">Bilibili-流体力学基础科普-北斗导航Compass</a></h2><p>参考教材：<a href="https://pan.baidu.com/s/1fbj6e9Xk6LmWW2Vjmu0oIw?pwd=eavw">Fundamentals of AERODYNAMICS by John D. Anderson, Jr.</a></p><hr><h1 id="二、基本方程"><a href="#二、基本方程" class="headerlink" title="二、基本方程"></a>二、基本方程</h1><h2 id="1-质量守恒方程-连续方程"><a href="#1-质量守恒方程-连续方程" class="headerlink" title="1. 质量守恒方程(连续方程)"></a>1. 质量守恒方程(连续方程)</h2><p> <strong>控制体内流体总质量的增量 = 流入控制体的流体质量</strong></p><p>积分形式的质量守恒方程</p><script type="math/tex; mode=display">{\iiint}_{cv}\Big[\frac{\partial \rho}{\partial t}+\frac{\partial(\rho u)}{\partial x}+\frac{\partial(\rho v)}{\partial y}+\frac{\partial(\rho w)}{\partial z}\Big]dV=0</script><p>微分形式的质量守恒方程</p><script type="math/tex; mode=display">\frac{\partial \rho}{\partial t}+\frac{\partial(\rho u)}{\partial x}+\frac{\partial(\rho v)}{\partial y}+\frac{\partial(\rho w)}{\partial z}=0</script><p>用哈密顿算子表示,可写为</p><script type="math/tex; mode=display">\frac{\partial \rho}{\partial t}+\vec{\nabla}\cdot(\rho\vec{v})=0</script><hr><h2 id="2-动量守恒方程"><a href="#2-动量守恒方程" class="headerlink" title="2. 动量守恒方程"></a>2. 动量守恒方程</h2><p> <strong>控制体内流体总动量的增量 = 流入控制体的流体动量 + 外界的力产生的动量增量</strong></p><h2 id="3-能量守恒方程"><a href="#3-能量守恒方程" class="headerlink" title="3. 能量守恒方程"></a>3. 能量守恒方程</h2><p> <strong>控制体内流体的总能量的增量 = 流入控制体的流体能量 + 外界的作用产生的能量增量</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流体力学 </tag>
            
            <tag> 动量守恒方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 工作流程</title>
      <link href="/2024/04/24/2024-4-24-Github-work/"/>
      <url>/2024/04/24/2024-4-24-Github-work/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-工作流程——以Github为例"><a href="#Git-工作流程——以Github为例" class="headerlink" title="Git 工作流程——以Github为例"></a>Git 工作流程——以Github为例</h1><p><strong>适用于个人和小团队的标准工作模式</strong></p><p>学习视频：<a href="https://www.bilibili.com/video/BV19e4y1q7JJ/?share_source=copy_web&amp;vd_source=374d2addde246f63ad679abfc5ab707c">十分钟学会正确的github工作流，和开源作者们使用同一套流程</a></p><p>假设项目初始内容如下</p><blockquote><ul><li><p>Github: </p><ul><li>main(master) 分支 Init 内容</li></ul></li><li><p>Loacl git: </p><ul><li>main(master) 分支 Init 内容</li></ul></li><li><p>DIsk: </p><ul><li>main(master) 分支 Init 内容（仅作理解）</li></ul></li></ul></blockquote><h2 id="1-建立个人工作分支"><a href="#1-建立个人工作分支" class="headerlink" title="1. 建立个人工作分支"></a>1. 建立个人工作分支</h2><p>使用如下命令创建一个个人工作的分支并切换到该分支上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b my-feature</span><br></pre></td></tr></table></figure><p>当前状态如下</p><blockquote><ul><li><p>Github: </p><ul><li>main(master) 分支 Init 内容</li></ul></li><li><p>Loacl git: </p><ul><li>main(master) 分支 Init 内容</li><li><code>my-feature分支 Init 内容</code></li></ul></li><li><p>DIsk: </p><ul><li><code>my-feature分支</code> Init 内容</li></ul></li></ul></blockquote><h2 id="2-对本地内容进行修改、提交、推送"><a href="#2-对本地内容进行修改、提交、推送" class="headerlink" title="2. 对本地内容进行修改、提交、推送"></a>2. 对本地内容进行修改、提交、推送</h2><h3 id="1-当前状态如下"><a href="#1-当前状态如下" class="headerlink" title="(1) 当前状态如下"></a>(1) 当前状态如下</h3><blockquote><ul><li><p>Github: </p><ul><li>main(master) 分支 Init 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 Init 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 <code>Init-changes</code> 内容</li></ul></li></ul></blockquote><p>使用<code>git diff</code>可查看对比做出修改的内容</p><h3 id="2-暂存更改内容"><a href="#2-暂存更改内容" class="headerlink" title="(2) 暂存更改内容"></a>(2) 暂存更改内容</h3><p>使用<code>git add &lt;filename&gt;</code>暂存已做出的修改</p><p>此时状态如下</p><blockquote><ul><li><p>Github: </p><ul><li>main(master) 分支 Init 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 <code>Init-changes</code> 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 Init-changes 内容</li></ul></li></ul></blockquote><h3 id="3-提交已暂存的更改"><a href="#3-提交已暂存的更改" class="headerlink" title="(3) 提交已暂存的更改"></a>(3) 提交已暂存的更改</h3><p>使用<code>git commit</code>命令提交</p><p>若想添加注释可使用如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;text&quot;</span><br></pre></td></tr></table></figure><p>此时状态如下</p><blockquote><ul><li><p>Github: </p><ul><li>main(master) 分支 Init 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 <code>Init-f-commit</code> 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 Init-f-commit 内容</li></ul></li></ul></blockquote><h3 id="4-将内容push到Github上"><a href="#4-将内容push到Github上" class="headerlink" title="(4) 将内容push到Github上"></a>(4) 将内容<code>push</code>到Github上</h3><p>使用<code>git push origin my-feature</code>将内容push到Github中自己的分支</p><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 <code>Init-f-commit</code> 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 Init-f-commit 内容</li></ul></li></ul></blockquote><p><strong>若此时GitHub中的main(master)分支有其他的修改或提交，须进行第三步<a href="#处理主分支的改变">处理主分支的改变</a></strong></p><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 <code>Init-update</code> 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 Init-f-commit 内容</li></ul></li></ul></blockquote><h2 id="3-处理主分支的改变"><a href="#3-处理主分支的改变" class="headerlink" title="3. 处理主分支的改变"></a>3. 处理主分支的改变</h2><h3 id="1-本地返回main-master-分支"><a href="#1-本地返回main-master-分支" class="headerlink" title="(1) 本地返回main(master)分支"></a>(1) 本地返回main(master)分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init-update 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li><code>main(master)分支 Init 内容</code></li></ul></li></ul></blockquote><h3 id="（2）拉取远程改变"><a href="#（2）拉取远程改变" class="headerlink" title="（2）拉取远程改变"></a>（2）拉取远程改变</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init-update 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 <code>Init-update</code> 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li>main(master)分支 <code>Init-update</code> 内容</li></ul></li></ul></blockquote><h3 id="3-切换回my-feature分支并合并代码"><a href="#3-切换回my-feature分支并合并代码" class="headerlink" title="(3) 切换回my-feature分支并合并代码"></a>(3) 切换回my-feature分支并合并代码</h3><p>使用以下命令切换回<code>my-feature</code>分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout my-feature</span><br></pre></td></tr></table></figure><p>再使用以下命令合并代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase main</span><br></pre></td></tr></table></figure><p>此时可能会出现<code>rebase conflict</code>，需要手动选择要保留的代码</p><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init-update 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init-update 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li><code>my-feature</code>分支 <code>Init-update-f-commit</code> 内容</li></ul></li></ul></blockquote><h3 id="4-推送my-feature分支"><a href="#4-推送my-feature分支" class="headerlink" title="(4) 推送my-feature分支"></a>(4) 推送<code>my-feature</code>分支</h3><p>使用以下命令推送</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin my-feature</span><br></pre></td></tr></table></figure><p><strong><code>-f</code>表示强制，切忌在push<code>main</code>分支时使用，须谨慎谨慎再谨慎!!!!!!!!!</strong></p><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init-update 内容</li><li>my-feature分支 <code>Init-update-f-commit</code> 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init-update 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 Init-update-f-commit 内容</li></ul></li></ul></blockquote><h3 id="5-审查并合并到main分支"><a href="#5-审查并合并到main分支" class="headerlink" title="(5) 审查并合并到main分支"></a>(5) 审查并合并到<code>main</code>分支</h3><p><strong>此时生成新的<code>pull request</code>,项目管理员审查代码之后<code>Squash and merge</code>合并分支的改变并同步到<code>main</code>分支，简化提交内容，此时状态如下</strong></p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 <code>Init-update-update2</code> 内容</li><li><del><code>my-feature 分支</code></del></li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init-uodate 内容</li><li>my-feature分支 Init-f-commit 内容</li></ul></li><li><p>DIsk: </p><ul><li>my-feature分支 Init-update-f-commit 内容</li></ul></li></ul></blockquote><h3 id="6-清理本地分支"><a href="#6-清理本地分支" class="headerlink" title="(6) 清理本地分支"></a>(6) 清理本地分支</h3><p>a. 切换到main(master)分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure><p>b. 删除my-feature分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D my-feature</span><br></pre></td></tr></table></figure><p><strong><code>-D</code>表示强制删除，切忌使用在main分支上，须谨慎谨慎再谨慎!!!!!!!!</strong></p><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init-update-update2 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init-update 内容</li><li><del><code>my-feature分支 Init-f-commit 内容</code></del></li></ul></li><li><p>DIsk: </p><ul><li><code>main(master)分支 Init-update 内容</code></li></ul></li></ul></blockquote><p>c. 拉取最新main(master)分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><p>此时状态如下</p><blockquote><ul><li><p>Github:</p><ul><li>main(master) 分支 Init-update-update2 内容</li></ul></li><li><p>Loacl git:  </p><ul><li>main(master) 分支 Init-update<code>-update2</code> 内容</li></ul></li><li><p>DIsk: </p><ul><li>main(master)分支 Init-update<code>-update2</code> 内容</li></ul></li></ul></blockquote><p>至此一个工作环节结束</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Git </tag>
            
            <tag> 工作流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记——流体力学基本方程（一）</title>
      <link href="/2024/04/22/2024-04-22-study-note-001/"/>
      <url>/2024/04/22/2024-04-22-study-note-001/</url>
      
        <content type="html"><![CDATA[<h1 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h1><h2 id="Bilibili-流体力学基础科普-北斗导航Compass"><a href="#Bilibili-流体力学基础科普-北斗导航Compass" class="headerlink" title="Bilibili-流体力学基础科普-北斗导航Compass"></a><a href="https://www.bilibili.com/video/BV1Ty4y1M7Fx/?share_source=copy_web&amp;vd_source=374d2addde246f63ad679abfc5ab707c">Bilibili-流体力学基础科普-北斗导航Compass</a></h2><p>参考教材：<a href="https://pan.baidu.com/s/1fbj6e9Xk6LmWW2Vjmu0oIw?pwd=eavw">Fundamentals of AERODYNAMICS by John D. Anderson, Jr.</a></p><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-什么是流体？"><a href="#1-什么是流体？" class="headerlink" title="1. 什么是流体？"></a>1. 什么是流体？</h2><ul><li>对比固体和流体的区别</li></ul><blockquote><p>对于固体剪切力与<strong>形变量</strong>成正比</p><p>对于流体剪切力与<strong>形变量的时间变化率</strong>成正比</p></blockquote><ul><li>解释流体为什么能流起来？</li></ul><blockquote><p>对于流体如果流体中的<strong>剪切力</strong>是常数，则其形变量的时间变化率也应为常数，即流体一直发生形变（流动）</p></blockquote><ul><li>流体在抗压时可以静止，在抗剪时一定在运动</li></ul><h2 id="2-流体质点"><a href="#2-流体质点" class="headerlink" title="2. 流体质点"></a>2. 流体质点</h2><p>将流体看作无穷多的质点的结合，符合连续介质假设</p><h2 id="3-描述流体的物理量"><a href="#3-描述流体的物理量" class="headerlink" title="3. 描述流体的物理量"></a>3. 描述流体的物理量</h2><blockquote><p>包括速度、密度、压强、温度等等</p></blockquote><ul><li>压强(压力) Pressure 单位Pa</li></ul><script type="math/tex; mode=display">P=\frac{F}{A}\ \ \ \ 当A\rightarrow0时\ \ \ P=frac{dF}{dA}</script><ul><li>密度 单位 $kg/m^3$ </li></ul><script type="math/tex; mode=display">\rho=\frac{m}{V}\ \ \ 当V\rightarrow0时\ \ \ \rho=\frac{dm}{dV}</script><ul><li>温度 单位K</li></ul><script type="math/tex; mode=display">0°C=273.15K</script><h2 id="4-描述流体运动的方法"><a href="#4-描述流体运动的方法" class="headerlink" title="4. 描述流体运动的方法"></a>4. 描述流体运动的方法</h2><ul><li>拉格朗日法</li></ul><blockquote><p>以质点为研究对象,跟踪质点的运动</p></blockquote><ul><li>欧拉法</li></ul><blockquote><p>以确定空间为研究对象,研究某一空间点不同时间下,在此空间点的质点的运动</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">积分方法</th><th style="text-align:center">微分方法</th></tr></thead><tbody><tr><td style="text-align:center">拉格朗日法</td><td style="text-align:center">一坨流体</td><td style="text-align:center">质点</td></tr><tr><td style="text-align:center">欧拉法</td><td style="text-align:center">控制体</td><td style="text-align:center">空间点</td></tr></tbody></table></div><h1 id="二、基本方程"><a href="#二、基本方程" class="headerlink" title="二、基本方程"></a>二、基本方程</h1><h2 id="1-质量守恒方程-连续方程"><a href="#1-质量守恒方程-连续方程" class="headerlink" title="1. 质量守恒方程(连续方程)"></a>1. 质量守恒方程(连续方程)</h2><p> <strong>控制体内流体总质量的增量 = 流入控制体的流体质量</strong></p><p>欧拉法连续方程的微分形式</p><script type="math/tex; mode=display">\frac{\partial \rho}{\partial t}+\frac{\partial (\rho u)}{\partial x}+\frac{\partial (\rho v)}{\partial y}+\frac{\partial (\rho w)}{\partial z}=0</script><p>其中 $\rho,u,v,w$ 均是 $x,y,z,t$ 的函数,如 $\rho(x,y,z,t)$ </p><p><strong>方程左边:</strong> 单位时间 控制体内流体总质量的增量(为负数就是减量)</p><p>首先,表示总质量</p><script type="math/tex; mode=display">m={\iiint}_{cv}\rho dV</script><p>对时间t求偏导,得</p><script type="math/tex; mode=display">\frac{\partial m}{\partial t}=\frac{\partial ({\iiint}_{cv}\rho dV)}{\partial t}={\iiint}_{cv}\frac{\partial \rho}{\partial t}\ dV</script><p><strong>方程右边:</strong> 单位时间 流入控制体的流体质量</p><p><img src="/img/post/2024-04/17141226084791714122607815.png" alt="" style="zoom:50%;" center/></p><blockquote><p>质量=密度*体积</p></blockquote><script type="math/tex; mode=display">h=v*\Delta t\cos\theta</script><script type="math/tex; mode=display">V=Sh=Sv*\Delta t\cos\theta</script><p>则 $\Delta t$ 时间范围内</p><script type="math/tex; mode=display">m=\rho V=\rho Sv\Delta t\cos\theta</script><script type="math/tex; mode=display">m|_{单位时间}=\rho Sv\cos\theta</script><p>对控制体边界面积分</p><script type="math/tex; mode=display">{\iint}_{cs}\rho \vec{v}\cdot d\vec{S}</script><p>规定控制体表面的外法线方向为正,则方程右边应为添加负号</p><p>即</p><script type="math/tex; mode=display">-{\iint}_{cs}\rho \vec{v}\cdot d\vec{S}</script><p>则可得到积分形式的质量守恒方程</p><script type="math/tex; mode=display">{\iiint}_{cv}\frac{\partial \rho}{\partial t}\ dV=-{\iint}_{cs}\rho \vec{v}\cdot d\vec{S}</script><p>也即</p><script type="math/tex; mode=display">{\iiint}_{cv}\frac{\partial \rho}{\partial t}\ dV+{\iint}_{cs}\rho \vec{v}\cdot d\vec{S}=0</script><p>根据高斯定理</p><script type="math/tex; mode=display">{\iint}_{cs}\rho \vec{v}\cdot d\vec{S}={\iiint}_{cv}[\frac{\partial(\rho u)}{\partial x}+\frac{\partial(\rho v)}{\partial y}+\frac{\partial(\rho w)}{\partial z}]dV</script><p>则积分形式的质量守恒方程可以合并为</p><script type="math/tex; mode=display">{\iiint}_{cv}[\frac{\partial \rho}{\partial t}+\frac{\partial(\rho u)}{\partial x}+\frac{\partial(\rho v)}{\partial y}+\frac{\partial(\rho w)}{\partial z}]dV=0</script><p>可得微分形式的质量守恒方程</p><script type="math/tex; mode=display">\frac{\partial \rho}{\partial t}+\frac{\partial(\rho u)}{\partial x}+\frac{\partial(\rho v)}{\partial y}+\frac{\partial(\rho w)}{\partial z}=0</script><p>用哈密顿算子表示,可写为</p><script type="math/tex; mode=display">\frac{\partial \rho}{\partial t}+\vec{\nabla}\cdot(\rho\vec{v})=0</script><p>下期内容：</p><h2 id="2-动量守恒方程"><a href="#2-动量守恒方程" class="headerlink" title="2. 动量守恒方程"></a>2. 动量守恒方程</h2><p> <strong>控制体内流体总动量的增量 = 流入控制体的流体动量 + 外界的力产生的动量增量</strong></p><h2 id="3-能量守恒方程"><a href="#3-能量守恒方程" class="headerlink" title="3. 能量守恒方程"></a>3. 能量守恒方程</h2><p> <strong>控制体内流体的总能量的增量 = 流入控制体的流体能量 + 外界的作用产生的能量增量</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流体力学 </tag>
            
            <tag> 质量守恒方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>叠加孔压计算程序的修改说明</title>
      <link href="/2024/04/21/2024-04-21-pore-stress-modify/"/>
      <url>/2024/04/21/2024-04-21-pore-stress-modify/</url>
      
        <content type="html"><![CDATA[<h1 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h1><h2 id="1、输入参数改变"><a href="#1、输入参数改变" class="headerlink" title="1、输入参数改变"></a>1、输入参数改变</h2><p>t(nl) 每层层底沉积年代(37 行)<br>土水特征参数 a、m、n 随沉积年代模型参数(54、55 行)<br>内摩擦角 粘聚力 重度 随沉积年代模型非线性(56、57 行)<br>水位位置（坡顶为 0，y 方向为负值）(58 行)<br>非饱和抗剪强度公式中 κ(59 行)</p><h2 id="2、输入所有节点孔压-53-行"><a href="#2、输入所有节点孔压-53-行" class="headerlink" title="2、输入所有节点孔压(53 行)"></a>2、输入所有节点孔压(53 行)</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">READ(<span class="number">12</span>,*)inpore  <span class="comment">!所有节点孔压</span></span><br></pre></td></tr></table></figure><h2 id="3、输出-prop-nprops-np-types-98-85-行"><a href="#3、输出-prop-nprops-np-types-98-85-行" class="headerlink" title="3、输出 prop(nprops,np_types)(98-85 行)"></a>3、输出 prop(nprops,np_types)(98-85 行)</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nprops=<span class="number">10</span> <span class="comment">!分别为内摩擦角、粘聚力、剪胀角、干密度、弹模、泊松比、a、m、n、饱和体积含水率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> g_prop(a1,a2,a3,a4,b1,a5,a6,a7,b2,b3,b4,c1,c2,c3,c4,d1,c5,c6,c7,d2,d3,d5,la_rwt1,   &amp;</span><br><span class="line">  la_rwt2,lm_rwt1,lm_rwt2,ln_rwt1,ln_rwt2,theta_r,zero,gam_w,np_types,nprops,nl,ny,t,   &amp;</span><br><span class="line">  nx1,nx2,ny1,ny2,nye,nod,nels,g_num,num,nn,h,inpore,prop,prop1,theta_w,pa_rwt1,        &amp;</span><br><span class="line">  pa_rwt2,pm_rwt1,pm_rwt2,pm_rwt3,pn_rwt1,pn_rwt2,pn_rwt3)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先，求prop1：一列单元的参数(其中重度为干重度)</span><br><span class="line">其次，求prop：所有单元参数(其中重度为干重度)</span><br><span class="line">之后，判断孔压正负，计算天然体积含水率/使用饱和体积含水率</span><br><span class="line">最后，利用含水率计算天然重度</span><br></pre></td></tr></table></figure><h2 id="4、输出-surf-2-nosurf-79-行"><a href="#4、输出-surf-2-nosurf-79-行" class="headerlink" title="4、输出 surf(2,nosurf) (79 行)"></a>4、输出 surf(2,nosurf) (79 行)</h2><p>根据水位计算水位线上各节点坐标</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> WTpoints(zero,nx1,nx2,nn,ny1,ny2,nod,nels,g_num,gam_w,inpore,g_coord,nosurf,surf,ndim)</span><br></pre></td></tr></table></figure><h2 id="5、绘制网格划分时，将所有网格设置为具有不同参数-81-85-行"><a href="#5、绘制网格划分时，将所有网格设置为具有不同参数-81-85-行" class="headerlink" title="5、绘制网格划分时，将所有网格设置为具有不同参数(81-85 行)"></a>5、绘制网格划分时，将所有网格设置为具有不同参数(81-85 行)</h2><h2 id="6、坡外水位所导致的重度荷载的变化，输出-gravlo-0-neq-119-行"><a href="#6、坡外水位所导致的重度荷载的变化，输出-gravlo-0-neq-119-行" class="headerlink" title="6、坡外水位所导致的重度荷载的变化，输出 gravlo(0:neq) (119 行)"></a>6、坡外水位所导致的重度荷载的变化，输出 gravlo(0:neq) (119 行)</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> water_loads</span><br></pre></td></tr></table></figure><h2 id="7、对于孔压-inpore-的处理"><a href="#7、对于孔压-inpore-的处理" class="headerlink" title="7、对于孔压 inpore 的处理"></a>7、对于孔压 inpore 的处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先，单元循环内提取该单元所有节点的孔压(172行)</span><br><span class="line">其次，利用Vanapalli公式计算吸应力suc_sig (174-176行)</span><br><span class="line">之后，高斯循环中计算高斯点吸应力pore (181行)</span><br><span class="line">最后，修正正应力(186-188行)</span><br></pre></td></tr></table></figure><h2 id="8、若收敛，对应力进行恢复-193-195-行"><a href="#8、若收敛，对应力进行恢复-193-195-行" class="headerlink" title="8、若收敛，对应力进行恢复(193-195 行)"></a>8、若收敛，对应力进行恢复(193-195 行)</h2><h2 id="9、奇偶分层下的变形图-224-行"><a href="#9、奇偶分层下的变形图-224-行" class="headerlink" title="9、奇偶分层下的变形图(224 行)"></a>9、奇偶分层下的变形图(224 行)</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> dismsh</span><br></pre></td></tr></table></figure><h1 id="输入说明"><a href="#输入说明" class="headerlink" title="输入说明"></a>输入说明</h1><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">w1   s1   w2   h1   h2   nl <span class="comment">!分层数  用于划分黄土古土壤序列情况</span></span><br><span class="line"><span class="number">8</span>    <span class="number">4</span>     <span class="number">4</span>    <span class="number">14</span>   <span class="number">8</span>    <span class="number">4</span></span><br><span class="line">h(nl) <span class="comment">!每层层底距坡顶距离</span></span><br><span class="line"><span class="number">4</span>   <span class="number">12</span>   <span class="number">16</span>   <span class="number">22</span></span><br><span class="line">ny(nl) <span class="comment">!每层划分网格数</span></span><br><span class="line"><span class="number">2</span>    <span class="number">4</span>    <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">t(nl) <span class="comment">!每层层底沉积年代</span></span><br><span class="line"><span class="number">8</span>   <span class="number">12</span>   <span class="number">18</span>   <span class="number">33</span></span><br><span class="line">nx1    nx2   ny1    ny2</span><br><span class="line"><span class="number">4</span>       <span class="number">2</span>     <span class="number">7</span>    <span class="number">4</span></span><br><span class="line"><span class="comment">!土水特征参数a、m、n随沉积年代模型参数</span></span><br><span class="line"><span class="number">0.044</span>     <span class="number">7.062</span>      -<span class="number">0.0000724</span>      <span class="number">0.3318</span>              -<span class="number">0.000161</span>      <span class="number">1.5092</span></span><br><span class="line"><span class="number">24.4397</span>   -<span class="number">113.0186</span>   <span class="number">0.000000176</span>   -<span class="number">0.0000591</span>   <span class="number">0.2077</span>   <span class="number">0.000000331</span>   -<span class="number">0.000128</span>   <span class="number">1.2664</span></span><br><span class="line"><span class="comment">!内摩擦角     粘聚力        剪胀角     重度                    弹模 泊松比  比重</span></span><br><span class="line"><span class="number">0</span>  <span class="number">18.5</span>       <span class="number">0.17</span>    <span class="number">0</span>      <span class="number">0.0</span>        <span class="number">1.25</span>   <span class="number">0.018</span>    <span class="number">0.4623</span>   <span class="number">1.0e5</span>   <span class="number">0.3</span>  <span class="number">2.71</span></span><br><span class="line"><span class="number">0</span>  <span class="number">18.5</span>       <span class="number">3.56</span>   <span class="number">500</span>     <span class="number">0.0</span>        <span class="number">1.39</span>   <span class="number">0.0035</span>   <span class="number">0.6489</span>   <span class="number">1.0e5</span>   <span class="number">0.3</span>  <span class="number">2.72</span></span><br><span class="line"><span class="comment">!水位位置（坡顶为0，y方向为负值）</span></span><br><span class="line">-<span class="number">100</span></span><br><span class="line"><span class="comment">!非饱和抗剪强度公式中κ</span></span><br><span class="line"><span class="number">1.4</span></span><br><span class="line"><span class="comment">!收敛准则  计算次数</span></span><br><span class="line"><span class="number">0.0001</span>   <span class="number">500</span></span><br><span class="line"><span class="comment">!折减次数</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="comment">!折减系数</span></span><br><span class="line"><span class="number">0.8</span>  <span class="number">0.9</span>  <span class="number">1.0</span>  <span class="number">1.1</span>  <span class="number">1.2</span>  <span class="number">1.3</span>  <span class="number">1.4</span>  <span class="number">1.5</span>  <span class="number">1.6</span></span><br></pre></td></tr></table></figure><hr><p>非本人原创内容</p>]]></content>
      
      
      <categories>
          
          <category> 教程及说明 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 边坡稳定性 </tag>
            
            <tag> Fortran </tag>
            
            <tag> 孔压 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非饱和土边坡稳定性计算程序说明文件</title>
      <link href="/2024/04/20/2024-04-20-p64-load-pore/"/>
      <url>/2024/04/20/2024-04-20-p64-load-pore/</url>
      
        <content type="html"><![CDATA[<h1 id="一、数据文件"><a href="#一、数据文件" class="headerlink" title="一、数据文件"></a>一、数据文件</h1><h3 id="注意：以下文件内不要输入注释文字"><a href="#注意：以下文件内不要输入注释文字" class="headerlink" title="注意：以下文件内不要输入注释文字"></a>注意：以下文件内不要输入注释文字</h3><h4 id="1-dat文件"><a href="#1-dat文件" class="headerlink" title="1. dat文件"></a>1. dat文件</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!dx  h2v</span></span><br><span class="line"><span class="number">1.0</span>  <span class="number">2.0</span></span><br><span class="line"><span class="comment">!nx1 nx2 ny1 ny2</span></span><br><span class="line"><span class="number">20</span>  <span class="number">20</span>  <span class="number">10</span>  <span class="number">5</span></span><br><span class="line"><span class="comment">!树荷载的左列和右列数，单位长度的树荷载kN/m</span></span><br><span class="line"><span class="number">27</span> <span class="number">32</span> <span class="number">10.0</span></span><br><span class="line"><span class="comment">!内摩擦角，粘聚力，剪胀角，重度，弹性模量，泊松比, a, m, n, theta_s 其中,重度=ρ_d*gam_w,theta_s=1-ρ_d/G_s</span></span><br><span class="line"><span class="number">20.0</span>  <span class="number">15.0</span>  <span class="number">0.0</span>  <span class="number">20.0</span>  <span class="number">1.0e5</span>  <span class="number">0.3</span> <span class="number">15</span> <span class="number">0.2</span> <span class="number">4</span> <span class="number">0.907749</span></span><br><span class="line"><span class="comment">!水位位置（坡顶为0，y方向为负值）</span></span><br><span class="line">-<span class="number">20</span></span><br><span class="line"><span class="comment">!非饱和抗剪强度公式中κ</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment">!收敛准则  计算次数</span></span><br><span class="line"><span class="number">0.0001</span> <span class="number">500</span></span><br><span class="line"><span class="comment">!折减次数</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="comment">!折减系数</span></span><br><span class="line"><span class="number">1.2</span>  <span class="number">1.3</span>  <span class="number">1.4</span>  <span class="number">1.5</span>  <span class="number">1.55</span> <span class="number">1.6</span></span><br></pre></td></tr></table></figure><p><img src="../img/post/2024-04/6619e7df68eb935713ab513c.png" alt="模型"></p><p>其中,第三行表示荷载的加荷位置和大小</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27</span> <span class="comment">! 表示起点在第27列（从左至右）</span></span><br><span class="line"><span class="number">32</span> <span class="comment">! 表示终点在第32列（从左至右）</span></span><br><span class="line"><span class="number">30</span> <span class="comment">! 表示荷载为30kN/m</span></span><br></pre></td></tr></table></figure><p>对应下图中的红色位置</p><p><img src="/img/post/2024-04/6619e7bc68eb935713ab1a65.png" alt="加载位置"></p><h4 id="2-孔压文件x-f-txt"><a href="#2-孔压文件x-f-txt" class="headerlink" title="2. 孔压文件x_f.txt"></a>2. 孔压文件x_f.txt</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按节点列依次输入节点处的孔压</span><br><span class="line">每个单元格有<span class="number">3</span>列共<span class="number">8</span>个节点，呈<span class="number">323</span>分布，如下图所示，阴影部分为一个单元格，黄色为单元格号</span><br><span class="line">按照节点的<span class="number">1234.</span>..顺序竖向填写x_f.txt文件，每节点占一行 </span><br></pre></td></tr></table></figure><p><img src="/img/post/2024-04/17143576814081714357680903.png" alt="17143576814081714357680903png"></p><h1 id="二、源代码"><a href="#二、源代码" class="headerlink" title="二、源代码"></a>二、源代码</h1><p>本程序单元格序号是从上至下，从左至右依次排序,如下例</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">6</span> </span><br><span class="line"><span class="number">2</span> <span class="number">7</span>  <span class="number">11</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span>  <span class="number">12</span> <span class="number">15</span></span><br><span class="line"><span class="number">4</span> <span class="number">9</span>  <span class="number">13</span> <span class="number">16</span> <span class="number">18</span> <span class="number">20</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span> <span class="number">14</span> <span class="number">17</span> <span class="number">19</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p>在叠加荷载时，因为所有单元格的g都是按照3 2 1 4 6 7 8 5 的顺序保存，因此我们仅需找到对应的单元格号以及146号节点的相对位置</p><p>146号节点的相对位置为g(6), g(8), g(10),下文有介绍</p><p>接下来只需找到单元格号即可。</p><h2 id="计算单元号"><a href="#计算单元号" class="headerlink" title="计算单元号"></a>计算单元号</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tree_load/=<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!荷载不为零再进行运算</span></span><br><span class="line">  <span class="built_in">allocate</span>(tree_nodes(nx1+nx2+ny1*ngrad))</span><br><span class="line"></span><br><span class="line">  tree_nodes=<span class="number">0</span></span><br><span class="line">   <span class="comment">! tree_nodes(nx1+nx2+ny1*ngrad)是储存表面单元格的单元号</span></span><br><span class="line"></span><br><span class="line">  itree = <span class="number">2</span> <span class="comment">!用于计数，记录需加荷的单元格数量</span></span><br><span class="line">  tree_nodes(<span class="number">1</span>)=<span class="number">1</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">! 顶面和斜面前ngrad行</span></span><br><span class="line">  <span class="keyword">do</span> i=<span class="number">2</span>,nx1+ngrad </span><br><span class="line">     tree_nodes(itree) = (i-<span class="number">1</span>)*nye+<span class="number">1</span></span><br><span class="line">     itree = itree + <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">! 斜面ngrad行以后</span></span><br><span class="line">  <span class="keyword">do</span> i=<span class="number">1</span>,ny1-<span class="number">1</span></span><br><span class="line">    <span class="keyword">do</span> j=<span class="number">1</span>,ngrad</span><br><span class="line">       <span class="keyword">if</span> (j==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">          tree_nodes(itree) = tree_nodes(itree-<span class="number">1</span>)+nye-i+<span class="number">1</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">          tree_nodes(itree) = tree_nodes(itree-<span class="number">1</span>)+nye-i</span><br><span class="line">       <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">       itree = itree + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">! 底面第一列</span></span><br><span class="line">  tree_nodes(itree) = tree_nodes(itree-<span class="number">1</span>)+ny2+<span class="number">1</span></span><br><span class="line">  itree = itree + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">! 底面以后</span></span><br><span class="line">  <span class="keyword">do</span> i=<span class="number">2</span>,nx2</span><br><span class="line">     tree_nodes(itree) = tree_nodes(itree-<span class="number">1</span>)+ny2</span><br><span class="line">     itree = itree + <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  tree_nodes_= tree_nodes(nel_left:nel_right) <span class="comment">! 储存实际需要加荷的单元格的序号</span></span><br></pre></td></tr></table></figure><h2 id="分配荷载到节点"><a href="#分配荷载到节点" class="headerlink" title="分配荷载到节点"></a>分配荷载到节点</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">ALLOCATE</span>(weight_load(<span class="number">8</span>),tree(ndof))</span><br><span class="line">  <span class="comment">!荷载在节点上的分布权重</span></span><br><span class="line">  weight_load = (/<span class="number">0.166667</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.666667</span>,<span class="number">0.0</span>,<span class="number">0.166667</span>,<span class="number">0.0</span>,<span class="number">0.0</span>/)</span><br><span class="line"></span><br><span class="line">  <span class="comment">!计算各节点荷载大小</span></span><br><span class="line">  tree=zero</span><br><span class="line">  tree(<span class="number">6</span>)=tree_load*weight_load(<span class="number">1</span>)</span><br><span class="line">  tree(<span class="number">8</span>)=tree_load*weight_load(<span class="number">4</span>)</span><br><span class="line">  tree(<span class="number">10</span>)=tree_load*weight_load(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">! 此处注意区分(见下图)</span></span><br><span class="line">  <span class="comment">! g数组按3x 3y 2x 2y 1x 1y 4x 4y 6x 6y 7x 7y 8x 8y 5x 5y的顺序保存</span></span><br><span class="line">  <span class="comment">! weight_load按1 2 3 4 5 6 7 8来保存</span></span><br><span class="line">  <span class="comment">! 则1 4 6号节点的y方向对应g(6),g(8),g(10)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure><p><img src="/img/post/2024-04/6619e75e68eb935713aadeb2.png" title="" alt="单元节点" data-align="center"></p><h2 id="叠加荷载"><a href="#叠加荷载" class="headerlink" title="叠加荷载"></a>叠加荷载</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">itree=<span class="number">1</span> <span class="comment">! 作tree_nodes_数组的索引，将序号依次读出</span></span><br><span class="line"></span><br><span class="line">elements_2: <span class="keyword">DO</span> iel=<span class="number">1</span>,nels</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   gravlo(g)=gravlo(g)-eld*prop(<span class="number">4</span>,etype(iel))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (tree_load.ne<span class="number">.0</span><span class="number">.0</span>) <span class="keyword">then</span> <span class="comment">!荷载不为零时计算</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((iel==tree_nodes_(itree)).and.(itree.le.<span class="built_in">size</span>(tree_nodes_))) <span class="keyword">then</span> <span class="comment">!判断是否为需加荷的单元</span></span><br><span class="line"></span><br><span class="line">         gravlo(g) = gravlo(g) - tree <span class="comment">!根据自由度编号加到指定位置</span></span><br><span class="line"></span><br><span class="line">         itree=itree+<span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">   <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">DO</span> elements_2</span><br></pre></td></tr></table></figure><hr><h2 id="叠加外部水荷载"><a href="#叠加外部水荷载" class="headerlink" title="叠加外部水荷载"></a>叠加外部水荷载</h2><p>叠加外部水荷载的方式与上方叠加外部荷载的方法类似，将水的压力 $\gamma_w*h$ 叠加到相应的表面节点上</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span>(wl&gt;g_coord(<span class="number">2</span>,<span class="number">1</span>))<span class="keyword">THEN</span>  <span class="comment">! 水位淹没整个边坡</span></span><br><span class="line">      p3=(wl-g_coord(<span class="number">2</span>,<span class="number">1</span>))*gam_w</span><br><span class="line">      <span class="keyword">DO</span> i=<span class="number">1</span>,nx1</span><br><span class="line">         gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p3/d6</span><br><span class="line">         gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p3/d3</span><br><span class="line">         gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p3/d6</span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">DO</span></span><br><span class="line">      <span class="keyword">DO</span> i=nx1+<span class="number">1</span>,nx1+ny1*ngrad</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">mod</span>(i-nx1,ngrad)/=<span class="number">0</span>)<span class="keyword">then</span></span><br><span class="line">            y5=g_coord(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i)))</span><br><span class="line">            p5=(wl-y5)*gam_w</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p5/d3</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            y5=g_coord(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i)))</span><br><span class="line">            p5=(wl-y5)*gam_w</span><br><span class="line">            y7=g_coord(<span class="number">2</span>,g_num(<span class="number">7</span>,tree_nodes(i)))</span><br><span class="line">            p7=(wl-y7)*gam_w</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p5/d3</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">6</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">6</span>,tree_nodes(i))))-dx*(p5+p7)/d3</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">7</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">7</span>,tree_nodes(i))))-dx*p7/d6</span><br><span class="line">         <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">DO</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">IF</span>(ny2&gt;<span class="number">0</span>)<span class="keyword">THEN</span> <span class="comment">! 如果有破角台阶</span></span><br><span class="line">         p3=(wl-g_coord(<span class="number">2</span>,nn-<span class="number">2</span>*ny2))*gam_w <span class="comment">!p3==p5</span></span><br><span class="line">         <span class="keyword">DO</span> i=nx1+ny1*ngrad+<span class="number">1</span>,nx1+ny1*ngrad+nx2</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p3/d6</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p3/d3</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p3/d6</span><br><span class="line">         <span class="keyword">END</span> <span class="keyword">DO</span></span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">   <span class="keyword">ELSE</span> <span class="keyword">IF</span>(wl&gt;g_coord(<span class="number">2</span>,nn-<span class="number">2</span>*ny2))<span class="keyword">THEN</span> <span class="comment">! 水面在斜面位置(低于坡顶,高于坡脚)</span></span><br><span class="line">      nw=<span class="built_in">int</span>((-wl)/dx)</span><br><span class="line">      <span class="keyword">do</span> i=nx1+nw*ngrad+ngrad,nx1+ny1*ngrad</span><br><span class="line">         y5=g_coord(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i)))</span><br><span class="line">         y7=g_coord(<span class="number">2</span>,g_num(<span class="number">7</span>,tree_nodes(i)))</span><br><span class="line">         p5=(wl-y5)*gam_w</span><br><span class="line">         p7=(wl-y7)*gam_w</span><br><span class="line">         <span class="keyword">if</span>(i==nx1+nw*ngrad+ngrad)<span class="keyword">then</span> <span class="comment">! 如果水面恰好穿过某行单元格</span></span><br><span class="line">            cx=y5-wl</span><br><span class="line">            cy=cx</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i))))           &amp;</span><br><span class="line">               +p7*cy*(cy**<span class="number">2</span>-two*cy*dx+dx**<span class="number">2</span>)/(d6*dx**<span class="number">2</span>)</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">6</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">6</span>,tree_nodes(i))))           &amp;</span><br><span class="line">               -p7*(cy**<span class="number">3</span>-cy**<span class="number">2</span>*dx-cy*dx**<span class="number">2</span>+dx**<span class="number">3</span>)/(d3*dx**<span class="number">2</span>)</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">7</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">7</span>,tree_nodes(i))))           &amp;</span><br><span class="line">               -p7*(dx**<span class="number">3</span>-cy**<span class="number">3</span>)/(d6*dx*dx)</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">mod</span>(i-nx1,ngrad)/=<span class="number">0</span>)<span class="keyword">then</span> <span class="comment">! 方格斜面台阶内部(仅有上表面接触水)</span></span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p5/d3</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">         <span class="keyword">else</span> <span class="comment">! 方格斜面台阶最外部的单元格(上表面和右表面接触水)</span></span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p5/d3</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p5/d6</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">6</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">6</span>,tree_nodes(i))))-dx*(p5+p7)/d3</span><br><span class="line">            gravlo(nf(<span class="number">1</span>,g_num(<span class="number">7</span>,tree_nodes(i))))=gravlo(nf(<span class="number">1</span>,g_num(<span class="number">7</span>,tree_nodes(i))))-dx*p7/d6</span><br><span class="line">         <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">DO</span></span><br><span class="line">      <span class="keyword">IF</span>(ny2&gt;<span class="number">0</span>)<span class="keyword">THEN</span> </span><br><span class="line">         p3=(wl-g_coord(<span class="number">2</span>,nn-<span class="number">2</span>*ny2))*gam_w</span><br><span class="line">         <span class="keyword">DO</span> i=nx1+ny1*ngrad+<span class="number">1</span>,nx1+ny1*ngrad+nx2</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">3</span>,tree_nodes(i))))-dx*p3/d6</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">4</span>,tree_nodes(i))))-dx*two*p3/d3</span><br><span class="line">            gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))=gravlo(nf(<span class="number">2</span>,g_num(<span class="number">5</span>,tree_nodes(i))))-dx*p3/d6</span><br><span class="line">         <span class="keyword">END</span> <span class="keyword">DO</span></span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">   <span class="keyword">END</span> <span class="keyword">IF</span></span><br></pre></td></tr></table></figure><h3 id="叠加孔压"><a href="#叠加孔压" class="headerlink" title="叠加孔压"></a>叠加孔压</h3><p>根据Vanapalli公式, 使用体积含水率、孔压等参数计算出基质吸力项, 叠加到正应力上</p><p><img src="/img/post/2024-04/17143599364091714359936244.png" alt="17143599364091714359936244png"></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">elements_3: <span class="keyword">DO</span> iel=<span class="number">1</span>,nels</span><br><span class="line">            bload=zero</span><br><span class="line">            phi=prop(<span class="number">1</span>,iel)</span><br><span class="line">            tnph=<span class="built_in">TAN</span>(phi*pi/d180)</span><br><span class="line">            phif=<span class="built_in">ATAN</span>(tnph/srf(iy))*d180/pi</span><br><span class="line">            psi=prop(<span class="number">3</span>,iel)</span><br><span class="line">            tnps=<span class="built_in">TAN</span>(psi*pi/d180)</span><br><span class="line">            psif=<span class="built_in">ATAN</span>(tnps/srf(iy))*d180/pi</span><br><span class="line">            cf=prop(<span class="number">2</span>,iel)/srf(iy)</span><br><span class="line">            e=prop(<span class="number">5</span>,iel)</span><br><span class="line">            v=prop(<span class="number">6</span>,iel)</span><br><span class="line">            <span class="keyword">CALL</span> deemat(dee,e,v)</span><br><span class="line">            num=g_num(:,iel)</span><br><span class="line">            coord=<span class="built_in">TRANSPOSE</span>(g_coord(:,num))</span><br><span class="line">            <span class="keyword">do</span> i=<span class="number">1</span>,nod</span><br><span class="line">               <span class="keyword">call</span> Vanapalli(i,iel,nprops,kapa,prop,theta_w,suc_sig,n_inpore) <span class="comment">! 计算基质吸力项</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">            g=g_g(:,iel)</span><br><span class="line">            eld=loads(g)</span><br><span class="line">            gauss_pts_2: <span class="keyword">DO</span> i=<span class="number">1</span>,nip</span><br><span class="line">               <span class="keyword">call</span> shape_fun(fun,points,i)</span><br><span class="line">               pore(iel,i)=<span class="built_in">dot_product</span>(fun,suc_sig)</span><br><span class="line">               <span class="keyword">CALL</span> bee8(bee,coord,points(i,<span class="number">1</span>),points(i,<span class="number">2</span>),det)</span><br><span class="line">               eps=<span class="built_in">MATMUL</span>(bee,eld)</span><br><span class="line">               eps=eps-evpt(:,i,iel)</span><br><span class="line">               sigma=<span class="built_in">MATMUL</span>(dee,eps)</span><br><span class="line">               sigma(<span class="number">1</span>)=sigma(<span class="number">1</span>)-pore(iel,i) <span class="comment">! 此处124为正应力项, 3为剪应力项</span></span><br><span class="line">               sigma(<span class="number">2</span>)=sigma(<span class="number">2</span>)-pore(iel,i)</span><br><span class="line">               sigma(<span class="number">4</span>)=sigma(<span class="number">4</span>)-pore(iel,i)</span><br><span class="line">               <span class="keyword">CALL</span> invar(sigma,sigm,dsbar,lode_theta)</span><br><span class="line">               <span class="comment">!-----------------------check whether yield is violated-------------------</span></span><br><span class="line">               <span class="keyword">CALL</span> mocouf(phif,cf,sigm,dsbar,lode_theta,f)</span><br><span class="line">               <span class="keyword">IF</span>(f&gt;fmax)fmax=f</span><br><span class="line">               <span class="keyword">IF</span>(converged.OR.iters==limit)<span class="keyword">THEN</span></span><br><span class="line">                  sigma(<span class="number">1</span>)=sigma(<span class="number">1</span>)+pore(iel,i)</span><br><span class="line">                  sigma(<span class="number">2</span>)=sigma(<span class="number">2</span>)+pore(iel,i)</span><br><span class="line">                  sigma(<span class="number">4</span>)=sigma(<span class="number">4</span>)+pore(iel,i)</span><br><span class="line">                  devp=sigma</span><br><span class="line">               <span class="keyword">ELSE</span></span><br><span class="line">                  <span class="keyword">IF</span>(f&gt;=zero.OR.(converged.OR.iters==limit))<span class="keyword">THEN</span></span><br><span class="line">                     <span class="keyword">CALL</span> mocouq(psif,dsbar,lode_theta,dq1,dq2,dq3)</span><br><span class="line">                     <span class="keyword">CALL</span> formm(sigma,m1,m2,m3)</span><br><span class="line">                     flow=f*(m1*dq1+m2*dq2+m3*dq3)</span><br><span class="line">                     erate=<span class="built_in">MATMUL</span>(flow,sigma)</span><br><span class="line">                     evp=erate*dt</span><br><span class="line">                     evpt(:,i,iel)=evpt(:,i,iel)+evp</span><br><span class="line">                     devp=<span class="built_in">MATMUL</span>(dee,evp)</span><br><span class="line">                  <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">               <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">               <span class="keyword">IF</span>(f&gt;=zero)<span class="keyword">THEN</span></span><br><span class="line">                  eload=<span class="built_in">MATMUL</span>(devp,bee)</span><br><span class="line">                  bload=bload+eload*det*weights(i)</span><br><span class="line">               <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">            <span class="keyword">END</span> <span class="keyword">DO</span> gauss_pts_2</span><br><span class="line">            <span class="comment">!-----------------------compute the total bodyloads vector----------------</span></span><br><span class="line">            bdylds(g)=bdylds(g)+bload</span><br><span class="line">            bdylds(<span class="number">0</span>)=zero</span><br><span class="line">         <span class="keyword">END</span> <span class="keyword">DO</span> elements_3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程及说明 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 边坡稳定性 </tag>
            
            <tag> 非饱和土 </tag>
            
            <tag> 方形网格 </tag>
            
            <tag> Fortran </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可靠度分析程序说明文件</title>
      <link href="/2024/04/20/2024-04-20-reliability-MC/"/>
      <url>/2024/04/20/2024-04-20-reliability-MC/</url>
      
        <content type="html"><![CDATA[<h1 id="Slope-Monte-Carlo"><a href="#Slope-Monte-Carlo" class="headerlink" title="Slope_Monte_Carlo"></a>Slope_Monte_Carlo</h1><p>本程序是基于有限元的边坡可靠度分析程序，改进自<a href="https://inside.mines.edu/~vgriffit">Griffith教授</a> 的非饱和黄土边坡稳定性计算程序</p><p>本程序使用强度折减法计算稳定系数，使用Monte-Carlo法计算失效概率；</p><p>将计算作业量，分成<strong>线程数量</strong>的段数，将作业量平均分配给每一个线程；</p><p><strong>本程序使用MPI实现并行运算</strong></p><p><strong>程序文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slope_new/Subroutine.py</span><br><span class="line">slope_new/slope2.f90</span><br></pre></td></tr></table></figure><p><strong>示例数据文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exmaple/1.dat</span><br><span class="line">exmaple/1_c.txt</span><br><span class="line">exmaple/1_phi.txt</span><br><span class="line">example/1_gamma.txt !未给出</span><br><span class="line">exmaple/1_mstd.txt</span><br><span class="line">exmaple/1_grid.txt</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p><strong>结果文件</strong> 未给出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1_fs.res</span><br><span class="line">1_fail.res</span><br></pre></td></tr></table></figure><h2 id="前置安装教程"><a href="#前置安装教程" class="headerlink" title="前置安装教程"></a>前置安装教程</h2><p>1.Fortran程序前置安装：<a href="https://github.com/sourceryinstitute/OpenCoarrays">OpenCoarrays</a></p><p>以Ubuntu22.04安装Open-coarrays 2.9.2为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cmake gfortran</span><br><span class="line">wget https://github.com/sourceryinstitute/OpenCoarrays/archive/refs/tags/2.9.2.tar.gz</span><br><span class="line">tar xf 2.9.2.tar.gz</span><br><span class="line">cd OpenCoarrays-2.9.2</span><br><span class="line">makedir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>！若<a href="https://github.com/sourceryinstitute/OpenCoarrays/archive/refs/tags/2.9.2.tar.gz">OpenCoarrays2.9.2</a> 下载失败可手动下载并上传到<code>/home/username/</code>再解压编译安装</p><p>2.可选安装—后台运行<a href="https://www.gnu.org/software/screen/">Screen</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">安装：</span><br><span class="line">sudo apt-get install screen</span><br><span class="line">列出全部会话：</span><br><span class="line">screen -ls</span><br><span class="line">新建：</span><br><span class="line">screen</span><br><span class="line">screen -S name</span><br><span class="line">删除：</span><br><span class="line">screen -S name -X quit ! 或在窗口内使用快捷键ctrl + D</span><br><span class="line">放置后台：</span><br><span class="line">使用快捷键ctrl+A再ctrl+D </span><br><span class="line">返回窗口：</span><br><span class="line">screen -R</span><br><span class="line">screen -r name </span><br></pre></td></tr></table></figure><p>3.Python程序须安装<a href="https://www.python.org/downloads/">Python3.x</a> ！无须安装在服务器中，仅做数据处理工作，在本地使用即可</p><p>程序运行依赖<code>numpy</code>库，可使用pip安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure><h2 id="程序使用教程"><a href="#程序使用教程" class="headerlink" title="程序使用教程"></a>程序使用教程</h2><p>1.运行<a href="https://github.com/liudh56/Slope/blob/main/Slope_new/Subroutine.py">Subroutine.py</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 代码所在目录</span><br><span class="line">python ./Subroutine.py</span><br></pre></td></tr></table></figure><p> 根据提示操作即可<a href="https://github.com/liudh56/Slope/tree/main/example">使用教程</a></p><p>2.将生成文件与<code>slope2.f90</code>放在同一文件夹内（本文件夹即要上传的文件夹）</p><p>文件包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx.dat</span><br><span class="line">xxx_c.txt xxx_phi.txt xxx_gamma.txt #具体文件数量与设为随机的参数有关</span><br></pre></td></tr></table></figure><p><a href="https://github.com/liudh56/Slope/blob/main/example/1.dat">dat文件详细</a> </p><p>其他python程序使用文件（无需上传）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx_mstd.txt</span><br><span class="line">xxx_grid.txt</span><br></pre></td></tr></table></figure><h3 id="Fortran程序—在服务器中运行"><a href="#Fortran程序—在服务器中运行" class="headerlink" title="Fortran程序—在服务器中运行"></a>Fortran程序—在服务器中运行</h3><p>1.将上文中的文件夹上传至服务器并打开目录</p><p>2.编译命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caf slope2.f90 -o slope</span><br></pre></td></tr></table></figure><p>3.运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cafrun -n 4 slope</span><br><span class="line">！ 4代表线程数，可更改，若线程数报错改用下面的命令</span><br></pre></td></tr></table></figure><p> 或者：使用下面命令适用于多主机的情况，根据主机实际情况分配线程数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mpirun --host host1:40 host2:40 -n 80 filename</span><br><span class="line"></span><br><span class="line">mpirun --host hostfile -n 80 filename !使用该命令须先创建hostfile文件</span><br></pre></td></tr></table></figure><p>4.保存结果文件到本地与Subroutine.py文件放置在同一文件内</p><p>运行Subroutine.py程序并选择功能3计算失效概率，结果保存在<code>xxx_fail.res</code>文件内。</p><h1 id="Subroutine-py程序使用方式"><a href="#Subroutine-py程序使用方式" class="headerlink" title="Subroutine.py程序使用方式"></a>Subroutine.py程序使用方式</h1><h2 id="1-输入项目名称xxx。"><a href="#1-输入项目名称xxx。" class="headerlink" title="1.输入项目名称xxx。"></a>1.输入项目名称xxx。</h2><h2 id="2-选择功能（输入序号）。"><a href="#2-选择功能（输入序号）。" class="headerlink" title="2.选择功能（输入序号）。"></a>2.选择功能（输入序号）。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. （首次使用）引导填写并重新生成xxx.dat和xxx_mstd.txt文件</span><br><span class="line">   </span><br><span class="line">2. 根据xxx_mstd.txt生成phi、c和gamma的值</span><br><span class="line">   </span><br><span class="line">3. 计算失效概率,并生成xxx_fail.res文件,储存失效概率</span><br><span class="line">   </span><br><span class="line">4. 生成xxx_grid.txt文件,储存网格点的序号(多层土的情况使用)</span><br><span class="line">   </span><br><span class="line">5. 根据xxx_mstd.txt重新生成某参数值</span><br><span class="line"></span><br><span class="line">0. 退出程序(默认)</span><br></pre></td></tr></table></figure><h2 id="功能使用教程"><a href="#功能使用教程" class="headerlink" title="功能使用教程"></a>功能使用教程</h2><p>1.第一次使用选择<code>1</code>填写<code>xxx.dat</code>和<code>xxx_mstd.txt</code>文件（也可直接修改示例文件来使用）</p><p><strong>建议先查看示例文件</strong></p><p><strong>若填写过程中出现填写错误，可继续填写，等待填写完成再从生成文件内修改错误</strong></p><p><strong>功能4，可协助填写<code>xxx.dat</code>文件，后文介绍</strong></p><p>2.再选择<code>2</code>根据提示进行选择（以内摩擦角和粘聚力为随机参数为例）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请输入模拟次数:10000</span><br><span class="line">请输入参数类型(10:内摩擦角,20:粘聚力,30:重度) 10</span><br><span class="line">请输入分布类型(0:定值（默认）,1:正态分布,2:对数正态分布) 1</span><br><span class="line">已生成xxx_c.txt文件!</span><br><span class="line">请输入参数类型(10:内摩擦角,20:粘聚力,30:重度) 20</span><br><span class="line">请输入分布类型(0:定值（默认）,1:正态分布,2:对数正态分布): 1</span><br><span class="line">已生成xxx_phi.txt文件!</span><br></pre></td></tr></table></figure><p>3.文件上传计算</p><p>4.计算完成后，将结果文件<code>xxx_fs.res</code>放置与本程序在同一文件夹内，运行程序选择<code>3</code>，结果保存在<code>xxx_fail.res</code>文件</p><p><strong>功能4介绍（单层土不需要使用）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">！根据自己划分的每层土的单元格数（不是高度）填写即可，注意与ny1和ny2区分</span><br><span class="line">请输入第1层土的厚度(竖向单元格数): 16</span><br><span class="line">请输入第2层土的厚度(竖向单元格数): 5</span><br><span class="line">已生成xxx_grid.txt文件!</span><br></pre></td></tr></table></figure><p>xxx_grid.txt的内容复制到以下位置使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;Choose whether to set it as a random variable (the order is: phi c gamma,1 is random)&quot;</span><br><span class="line">1 1 0</span><br><span class="line"></span><br><span class="line">&quot;Property group assigned to each element (etype, data not needed if np_types=1)&quot;</span><br><span class="line">（--------此位置--------）</span><br><span class="line"></span><br><span class="line">&quot;Pseudo-static analysis: Horizontal acceleration factor (k_h)&quot;</span><br><span class="line">0.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程及说明 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 边坡稳定性 </tag>
            
            <tag> Fortran </tag>
            
            <tag> 失效概率 </tag>
            
            <tag> Monte-Carlo </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
