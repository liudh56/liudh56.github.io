[{"title":"论文研读(二)","url":"/2025/11/2b57c8fc/","content":"\n# 考虑摩擦及固态到液态相变的海底颗粒流两相两点MPM建模\n\n## 摘要\n\n> 精确建模海底颗粒流对滑坡灾害评估至关重要. 现有的数值方法虽关注海底滑坡的大变形特征和流体‐土体耦合, 但通常忽略了土壤的非线性固‐液相变以及对摩擦边界的合理处理. 为弥补这些不足, 本研究提出一种新型两相两点物质点法(MPM)模型, 可显式解析颗粒固‐液相变及摩擦边界. 开发的MPM框架采用两组拉格朗日物质点, 严格耦合土壤和水, 有效捕捉复杂的土‐水相互作用. 首次在两相两点MPM中引入弹塑性‐μ(I)相变模型, 以考虑颗粒从类固态到类流态的相变过程. 此外, 将摩擦接触算法引入MPM以表示摩擦边界. 为验证所提方法在模拟海底颗粒流方面的有效性, 分析了三个基准案例, 包括一个具有解析解的一维固结问题和两个实验性水下滑坡案例. 模拟结果与解析解及实验结果高度一致, 验证了模型的有效性. 特别地, 本研究对比了弹塑性‐μ(I)相变模型与纯固态弹塑性模型, 并利用提出的MPM模型评估了摩擦边界对海底滑坡的影响. 数值结果表明: (i)纯弹塑性模型相较于弹塑性‐μ(I)模型倾向于高估滑坡滑动距离; (ii)增加基底摩擦不仅显著减少土体滑动距离, 还能抑制流体涡旋, 从而削弱土‐水相互作用系统中的波浪.\n\n## 研究背景\n\n海底滑坡是海洋环境中最为复杂和最具破坏性的地质灾害之一. 历史教训惨痛: 1929年格兰德滩滑坡切断了600公里外的通信电缆; 1998年巴布亚新几内亚滑坡引发15米高海啸, 吞噬2200多条生命. 准确预测海底滑坡的动态行为, 对保障海洋工程设施安全和沿海社区防护至关重要.\n\n<img src=\"2025-11-10-mpm-bj2/image-20251110154230001.png\" alt=\"image-20251110154230001\" style=\"zoom: 33%;\" />\n\n## 存在的问题\n\n**问题一：固-液相变行为缺失**\n\n海底滑坡经历典型的“启动—运移—沉积”三阶段（图1）。在启动阶段，不稳定斜坡上的颗粒材料从固态转变为流体态；运移阶段，失效的颗粒体以流体态大规模运移；沉积阶段，材料重新恢复固态。这一复杂的相变过程在传统数值模型中被完全忽略——通常只采用单一的纯弹塑性模型或纯流体模型，无法捕捉材料状态的关键转变。\n\n**问题二：边界条件过度简化**\n\n多数模型将边界条件简化为无摩擦或完全黏着，忽略了实际滑坡体与海底之间的复杂摩擦作用，导致预测结果偏离实际。\n\n<img src=\"2025-11-10-mpm-bj2/image-20251110171725768.png\" alt=\"image-20251110171725768\" style=\"zoom:50%;\" />\n\n## 创新解决方案：考虑摩擦边界和相变的两相两点MPM框架\n\n文章研究创新性地提出了考虑摩擦边界和相变的两相两点物质点法（MPM）模型，这一框架具有三大核心创新：\n\n**创新一：双拉格朗日物质点系统**\n\n采用两套独立的物质点分别代表土体骨架和孔隙水，精确捕捉复杂的土-水相互作用机制（图2）。\n\n<img src=\"2025-11-10-mpm-bj2/image-20251110155524759.png\" alt=\"image-20251110155524759\" style=\"zoom:33%;\" />\n\n**创新二：弹塑性-μ(I)相变本构模型**\n\n首次将率无关的弹塑性应力（表征固态行为）和率相关的黏性应力（表征流体态行为）通过叠加方式结合，实现从固态到流体态的无缝过渡。该模型通过等效塑性应变和等效剪切粘度两个关键变量，清晰揭示材料在不同阶段的力学响应。\n\n**创新三：摩擦接触算法**\n\n引入基于库仑摩擦的接触算法，真实反映滑坡体与底床之间的摩擦效应。\n\n## 框架理论\n\n### 1. 控制方程\n\n固体骨架和液相的质量守恒方程表示为:\n$$\n\\frac{d(n_s\\rho_s)}{dt}=-\\nabla\\cdot(n_s\\rho_s\\mathbf{v}_s) \\tag{1}\n$$\n$$\n\\frac{d(n_w\\rho_w)}{dt}=-\\nabla\\cdot(n_w\\rho_w\\mathbf{v}_w) \\tag{2}\n$$\n\n其中 $\\rho_s$ 和 $\\rho_w$ 分别为固体骨架和水的密度; $v_s$ 和 $v_w$分别表示固体骨架和水的速度; $n_s$为固体骨架的体积浓度; $n_w$为水的体积浓度, 也称为孔隙率。注意 $n_s+n_w=1$.\n\n固体骨架和液相的动量守恒方程表示为:\n$$\nn_s \\rho_s \\dot{v}_s = \\nabla \\cdot \\bar{\\sigma}_s + n_s \\rho_s b + f^i \\tag{3}\n$$\n\n$$\nn_w \\rho_w \\dot{v}_w = \\nabla \\cdot \\bar{\\sigma}_w + \\nabla \\cdot s_w + n_w \\rho_w b - f^i \\tag{4}\n$$\n\n\n其中$\\bar{\\sigma}_{s}$和$\\bar{\\sigma}_w$分别为体积平均的固相和液相应力, 分别表示为$\\bar{\\sigma}_s=\\sigma'-(1-n_w)p_wI$和$\\bar{\\sigma}_w=-n_w p_wI$; $\\sigma'$为太沙基有效应力; $s_w$为液相的粘性应力; $b$表示体力; $f^i$表示固‐流相互作用力, 表达式见下式：\n$$\nf^i=\\frac{n_w\\rho_wg}k(v_w-v_s)+\\beta n_w^2\\rho_w\\|v_w-v_s\\|(v_w-v_s)+\\mathbf{\\sigma}_w\\nabla n \\tag{5}\n$$\n其中, k是水力传导率(m/s)，表示为$k = \\frac{\\kappa \\rho_w g}{\\mu_w}$, 且$\\kappa = \\frac{d^2 n_w^2}{180(1 - n_w)^2}$其中$\\kappa$是绝对渗透率(m³); $ \\mu_w $ 表示水的粘度，$ d $ 表示土粒的直径；$\\beta$ 是描述拖曳力与速度之间非线性关系的系数。\n\n联立式(3)和式(4)得混合物方程：\n$$\nn_w \\rho_w \\dot{v}_w + n_s \\rho_s \\dot{v}_s = \\nabla \\cdot \\sigma + \\rho_m b \\tag{6}\n$$\n其中$\\sigma$是柯西总应力张量，表示为$\\sigma = \\sigma' - p_w I$，这符合有效应力原理；$\\rho_m$ 是混合物密度，表示为 $\\rho_m = n_s \\rho_s + n_w \\rho_w$。\n\n为了求解方程(1)-(6)，需要建立某些假设来简化这些方程。\n\n(i) 固体骨架不可压缩，且标量场（密度和孔隙率）的梯度被忽略，即 $\\frac{d\\rho_s}{dt} = \\nabla \\rho_s = \\nabla n_s = 0$。因此，固相的质量守恒可以重写为：\n$$\n\\frac{dn_s}{dt} = -n_s \\nabla \\cdot (\\mathbf{v}_s) \\tag{7}\n$$\n(ii) 流体（水）为弱可压缩且标量场（密度）的梯度被忽略，即 $\\frac{d\\rho_w}{dt} \\neq 0$，$\\nabla \\rho_w = 0$。因此，流相的质量守恒可以重写为：\n$$\n\\frac{1}{\\rho_w} \\frac{d\\rho_w}{dt} = -\\frac{1}{n_w} [n_s \\nabla \\cdot (\\mathbf{v}_s) + n_w \\nabla \\cdot (\\mathbf{v}_w)] \\tag{8}\n$$\n(iii) 固-流相间相互作用力（方程(5)）被简化为：\n$$\nf^i = \\frac{n_w \\rho_w g}{k} (\\mathbf{v}_w - \\mathbf{v}_s) \\tag{9}\n$$\n此外，必须提出合适的固相和流相本构模型来闭合上述方程组。固体骨架使用第2.4小节详述的固-流相变本构模型进行模拟。水被视为弱可压缩材料，其本构模型可通过 $\\frac{d\\rho_w}{dt} = \\frac{\\rho_w}{K_w} \\frac{dp_w}{dt}$ 表达。将此方程与方程(8)结合，水压力则由下式给出：\n$$\n\\frac{dp_w}{dt} = -\\frac{K_w}{n_w} [n_s \\nabla \\cdot (\\mathbf{v}_s) + n_w \\nabla \\cdot (\\mathbf{v}_w)] \\tag{10}\n$$\n其中 $K_w$ 是水的弹性模量。\n\n对于自由水条件，压力简化为：\n$$\n\\frac{dp_w}{dt} = -K_w \\nabla \\cdot (\\mathbf{v}_w) \\tag{11}\n$$\n\n### 2. 摩擦接触算法\n\n基于库仑摩擦的接触算法（由Nguyen等人于2023年提出）被集成到物质点法(MPM)框架中，以考虑摩擦边界的影响。该算法中切向速度由库仑摩擦定律控制，具体步骤如下：\n\n(i) 确定切向和法向速度：\n$$\nv_{I}^{\\text{nor},(k)} = \\mathbf{n} \\left( v_{I}^{k} \\cdot \\mathbf{n} \\right) \\tag{34}\n$$\n\n\n$$\nv_{I}^{\\text{tan},(k)} = v_{I}^{k} - v_{I}^{\\text{nor},(k)} = v_{I}^{k} - \\mathbf{n} \\left( v_{I}^{k} \\cdot \\mathbf{n} \\right) \\tag{35}\n$$\n\n其中$n$为法向量；$v_I^k$为边界处的速度；$v_I^{nor,(k)}$和$v_I^{tan,(k)}$分别为法向速度和切向速度。基于公式(34)和(35)，可以计算出切向和法向速度的大小$\\left| v_I^{nor,(k)} \\right|$和$\\left| v_I^{tan,(k)} \\right|$.\n\n滑动平面的法向量通过平面上的三个点计算得出，计算公式如下：\n$$\ne_n = \\frac{\\left( x_j - x_i \\right) \\times \\left( x_k - x_i \\right) }{\\left\\| \\left( x_j - x_i \\right) \\times \\left( x_k - x_i \\right) \\right\\| } \\tag{36}\n$$\n其中$x_i$、$x_j$和$x_k$分别为滑动平面中节点$i$、$j$和$k$的节点坐标。\n\n(ii) 通过切向和法向速度确定切向和法向力：\n$$\nf_I^{nor,(k)} = v_I^{nor,(k)} \\frac{m_I^k}{dt} \\tag{37}\n$$\n\n$$\nf_I^{tan,(k)} = v_I^{tan,(k)} \\frac{m_I^k}{dt} \\tag{38}\n$$\n\n其中$f_I^{nor,(k)}$和$f_I^{tan,(k)}$分别为法向力和切向力。\n\n(iii) 确定摩擦力$f_{I}^{fti,(k)}$\n\n当切向力的大小较小时，施加的摩擦力会完全抵抗切向运动，从而有效地将切向速度设为零。当切向力超过某个阈值(即$\\mu_{fit} \\left\\| f_I^{nor,(k)}\\right\\|$)时，摩擦力将与法向力的大小成正比，并沿与切向力相反的方向作用。\n$$\nf_I^{fti,(k)} = -\\frac{g_I^{tan,(k)} }{\\left\\| f_I^{tan,(k)} \\right\\| } min\\left( \\mu_{fit} \\left\\| f_I^{nor,(k)} \\right\\|, \\left\\| f_I^{tan,(k)} \\right\\| \\right) \\tag{39}\n$$\n\n其中 $\\mu_{fit}$ 是基底摩擦参数；$\\left\\| f_I^{nor,(k)} \\right\\|$ 和 $\\left\\| f_I^{tan,(k)} \\right\\|$ 分别表示法向力和切向力的大小。\n\n(iv) 通过摩擦力修正切向速度(见公式(40))。在修正边界网格处的切向速度后，直接将法向速度设为零，以防止颗粒穿透边界。\n$$\n\\begin{cases}\n若 : \\left\\| v_I^{tan,(k)} \\right\\| = 0 : \\hat{v}_I^{tan,(k)} = 0 \\\\\n若 : \\left\\| v_I^{tan,(k)} \\right\\| \\neq 0 : \\hat{v}_I^{tan,(k)} = v_I^{tan,(k)} + \\frac{f_I^{fti,(k)} }{m_I^k} dt\n\\end{cases} \\tag{40}\n$$\n\n其中 $\\hat{v}_I^{tan,(k)}$ 是修正后的切向速度。\n\n基底摩擦参数$\\mu_{fit}$主要受边界条件影响，并且可能在不同的天然滑坡场地和实验室测试案例中有所变化。对于实验室实验，$\\mu_{fit}$理想情况下应通过标准的基底摩擦试验确定（参见Kelenenová等人, 2020；Lin等人, 2023）。从物理意义上讲，$\\mu_{fit}$的取值范围是0到1，文献中的值通常在0.2到0.8之间（参见Yu等人, 2023）。\n\n当无法直接测量时，可以通过以下过程来标定$\\mu_{fit}$：(i) 首先确定土壤本构参数；然后 (ii) 在一系列$\\mu_{fit}$取值下，将实验得到的颗粒流结果与 MPM 模拟结果进行比较，以确定最佳参数。需要注意的是，准确确定$\\mu_{fit}$仍然具有挑战性，值得在未来研究中进一步深入探讨。\n\n### 3. 相变本构模型\n\n颗粒材料表现出复杂的非线性行为，其特征是在类固体和类流体状态之间转变。为捕捉这种响应，我们在两相两点物质点法(MPM)框架中引入了弹塑性-μ(I)相变本构模型。该模型桥接了土壤力学中类固体的弹塑性应力和流体力学中类流体的粘性应力，能够无缝表征颗粒介质在破坏启动、流态化传播和沉积阶段的力学行为。\n\n弹塑性-μ(I)相变模型采用叠加方法来描述相变机制，这与经典的统一摩擦-碰撞框架（Johnson and Jackson, 1987; Johnson et al., 1990）保持一致。在该框架中，颗粒介质的应力被分为两个部分：表示类固体行为的率无关弹塑性部分，以及描述类流体行为的率相关粘性应力。该模型通过弹塑性和粘性应力的动态演化来表征相变过程：在低应变率下，弹塑性应力占主导，表明材料处于类固体状态，此时碰撞应力可忽略不计；在高应变率下，粘性应力占优势，表明材料处于类流体状态，而摩擦应力则保持可忽略不计。\n$$\n\\sigma' = \\sigma_{sp} + \\sigma_v \\tag{41}\n$$\n\n其中$\\sigma'$为土骨架的总有效应力张量；$\\sigma_{sp}$为弹塑性应力；$\\sigma_v$为粘性应力。\n\n弹塑性-μ(I)模型已在我们的前期工作中进行了讨论和验证（Feng et al., ）。为清晰起见，详细的模型信息见附录A和B。关键输入参数的总结在表2中给出。\n\n<img src=\"2025-11-10-mpm-bj2/image-20251110171855901.png\" alt=\"image-20251110171855901\" style=\"zoom:50%;\" />\n\n\n\n## 模型验证与关键发现\n\n研究通过三个典型算例系统验证了模型的可靠性：\n\n**验证一：一维固结问题**\n\n<img src=\"2025-11-10-mpm-bj2/image-20251110171914077.png\" alt=\"image-20251110171914077\" style=\"zoom:50%;\" />\n\nMPM计算结果与Terzaghi经典解析解高度吻合（图4），证明了模型在处理土-水耦合问题中的基本可靠性。\n\n<img src=\"2025-11-10-mpm-bj2/image-20251110172508203.png\" alt=\"image-20251110172508203\" style=\"zoom:33%;\" />\n\n**验证二：Grilli水下滑坡实验**\n\n<img src=\"2025-11-10-mpm-bj2/image-20251110172627760.png\" alt=\"image-20251110172627760\" style=\"zoom:33%;\" />\n\n<img src=\"2025-11-10-mpm-bj2/image-20251110172705742.png\" alt=\"image-20251110172705742\" style=\"zoom:33%;\" />\n\n模拟结果与实验观测高度一致（图7、图9）。特别值得关注的是：\n\n- 相变模型准确再现了滑坡体形态演变全过程\n\n- 纯弹塑性模型会**系统性高估滑坡运移距离**（图11、表4），因其忽略了黏性阻力\n\n- 成功捕捉了由土体运动诱导的流体涡旋生成和传播过程（图10）\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110173230943.png\" alt=\"image-20251110173230943\" style=\"zoom: 50%;\" />\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110172734752.png\" alt=\"image-20251110172734752\" style=\"zoom:33%;\" />\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110172949868.png\" alt=\"image-20251110172949868\" style=\"zoom:33%;\" />\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110173023122.png\" alt=\"image-20251110173023122\" style=\"zoom:33%;\" />\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110173051408.png\" alt=\"image-20251110173051408\" style=\"zoom:33%;\" />\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110173208040.png\" alt=\"image-20251110173208040\" style=\"zoom:33%;\" />\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110173248112.png\" alt=\"image-20251110173248112\" style=\"zoom: 50%;\" />\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110173436926.png\" alt=\"image-20251110173436926\" style=\"zoom:33%;\" />\n\n**验证三：Rzadkiewicz海底滑坡实验**\n\n<img src=\"2025-11-10-mpm-bj2/image-20251110173405125.png\" alt=\"image-20251110173405125\" style=\"zoom:50%;\" />\n\n进一步考察摩擦边界的影响，发现：\n\n- MPM结果在土体剖面和自由水面演化方面均优于SPH和PFEM方法（图15-16、表5）\n\n- 基底摩擦系数增大显著**减少土体运移距离**，并有效**抑制流体涡旋强度**（图17-18）\n\n- 摩擦效应通过改变土-水界面动量传递，直接影响海啸波幅大小\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110173505338.png\" alt=\"image-20251110173505338\" style=\"zoom:33%;\" />\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110173527438.png\" alt=\"image-20251110173527438\" style=\"zoom:33%;\" />\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110173551843.png\" alt=\"image-20251110173551843\" style=\"zoom:33%;\" />\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110173721318.png\" alt=\"image-20251110173721318\" style=\"zoom:50%;\" />\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110173653600.png\" alt=\"image-20251110173653600\" style=\"zoom:33%;\" />\n\n  <img src=\"2025-11-10-mpm-bj2/image-20251110173741945.png\" alt=\"image-20251110173741945\" style=\"zoom:33%;\" />\n\n## 结论\n\n文章建立的新型MPM框架，首次在考虑摩擦边界的条件下，实现了对海底颗粒流从固态到流体态全过程的精准模拟。主要结论包括：\n\n(i) 总体而言，所提出的MPM模型的数值结果与实验数据的关键方面吻合良好，包括海底颗粒流过程、最终沉积形态和滑坡引发的海啸。虽然存在轻微差异，但该模型与大多数实验观察结果显示出良好的定性和定量一致性。\n\n(ii) 该模型有效捕捉了海底颗粒流过程中颗粒介质的多阶段响应，其应力状态从弹塑性应力转变为弹塑性-粘性应力，并随着材料在类固体和类流体状态之间交替而恢复为弹塑性应力。\n\n(iii) 数值结果表明，在动态的土-水系统中，颗粒介质的运动决定了流体相涡旋的方向。\n\n(iv) 与纯类固体弹塑性模型的比较表明，纯类固体弹塑性模型往往会高估海底颗粒流的流动距离，这凸显了纳入相变机制的重要性。\n\n(v) 不同基底摩擦参数的对比分析表明，较高的基底摩擦会减少颗粒介质的流动距离并抑制流体相涡旋，从而削弱波的形成。\n\n\n\n> 本文基于 Ocean Engineering 341 (2025) 论文《Two-phase two-point MPM modeling of submarine granular flows considering solid-to-fluid phase transition over frictional plane》整理.","tags":["学习笔记","两相两点","相变"],"categories":["MPM"]},{"title":"ASF-12.5m-DEM下载教程","url":"/2025/11/a648a944/","content":"\n## 准备工作\n\n- ASF账号（下载必须，免费注册）\n- 良好的网络连接\n- ArcGis\n\n## 下载教程\n\n### 1. 打开[ASF网站](https://search.asf.alaska.edu/#/?dataset=ALOS)\n\n或网址：https://search.asf.alaska.edu/#/?dataset=ALOS\n\n### 2. 右上角注册并登录账号\n\n### 3. 下载数据\n\n(1) 如果使用上面的超链接或网址进入网站，那当前的数据来源应当为ALOS PALSAR，如果不是，下拉选择该选项\n\n<img src=\"2025-11-09-asf-dem-download/image-20251109230642877.png\" alt=\"image-20251109230642877\" style=\"zoom:33%;\" />\n\n(2) 框选需要下载的范围\n\n<img src=\"2025-11-09-asf-dem-download/image-20251109231901774.png\" alt=\"image-20251109231901774\" style=\"zoom:50%;\" />\n\n(3) 筛选数据\n\n<img src=\"2025-11-09-asf-dem-download/image-20251109232034162.png\" alt=\"image-20251109232034162\" style=\"zoom:50%;\" />\n\n<img src=\"2025-11-09-asf-dem-download/image-20251109232319249.png\" alt=\"image-20251109232319249\" style=\"zoom: 50%;\" />\n\n点击搜索查找数据\n\n<img src=\"2025-11-09-asf-dem-download/image-20251109232958644.png\" alt=\"image-20251109232958644\" style=\"zoom:50%;\" />\n\n打开右上角购物车(下载列表)\n\n<img src=\"2025-11-09-asf-dem-download/image-20251109233221741.png\" alt=\"image-20251109233221741\" style=\"zoom:50%;\" />\n\n即可下载相关数据\n\n### 4. 合并数据\n\n将下载好的数据导入到ArcMap(或ArcGis Pro)中，下图为ArcGis Pro的示例(ArcMap操作相同仅界面不同)\n\n在地理处理中搜索”镶嵌至新栅格“\n\n<img src=\"2025-11-09-asf-dem-download/PixPin_2025-11-09_23-42-31.png\" alt=\"PixPin_2025-11-09_23-42-31\" style=\"zoom: 50%;\" />\n\n这样就可以把多个栅格文件合并成一个栅格文件。\n","tags":["教程及说明","DEM"],"categories":["ArcGis"]},{"title":"分水岭提取教程","url":"/2025/05/2ef32537/","content":"\n## 准备工具\n\n- Arcgis Pro\n\n- ArcMap\n\n- 完整的DEM数据（如果有缺失，需要提前补缺（填补空缺值））\n\n## 开始教程\n\n### 1. 填洼（Fill）\n\n通过填充表面栅格中的汇来移除数据中的小缺陷。\n\n地理处理工具 -> 搜索填洼 -> 输入栅格 -> 输出栅格\n\n英文：打开**ArcToolbox** ->  搜索 **Fill**\n\n<img src=\"2025-05-06-arcgis-watershed/PixPin_2025-05-06_10-47-10.png\" alt=\"PixPin_2025-05-06_10-47-10\" style=\"zoom: 67%;\" />\n\n### 2. 流向 （FLow Direction）\n\n使用 D8、多流向 (MFD) 或 D-Infinity (DINF) 方法创建从每个像元到其下坡相邻点的流向的栅格。\n\n地理处理工具 -> 搜索流向 -> 输入处理后的栅格数据 -> 输出流向栅格\n\n英文：打开**ArcToolbox** ->  搜索 **Flow Direction**\n\n<img src=\"2025-05-06-arcgis-watershed/PixPin_2025-05-06_10-58-18.png\" alt=\"PixPin_2025-05-06_10-58-18\" style=\"zoom:67%;\" />\n\n这里类型一般使用默认的D8即可，具体类型区别请查看[帮助文档](https://pro.arcgis.com/zh-cn/pro-app/3.1/tool-reference/spatial-analyst/flow-direction.htm)。\n\n### 3. 计算河流网络（计算流量（Flow Accumulation））（可选）\n\n此部计算是为了下一步更好的选点做准备。如果地形不复杂，也可直接使用D8流向栅格做参考。\n\n地理处理工具 -> 搜索流量 -> 输入流向栅格数据 -> 输出流量栅格\n\n英文：打开**ArcToolbox** ->  搜索 **Flow Accumulation**\n\n<img src=\"2025-05-06-arcgis-watershed/PixPin_2025-05-06_11-06-24.png\" alt=\"PixPin_2025-05-06_11-06-24\" style=\"zoom:67%;\" />\n\n### 4. 创建点要素文件\n\n找到目录窗口，打开到需要保存到的文件夹，右键文件夹，选择新建，选择Shapefile\n\n<img src=\"2025-05-06-arcgis-watershed/PixPin_2025-05-06_11-10-22.png\" alt=\"PixPin_2025-05-06_11-10-22\" style=\"zoom:50%;\" />\n\n<img src=\"2025-05-06-arcgis-watershed/PixPin_2025-05-06_11-15-40.png\" alt=\"PixPin_2025-05-06_11-15-40\" style=\"zoom:50%;\" />\n\n创建完成之后，找到**编辑**工具栏；选择**创建**选项。打开的窗口中选择刚刚创建的文件。\n\n<img src=\"2025-05-06-arcgis-watershed/PixPin_2025-05-06_11-18-55.png\" alt=\"PixPin_2025-05-06_11-18-55\" style=\"zoom:50%;\" />\n\n<img src=\"2025-05-06-arcgis-watershed/PixPin_2025-05-06_11-19-50.png\" alt=\"PixPin_2025-05-06_11-19-50\" style=\"zoom:50%;\" />\n\n然后，在河流的上游和下游选点（至少各一个）。不要求完全选到源头，但汇出口尽量选到。\n\n> 根据创建的河网和流向栅格创建，之后生成的效果不好就回来修改这个文件\n\n### 5. 提取分水岭（Watershed）\n\n地理处理工具 -> 搜索集水区 -> 输入流向栅格数据 -> 输入点要素文件 -> 输出集水区栅格\n\n英文：打开**ArcToolbox** ->  搜索 **Watershed**\n\n<img src=\"2025-05-06-arcgis-watershed/PixPin_2025-05-06_11-29-44.png\" alt=\"PixPin_2025-05-06_11-29-44\" style=\"zoom:50%;\" />\n\n字段默认id即可\n\n> 集水区生成与点的位置有关，它会把每一个点的上游集水区域选择上，但由于地形数据原因会导致有些连续的流域选择不上，使用多个点可尽量保证选择全部区域；\n>\n> 字段的作用是区分该点对应的集水区，这些点的id都相同，因此只会创建一个集水区；如果需要创建多个集水区，需要使用不同的id区分。\n\n反复调整点要素文件，即可得到该区域的一个集水区栅格文件。将栅格转为面（地理处理工具 -> 栅格转面）即可得到集水区的要素文件。\n\n","tags":["教程及说明","分水岭","栅格"],"categories":["ArcGis"]},{"title":"Nginx反向代理教程","url":"/2025/03/4bc19655/","content":"\n## 准备工作\n\n- Ubuntu系统\n- Nginx\n\n## 配置教程\n\n### 1.备份配置文件\n\n```bash\nsudo cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.default\n```\n\n### 2.编辑配置文件\n\n```bash\nsudo vim /etc/nginx/nginx.conf\n```\n\n找到`http{}`块中的`server{}`块，注释掉原有的`server{}`\n\n<img src=\"2025-03-08-nginx-ssl/PixPin_2025-03-08_22-13-27.png\" alt=\"PixPin_2025-03-08_22-13-27\" style=\"zoom:50%;\" />\n\n### 3.按原有配置添加新的server块\n\n#### (1) 默认的错误界面\n\n```\nserver {\n    listen 443 ssl default_server;\n    server_name _;\n\n    ssl_certificate /etc/nginx/xxx.crt;\n    ssl_certificate_key /etc/nginx/xxx.key;\n\n    return 404;\n}\n```\n\n#### (2) 主域名\n\n```\nserver {\n     listen 443 ssl;\n     server_name fireflye.top;\n     ssl_certificate /etc/nginx/xxx.crt;\n     ssl_certificate_key /etc/nginx/xxx.key;\n     ssl_session_timeout 5m;\n     ssl_protocols TLSv1.2 TLSv1.3;\n     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;\n     ssl_prefer_server_ciphers on;\n\n     location / {\n         root /home/www/website;\n         index  index.html index.htm;\n     }\n}\n```\n\n其中`root`改为自己本地的网站目录\n\n#### (3) 主域名转发\n\n```\nserver {\n        listen 80;\n        server_name fireflye.top;\n        return 301 https://$host$request_uri;\n        }\n```\n\n#### (4) 二级域名端口转发示例\n\n```\nserver {\n     listen 443 ssl;\n     server_name xxx.fireflye.top;\n     ssl_certificate /etc/nginx/xxx.crt;\n     ssl_certificate_key /etc/nginx/xxx.key;\n     ssl_session_timeout 5m;\n     ssl_protocols TLSv1.2 TLSv1.3;\n     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;\n     ssl_prefer_server_ciphers on;\n\n     location / {\n       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n       proxy_set_header X-Forwarded-Proto $scheme;\n       proxy_set_header Host $host;\n       proxy_set_header X-Real-IP $remote_addr;\n       proxy_set_header Range $http_range;\n       proxy_set_header If-Range $http_if_range;\n       proxy_redirect off;\n       proxy_pass https://127.0.0.1:xxx;\n       client_max_body_size 20000m;\n       }\n}\n server {\n        listen 80;\n        server_name xxx.fireflye.top;\n        return 301 https://$host$request_uri;\n\t\t\t\t}\n```\n\n其他均可套此模版\n\n> 注意http{}需要闭合，最后的大括号容易被误删\n\n#### (5) 检验配置并重启nginx\n\n```bash\nsudo nginx -t\n```\n\n<img src=\"2025-03-08-nginx-ssl/PixPin_2025-03-08_22-34-47.png\" alt=\"PixPin_2025-03-08_22-34-47\" style=\"zoom:67%;\" />\n\n证明无错误，重启nginx\n\n```bash\nsudo nginx -s reload\n```\n\n### 4.SSL证书\n\n可以去腾讯云申请免费的证书，下载证书的crt和key(选nginx即可)可用于其他平台的服务器\n\n>每个证书有效期三个月\n>\n>除www外的二级域名需要单独申请\n>\n>总有效证书最多50个(到期会释放个数)\n\n","tags":["教程及说明","反向代理","端口转发"],"categories":["Nginx"]},{"title":"Hexo博客部署到云服务器教程","url":"/2025/03/ee12770f/","content":"\n## 准备工作\n\n- Ubuntu（Linux）系统\n- Git\n- Nginx\n- Hexo（本地）\n\n## 环境配置\n\n### 1.使用`root`用户或者具有管理员权限的用户连接至云服务器\n\n### 2.安装Git\n\n#### (1)查看是否安装好git\n\n```bash\ngit --version\n```\n\n如果提示git版本，说明已经安装git，跳到下一步。如果提示找不到`git`命令，说明未安装。\n\n运行以下命令安装git：\n\n```bash\napt install git\n```\n\n再次查看是否完成git安装：\n\n```bash\ngit --version\n```\n\n#### (2)创建git用户，并配置仓库\n\n创建用户\n\n```bash\nadduser git\n```\n\n根据提示设置密码，其他信息可以位空\n\n切换至git用户\n\n```bash\nsu git\n```\n\n打开用户目录\n\n```bash\ncd\n```\n\n`cd`默认打开当前用户的目录，即`/home/git/`\n\n创建一个保存网页文件的文件夹\n\n```bash\nmkdir -p projects/hexo-blog\n```\n\n新建并打开仓库文件夹\n\n```bash\nmkdir repos && cd repos\n```\n\n第一次使用git会提示设置默认分支名称，我们这里提前设置为main（或者master）\n\n> 如果之前一直在使用github的pages，大概率你的主分支是main，为了方便统一，这里也设置为main\n\n```bash\ngit config --global init.defaultBranch main\n```\n\n初始化仓库\n\n```bash\ngit init --bare hexo-blog.git\n```\n\n#### (3)创建钩子函数\n\n```bash\ncd hexo-blog.git/hooks\n```\n\n新建文件\n\n```bash\nvim post-receive\n```\n\n按`i`进入编辑模式\n\n粘贴以下内容：\n\n```\n#!/bin/sh\ngit --work-tree=/home/git/projects/hexo-blog --git-dir=/home/git/repos/hexo-blog.git checkout -f\n```\n\n按`ESC`再输入`:wq`按Enter即可\n\n#### (4)修改权限\n\n```bash\nchmod +x post-receive\n```\n\n退回root用户（也可以切换到可以使用sudo的用户，使用sudo完成）\n\n```bash\nexit\n```\n\n修改权限\n\n```bash\nchown -R git:git /home/git/repos/hexo-blog.git\n```\n\n#### (5)测试可用性\n\n在本地终端中使用：\n\n```bash\ngit clone git@<ip>:/home/git/repos/hexo-blog.git\n```\n\n`ip`为远程服务器的ip\n\n### 3.设置免密SSH连接\n\n#### (1)创建`authorized_keys`并修改权限\n\n使用`git`用户建立远程连接\n\n```bash\ncd /home/git/.ssh\n```\n\n如果没有就创建该目录\n\n```bash\ntouch authorized_keys\n```\n\n该文件内保存公钥(.pub)内容\n\n修改权限\n\n```bash\nchmod 600 authorized_keys\n```\n\n#### (2)创建密钥对（如果已有可跳过）\n\n查看本地是否存在密钥\n\nWindows：`C:/Users/<username>/.ssh`\n\nLinux:`/home/<username>/.ssh`\n\nMac:`/Users/<username>/.ssh`\n\n如果目录下存在`id_rsa`和`id_rsa.pub`则说明存在密钥对\n\n\n\n如果没有\n\n```bash\nssh-keygen -t rsa\n```\n\n全Enter即可\n\n#### (3)建立链接\n\n本地终端输入\n\n```bash\nssh-copy-id -i C:/Users/<username>/.ssh/id_rsa.pub git@<ip>\n```\n\n也可以手动复制文件`id_rsa.pub`的内容到远程`authorized_keys`\n\n测试连接\n\n本地终端输入\n\n```bash\nssh git@<ip>\n```\n\n> 此时使用git登陆远程主机，不需要输入密码\n>\n> 如果仍然需要密码，排查前面步骤是否出错，可以查看`/home/git/.ssh/authorized_keys`文件的内容是否与本地一致\n>\n> 确认前面没有问题，需要修改ssh的配置文件\n>\n> ```bash\n> sudo vim /etc/ssh/sshd_config\n> ```\n>\n> 修改其中的一些配置\n>\n> ```\n> # 是否让 sshd 去检查用户家目录或相关档案的权限数据，\n> # 这是为了担心使用者将某些重要档案的权限设错，可能会导致一些问题所致。\n> # 例如使用者的 ~.ssh/ 权限设错时，某些特殊情况下会不许用户登入\n> # 修改此项仅为临时方案，建议将目录权限修改为正确权限（chmod）\n> StrictModes no\n> \n> # 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。\n> # 至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内\n> RSAAuthentication yes\n> PubkeyAuthentication yes\n> AuthorizedKeysFile      .ssh/authorized_keys\n> \n> # 有了证书登录了，就禁用密码登录。\n> PasswordAuthentication no\n> ```\n>\n> 保存配置，重启ssh\n>\n> ```bash\n> systemctl restart ssh\n> ```\n>\n> 或者\n>\n> ```bash\n> systemctl restart sshd\n> ```\n>\n> \n\n### 4.安装Nginx\n\n#### (1)使用`root`或者带有管理权限的用户登陆\n\n```bash\napt install nginx\n```\n\n或者\n\n```bash\nsudo apt install nginx\n```\n\n查看是否安装完成\n\n```bash\nnginx -v\n```\n\n显示版本信息就说明安装完成\n\n运行nginx\n\n```bash\nnginx\n```\n\n在本地浏览器输入<ip>可以看到\n\n<img src=\"2025-03-08-hexo-git-cloud/PixPin_2025-03-08_21-15-24.png\" alt=\"PixPin_2025-03-08_21-15-24\" style=\"zoom: 67%;\" />\n\n如果拒绝访问，确认自己的服务器开放了80端口\n\n#### (2)配置nginx\n\n远程连接服务器\n\n备份配置文件\n\n```bash\nsudo cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.default\n```\n\n编辑配置文件\n\n```bash\nsudo vim /etc/nginx/nginx.conf\n```\n\n找到`http {`开头的块\n\n里面会有`server`开头的块，如下图，默认不是注释掉的\n\n<img src=\"2025-03-08-hexo-git-cloud/PixPin_2025-03-08_21-24-34.png\" alt=\"PixPin_2025-03-08_21-24-34\" style=\"zoom:50%;\" />\n\n只需要修改80端口server里面的就可以，后面解释ssl的配置\n\n把其中的\n\n```\nroot         /usr/share/nginx/html;\n```\n\n修改为\n\n```\nroot         /home/git/projects/hexo-blog;\n```\n\n保存，检验配置\n\n```bash\nsudo nginx -t\n```\n\n如果不使用sudo可能会有警告提示user命令失效\n\n<img src=\"2025-03-08-hexo-git-cloud/PixPin_2025-03-08_21-29-38.png\" alt=\"PixPin_2025-03-08_21-29-38\" style=\"zoom:50%;\" />\n\n说明配置正确，如果提示其他内容，检查是否存在拼错或者其他错误\n\n重启nginx\n\n```bash\nsystemctl reload nginx\n```\n\n```bash\nsystemctl restart nginx\n```\n\n或者\n\n```bash\nsudo nginx -s reload\n```\n\n### 5.配置Hexo\n\n编辑本地网站主目录下的`_config.yml`\n\n找到\n\n```\ndeploy:\n  type: git\n  repo:\n    github: git@github.com:xxxxxxxxxx.github.io.git\n    git1: git@<ip1>:/home/git/repos/hexo-blog.git\n    git2: git@<ip2>:/home/git/repos/hexo-blog.git\n  branch: main\n```\n\n可以同时上传到多个服务器上\n\n上传网站\n\n```bash\nhexo g -d\n```\n\n### 6.限制git用户权限（可选）\n\n查看git-shells是否在登录方式里\n\n```bash\ncat /etc/shells\n```\n\n如果没有\n\n```bash\nwhich git-shell\nsudo vim /etc/shells\n```\n\n添加到后面\n\n```bash\n/usr/bin/git-shell\n```\n\n如下图\n\n<img src=\"2025-03-08-hexo-git-cloud/PixPin_2025-03-08_21-43-36.png\" alt=\"PixPin_2025-03-08_21-43-36\" style=\"zoom:67%;\" />\n\n然后修改\n\n```bash\nsudo vim /etc/passwd\n```\n\n找到git用户\n\n只修改划线部分\n\n```bash\n/usr/bin/git-shell\n```\n\n<img src=\"2025-03-08-hexo-git-cloud/PixPin_2025-03-08_21-45-35.png\" alt=\"PixPin_2025-03-08_21-45-35\" style=\"zoom:67%;\" />","tags":["教程及说明","Hexo"],"categories":["Ubuntu"]},{"title":"论文研读(一)","url":"/2024/12/3e16e77c/","content":"\n## 原文\n\n[A depth-averaged two-dimensional sediment transport model for environmental studies in the Scheldt Estuary and tidal river network - ScienceDirect](https://www.sciencedirect.com/science/article/pii/S0924796313000833)\n\n[附PDF: https://pan.baidu.com/s/1XmZkQXuFonfgSAhfdp6Wrw?pwd=pnkh](https://pan.baidu.com/s/1XmZkQXuFonfgSAhfdp6Wrw?pwd=pnkh)\n\n## 工作内容\n\n针对SLIM有限元模型(Second-generation Louvainla-Neuve Ice-ocean Model)的二维深度平均分量和一维截面平均分量设计了泥沙模块, 并将其应用于斯海尔德盆地的潮汐部分. 该泥沙输运模块侧重于细粒、粘性沉积物. 它是进行环境生物地球化学研究的必要工具, 其中细粒沉积物动力学起着至关重要的作用。\n\n## 流体力学和盐度模型\n\n河口部分使用二维深度平均方程, 河流部分使用一维截面平均方程\n\n### 浅水方程(Shallow water equations)\n\n$$\n\\frac {\\partial \\eta}{\\partial t} + \\nabla \\cdot(Hu) = 0\n$$\n\n$$\n\\frac{\\partial u}{\\partial t} + u \\cdot (\\nabla u) + fk \\times u = -g \\nabla \\eta - \\frac{1}{\\rho}\\nabla P_a + \\frac{1}{H}\\nabla \\cdot (H\\nu (\\nabla u)) + \\frac{\\tau_s - \\tau_b}{\\rho H}\n$$\n\n\n\n其中 t 是时间, $H=h+\\eta$ 是水深, h 是水柱参考高度; $f=2\\omega\\sin \\phi$为科里奥利参数, 以$\\omega$为地球角速度, 以$\\phi$为纬度; k为单位向上矢量; G为重力加速度; $\\rho$ 是水的密度, 假设水的密度是恒定的, $P_a$ 是水面的大气压力; $\\nu$ 为水平涡动粘度; $\\tau_s$和$\\tau_b$分别为表面和底部应力矢量. \n\n### 深度平均盐度运输方程\n\n$$\n\\frac{\\partial (HS)}{\\partial t} + \\nabla\\cdot (HuS) = \\nabla \\cdot (Hk\\nabla S)\n$$\n\n其中k为扩散系数\n\n### 水平涡粘性系数\n\n根据 Smagorinsky（1963）的工作，水平涡粘性系数 $\\nu$ 通常按照以下形式给出：\n\n$$\nν = C_s^2 * Δx * |S|\n$$\n这里，\n\n$C_s$ 是 Smagorinsky 常数，一般取值在 0.1 到 0.2 之间；\n$Δx$ 是网格间距，代表了模型分辨率；\n$|S|$ 是应变率张量 S 的模，它描述了速度场的空间变化，具体为：\n$$\nS = (∇u + (∇u)^T) / 2\n$$\n其中 $∇u$ 是速度梯度张量，而上标 T 表示转置。应变率张量的模可以通过下式计算：\n\n$$\n|S| = sqrt(2 * S_{ij} * S_{ij})\n$$\n这里的 $S_ij$ 表示应变率张量的分量。\n\n### 曼宁-斯特里克勒公式(the Chézy–Manning–Strickler formulation)\n\n$$\n\\tau_b = \\rho g n^2 \\frac{u \\begin{Vmatrix} u \\end{Vmatrix} }{H^{1/3}}\n$$\n\n其中 n 是曼宁系数. 在大陆架等于$0.0235\\ s\\ m^{-1/3}$ , 在Antwerp附近, 从河口线性增加到$0.028\\ s\\ m^{-1/3}$\n\n### 扩散系数 k (Okubo)\n\n$$\nk = c_k \\Delta^{1.15}\n$$\n\n其中 $c_k$ 为常数, $\\Delta$ 是网格的特征长度尺度(即二维网格中三角形的最长边, 或一维网格中线段的长度). 对其值进行校准以准确地表示Scheldt中的盐度变化, 从而得到 $c_k = 150\\ m^{0.85}s^{-1}$. \n\n## 泥沙模型\n\n泥沙模块考虑了三层: 悬浮沉积物所在的水柱, 由底部新沉积的沉积物组成的一层, 以及后者下方的一个母层。虽然考虑了三层, 但该模块仅由两个相互作用的变量组成, 即$C_{ss}$, 悬浮沉积物的深度平均浓度[$kg\\ m^{−3}$], 以及$C_{sb}$, 新鲜层中底层沉积物的浓度[$kg\\ m^{−2}$]。母层是沉积物的无限来源, 只有当$C_{sb}$局部为零时才会被侵蚀。\n\n悬浮中的沉积物是通过平流和扩散输送的, 而底部的沉积物则不是。在区域的二维部分, 悬浮泥沙浓度和新沉积泥沙浓度服从如下方程:\n$$\n\\frac{\\partial (HC_{ss})}{\\partial t} + \\nabla \\cdot (HuC_{ss}) = \\nabla \\cdot (Hk\\nabla C_{ss}) + E_f + E_p - D\n$$\n\n$$\n\\frac{\\partial C_{sb}}{\\partial t} = D - E_f\n$$\n\n<img src=\"2024-12-08-read-experience/image-20241208170632962.png\" alt=\"image-20241208170632962\" style=\"zoom:50%;\" />\n\n式中$E_f$为新鲜层沉积物的侵蚀速率, $E_p$为母层沉积物的侵蚀速率, $D$为新鲜层沉积物的沉积速率。\n\n**假设母层从未供应, 并且两个底层之间没有交换。此外, 也没有考虑床质输运。**\n\n### 侵蚀速率 (Partheniades(1965))\n\n$$\nE_f = \\begin{cases} \\begin{aligned}\n&M\\left( \\frac{\\tau_b}{\\tau_e} -1\\right) &     & if\\ \\tau_b > \\tau_e\\ and\\ C_{sb} > 0 \\newline\n&0 &    &otherwise\n\\end{aligned}\n\\end{cases}\n$$\n\n$$\nE_p = \\begin{cases} \\begin{aligned}\n&M\\left( \\frac{\\tau_b}{\\tau_{e,p}} -1\\right) &     & if\\ \\tau_b > \\tau_{e,p}\\ and\\ C_{sb} = 0 \\newline\n&0 &    &otherwise\n\\end{aligned}\n\\end{cases}\n$$\n\n当$\\tau_b$(底部应力向量的范数$\\tau_b$) 高于一个阈值$\\tau_e$时, 沉积物从新鲜层被侵蚀, 或者, 如果新鲜层局部是空的, 当$\\tau_b$高于另一个阈值$\\tau_{e,p}$; M被称为侵蚀速率参数。\n\n### 沉积速率(Einstein和Krone (1962))\n\n$$\nD=w_sC_{ss}\n$$\n\n其中 $w_s$ 为沉降速度. \n$$\nw_S = w_{s,0} \\left( \\frac{C_{ss}}{C_{ss,0}}\\right)^m\n$$\n其中 $C_{ss,0}=0.1\\ kg m^{-3}$ 是 Scheldt SSC的参考值, $w_{s,0}$ 是相关的参考沉降速度, 其值是经验确定的, m 是0.5到3.5之间的系数(van Leussen, 1999). \n\n>### 连续方程的推导\n>\n>![image-20241211171404424](2024-12-08-read-experience/image-20241211171404424.png)\n>\n>引入自由表面的运动学条件和底部运动学条件\n>$$\n>u_z|_{z=z_s} = \\frac{dz_s}{dt} = \\frac{\\partial z_s}{\\partial t} + \\frac{\\partial z_s}{\\partial x} u_x + \\frac{\\partial z_s}{\\partial y} u_y\n>$$\n>\n>$$\n>u_z|_{z=z_b} = \\frac{dz_b}{dt} = \\frac{\\partial z_b}{\\partial t} + \\frac{\\partial z_b}{\\partial x} u_x + \\frac{\\partial z_b}{\\partial y} u_y\n>$$\n>\n>对连续性方程沿水深方向进行积分\n>$$\n>\\int_{z_b}^{z_s}\\frac{\\partial u_j}{\\partial x_j} dz = 0 \\ (j=1,2,3)\n>$$\n>\n>$$\n>\\int_{z_b}^{z_s}\\frac{\\partial u_j}{\\partial x_j}dz + u_z|_{z_s} - u_z|_{u_b} = 0 \\ (j=1,2)\n>$$\n>\n>由牛顿-莱布尼兹公式\n>$$\n>\\frac{\\partial}{\\partial x_j} \\int_a^b f dz = \\int_a^b \\frac{\\partial f}{\\partial x_j} dz + f|_b \\frac{\\partial b}{\\partial x_j} - f|_a \\frac{\\partial a}{\\partial x_j}\n>$$\n>将上式第一项展开，可得\n>$$\n>\\frac{\\partial }{\\partial x_j}\\int_{z_b}^{z_s}u_jdz - u_j|_{z_s}\\frac{\\partial z_s}{\\partial x_j} +u_j|_{z_b}\\frac{\\partial z_b}{\\partial x_j} + u_z|_{z_s} - u_z|_{z_b} = 0 \\ (j=1,2)\n>$$\n>代入两个运动学条件，可得\n>$$\n>\\frac{\\partial }{\\partial x_j}\\int_{z_b}^{z_s}u_jdz - u_j|_{z_s}\\frac{\\partial z_s}{\\partial x_j} +u_j|_{z_b}\\frac{\\partial z_b}{\\partial x_j} + \\frac{\\partial z_s}{\\partial t} + \\frac{\\partial z_s}{\\partial x_j} u_j|_{z_s} - \\frac{\\partial z_b}{\\partial t} - \\frac{\\partial z_b}{\\partial x_j} u_j|_{z_b} = 0 \\ (j=1,2)\n>$$\n>化简，得\n>$$\n>\\frac{\\partial }{\\partial x_j} \\int_{z_b}^{z_s} u_j dz + \\frac{\\partial z_s}{\\partial x_j} - \\frac{\\partial z_b}{\\partial x_j} = 0 \\ (j=1,2)\n>$$\n>由 $H=z_s-z_b$, 进一步化简为\n>$$\n>\\frac{\\partial H}{\\partial t} + \\frac{\\partial }{\\partial x_j} \\int_{z_b}^{z_s} u_j dz = 0 \\ (j=1,2)\n>$$\n>又有\n>$$\n>\\int_{z_b}^{z_s} u_j dz = HU_j \\ (j=1,2)\n>$$\n>代入上式，得\n>$$\n>\\frac{\\partial H}{\\partial t} + \\frac{\\partial HU_j}{\\partial x_j} = 0 \\ (j=1,2)\n>$$\n>即\n>$$\n>\\frac{\\partial H}{\\partial t} + \\frac{\\partial HU_x}{\\partial x} + \\frac{\\partial HU_y}{\\partial y} = 0\n>$$\n>本篇文章中 $H = h + \\eta$, $H$ 为水深，$h$ 为参考水柱高度（河床到基准面的高度），$\\eta$ 为水面相对于基准面的高度，是一个瞬时变化量。\n>\n>因此，第一项水深随时间的变化率写为 $\\frac{\\partial \\eta}{\\partial t}$，第二三项的为水平方向的水流通量，其通过面积可表示为 $H$, 因此此项应写为 $\\frac{\\partial Hu_j}{\\partial x_j}$. \n>\n>综上\n>$$\n>\\frac{\\partial \\eta}{\\partial t} + \\frac{\\partial Hu_j}{\\partial x_j} = 0 \\ (j=1,2)\n>$$\n>使用哈密顿算子可以表示为\n>$$\n>\\frac{\\partial \\eta}{\\partial t} + \\nabla \\cdot (Hu) = 0\n>$$\n>\n\n\n\n\n\n","tags":["学习笔记","深度平均"],"categories":["深度平均"]},{"title":"Mavic 3 classic屏控航线(航点)飞行教程","url":"/2024/08/78788d45/","content":"\n## 准备工作\n\n遥控手柄(带屏)\n\n航线规划软件(网页) - Rainbow Cloud\n\nSD卡, 读卡器, 电脑\n\n## 1. 创建航线\n\n首先, 打开[Rainbow Cloud网站](https://app.flydji.cn/). \n\n网页界面如下: \n\n<img src=\"2024-08-05-uav-mavic3c/20240907103046.png\" alt=\"image-20240907103033256\" style=\"zoom: 33%;\" />\n\n点击左侧新建任务. \n\n<img src=\"2024-08-05-uav-mavic3c/20240907103203.png\" alt=\"image-20240907103201411\" style=\"zoom:33%;\" />\n\n选择正射\n\n<img src=\"2024-08-05-uav-mavic3c/20240907103355.png\" alt=\"image-20240907103352484\" style=\"zoom: 33%;\" />\n\n输入任务名称\n\n<img src=\"2024-08-05-uav-mavic3c/20240907103444.png\" alt=\"image-20240907103443297\" style=\"zoom:50%;\" />\n\n确认之后, 找到我们需要飞行的区域. 任意点击一个区域, 生成一个默认的范围. \n\n<img src=\"2024-08-05-uav-mavic3c/20240907103635.png\" alt=\"image-20240907103623963\" style=\"zoom:33%;\" />\n\n然后, 调整这个范围至合适位置. 可以移动和添加顶点\n\n<img src=\"2024-08-05-uav-mavic3c/20240907104233.png\" alt=\"image-20240907104221465\" style=\"zoom:33%;\" />\n\n然后, 调整右侧参数栏的参数. \n\n<img src=\"2024-08-05-uav-mavic3c/20240907104901.png\" alt=\"image-20240907104849438\" style=\"zoom:33%;\" />\n\n<img src=\"2024-08-05-uav-mavic3c/20240907105200.png\" alt=\"image-20240907105046748\" style=\"zoom:33%;\" />\n\n其余设置与上图保持一致, 保存任务\n\n<img src=\"2024-08-05-uav-mavic3c/20240907105605.png\" alt=\"image-20240907105604011\" style=\"zoom:50%;\" />\n\n点击右上角任务导出\n\n<img src=\"2024-08-05-uav-mavic3c/20240907105752.png\" alt=\"image-20240907105740750\" style=\"zoom:33%;\" />\n\n选择合适的航点数, 每个文件最多支持300个航点. 航点越多单文件加载越慢.\n\n<img src=\"2024-08-05-uav-mavic3c/20240907110020.png\" alt=\"image-20240907110018439\" style=\"zoom:50%;\" />\n\n点击下载, 将文件下载并导入到SD卡中.\n\n## 2. 导入航线\n\n根据导入教程导入文件[Mavic3系列屏控手动导入Kmz航点任务](https://docs.qq.com/doc/DWWNyWkxjaURLU05G)\n\n### 2.1 创建并备份航线\n\n创建任意数量的航点, 保存. \n\n航点文件保存位置如下\n\n<img src=\"2024-08-05-uav-mavic3c/20240913182709.png\" alt=\"image-20240913182656864\" style=\"zoom:33%;\" />\n\n一串英文字符的文件夹内存放的就是航线文件(kmz格式)\n\n将整个waypoint文件夹复制至SD卡中\n\n### 2.2 替换kmz文件\n\n将已经下载好的Kmz文件同样导入到SD卡的该文件夹内\n\n注意一个文件内只有一个kmz文件, 导出多个文件时需要提前创建好足够数量的航点文件(单文件最大支持300个航点).\n\n将文件夹内的kmz文件名称复制 -> 删除 -> 导入下载的kmz文件 -> 重命名为刚复制的文件名(即保证文件名不更换)\n\n最后将替换好的waypoint文件夹替换回去 \n","tags":["教程及说明","DJI","Mavic 3 classic","正射航线"],"categories":["无人机"]},{"title":"物质点法--学习笔记(一)","url":"/2024/07/af38f644/","content":"\n## 1. 物质点法\n\n​    物质点法(MPM)将连续体离散成一组质点. 每个质点代表一块材料区域并携带该区域材料的所有物质信息, 如质量, 速度, 应力和应变等. 计算网格仅用于动量方程的求解和空间导数的计算, 它不携带任何物质信息. 在每一个时间步中, 质点与计算网格完全固连(拉格朗日计算步), 可以用标准的有限元法在计算网格上求解物体的运动方程. 计算网格结点的运动方程可以通过将质点的运动量映射到计算网格得到, 求解后将计算网格结点的运动量映射回各质点, 从而得到这些质点在下一时刻的运动量(对流计算步). \n\n​    物质点法是一种完全的拉格朗日质点类方法, 在每步中质点和计算网格没有相对运动, 避免了欧拉法因非线性对流项产生的数值困难. 质点已经携带了连续体的所有物质信息, 因此物质点法在每个时间步结束时抛弃变形后的计算网格, 在新的时间步中仍可以采用未变形的计算网格. \n\n<img src=\"2024-07-12-mpm-bj1/20240712103901.png\" alt=\"image-20240712103857244\" style=\"zoom:33%;\" />\n\n​    在并行算法方面, 主要基于消息传递模型(MPI)和信息共享模型(OpenMP)实现. \n\n## 2. 控制方程\n\n### 2.1 物体运动和变形的描述\n\n​    物体在 t = 0 时刻所占据的空间区域称为`初始构形`. 物体在 t 时刻所占据的空间区域成为`现时构形`. 为了度量物体的运动, 需要选取一个特定的构形作为基准, 称为`参考构形`. \n\n<img src=\"2024-07-12-mpm-bj1/20240712105211.png\" alt=\"image-20240712105208694\" style=\"zoom: 33%;\" />\n\n​    在参考构形中质点的矢径 $X$ 可以表示为\n$$\n\\begin{equation}\n\\label{eq21}\nX = X_i e_i, i = 1,2,3\n\\end{equation}\n$$\n​    其中 $e_i$ 为直角坐标系的基矢量, $X_i$ 为参考构形中质点矢径 $X$ 在 $e_i$ 上的投影. 质点在参考构形中的矢径 $X$ 不随时间 $t$ 变化, $X_i$ 称为`物质坐标`或`拉格朗日坐标`, 它可以作为该质点的标记. \n\n​    在现时构形中质点 $X$ 的矢径 $x$ 可以表示为\n$$\n\\begin{equation}\n\\label{eq22}\nx = x_i e_i , i = 1, 2, 3\n\\end{equation}\n$$\n​    其中 $x_i$ 为矢径 $x$ 在 $e_i$ 上的投影, 坐标 $x_i$ 给出了质点 $X$ 在空间中的位置,称为`空间坐标`或`欧拉坐标`. 质点 $X$ 的运动方程可以表示为\n$$\n\\begin{equation}\n\\label{eq23}\nx_i = x_i(X,t)\n\\end{equation}\n$$\n​    在拉格朗日描述中, 质点 $X$ 的位移为\n$$\n\\begin{equation}\n\\label{eq24}\nu_i = x_i (X, t) - X_i\n\\end{equation}\n$$\n​    在欧拉描述中, 质点 $X$ 的位移为\n$$\n\\begin{equation}\n\\label{eq25}\nu_i = x_i - X_i(x,t)\n\\end{equation}\n$$\n​    质点的速度等于其矢径 $x$ 的变化率, 即令 $X$ 保持不变时矢径 $x$ 对时间的偏导数. 令 $X$ 保持不变时物理量对时间的导数称为`物质导数`, 也称为`全导数`或`拉格朗日导数`. 由式 $(\\ref{eq24})$ 可以得到质点的速度为\n$$\n\\begin{equation}\n\\label{eq26}\nv_i = \\frac{\\partial x_i(X, t)}{\\partial t} = \\frac{\\partial u_i(X, t)}{\\partial t} \\equiv \\dot{u}_i\n\\end{equation}\n$$\n​    质点的加速度为其速度的物质导数, 即\n$$\n\\begin{equation}\n\\label{eq27}\n\\alpha_i = \\frac{\\partial v_i(X,t)}{\\partial t} = \\frac{\\partial^2 u_i (X, t)}{\\partial t^2} \\equiv \\ddot{u}_i\n\\end{equation}\n$$\n​    如果物理量 $F$ 是用空间坐标 $x$ 和时间 $t$ 描述的, 即 $F = F(x,t)$, 可以先利用式 $(\\ref{eq23})$ 把它变换为复合函数 $F = F(x(X, t), t)$, 它的物质导数为\n$$\n\\begin{equation}\n\\begin{aligned}\n\\label{eq28}\n\\frac{DF(x, t)}{Dt} &= \\frac{\\partial F(x, t)}{\\partial t} + \\frac{\\partial F(x, t)}{\\partial x_i}\\frac{\\partial x_i(X, t)}{\\partial t} \\\\ \n&= \\frac{\\partial F(x, t)}{\\partial t} + \\frac{\\partial F(x, t)}{\\partial x_i}v_i \n\\end{aligned}\n\\end{equation}\n$$\n​     $F(x, t)$ 描述的是时刻 $t$  空间点 $x$ 处的物理量, 因此 $\\partial F(x, t)/\\partial t$ 表示的是物理量在空间固定点 $x$ 处的变化率, 称为`空间时间导数`, 也称为`局部导数`或`欧拉导数`. 它反映了物理量的非定常性.\n\n### 2.2 变形梯度\n\n质点的现时坐标 $x_i$ 相对于物质坐标 $X_j$ 的偏导数 $F_{ij} = \\partial x_i / \\partial X_j$ 称为变形梯度, 它是一个非对称的二阶张量. 初始构形中由相邻质点 $X$ 和 $X+dX$ 构成的无限小线元 $dX$ 在现时构形中变为\n$$\n\\begin{equation}\n\\label{eq29}\ndx_i = x_i(X + dX, t) - x_i(X, t)\n\\end{equation}\n$$\n对 $x_i(X + dX, t)$ 在 $X$ 处作泰勒展开, 并略去高阶小项得\n$$\n\\begin{equation}\n\\label{eq210}\ndx_i = \\frac{\\partial x_i}{\\partial X_j} dX_j\n\\end{equation}\n$$\n变形梯度的行列式\n$$\n\\begin{equation}\n\\label{eq211}\nJ = \n\\begin{vmatrix} \n\\frac{\\partial x_i}{\\partial X_j}\n\\end{vmatrix}\n=\n\\begin{vmatrix} \n\\frac{\\partial x_1}{\\partial X_1} & \\frac{\\partial x_1}{\\partial X_2} & \\frac{\\partial x_1}{\\partial X_3}\\\\\n\\frac{\\partial x_2}{\\partial X_1} & \\frac{\\partial x_2}{\\partial X_2} & \\frac{\\partial x_2}{\\partial X_3}\\\\\n\\frac{\\partial x_3}{\\partial X_1} & \\frac{\\partial x_3}{\\partial X_2} & \\frac{\\partial x_3}{\\partial X_3}\\\\\n\\end{vmatrix}\n\\end{equation}\n$$\n称为`雅可比行列式`. \n\n引入**排列张量** $e_{ijk}$, 可将式 $(\\ref{eq211})$ 展开为\n$$\n\\begin{equation}\n\\label{eq212}\nJ = e_{ijk}\\frac{\\partial x_i}{\\partial X_1} \\frac{\\partial x_j}{\\partial X_2} \\frac{\\partial x_k}{\\partial X_3}\n\\end{equation}\n$$\n由行列式的性质和 $J$ 的定义式 $(\\ref{eq211})$可得\n$$\n\\begin{equation}\n\\label{eq213}\ne_{plm}J = e_{ijk}\\frac{\\partial x_i}{\\partial X_p} \\frac{\\partial x_j}{\\partial X_l} \\frac{\\partial x_j}{\\partial X_m}\n\\end{equation}\n$$\n设初始构形中的平行六面体体元的三个线元分别是 $dX$, $\\delta X$ 和 $\\Delta X$, 它们在现时构形中分别为 $dx$, $\\delta x$ 和 $\\Delta x$, 且\n$$\ndx_i = \\frac{\\partial x_i}{\\partial X_p}dX_p,\\ \\delta x_j = \\frac{\\partial x_j}{\\partial X_l}\\delta X_l,\\ \\Delta x_k = \\frac{\\partial x_k}{\\partial X_m} \\Delta X_m\n$$\n<img src=\"2024-07-12-mpm-bj1/20240714111451.png\" alt=\"image-20240714111448284\" style=\"zoom:50%;\" />\n\n现时构形中由 $dx$, $\\delta x$ 和 $\\Delta x$ 构成的六面体体元的体积为\n$$\n\\begin{equation}\n\\label{eq214}\ndV = \n\\begin{vmatrix}\ndx_1 & dx_2 & dx_3\\\\\n\\delta x_1 & \\delta x_2 & \\delta x_3\\\\\n\\Delta x_1 & \\Delta x_2 & \\Delta x_3\\\\\n\\end{vmatrix}\n= JdV_0\n\\end{equation}\n$$\n因此变形梯度矩阵的行列式 $J$ 可用来表示变形过程中体元的体积变化, 即\n$$\n\\begin{equation}\n\\label{eq215}\nJ = \\frac{dV}{dV_0}\n\\end{equation}\n$$\n可见 $J$ 表示变形前后体元体积之比. \n\n### 2.3 变形率\n\n考察一个典型的质点 $P$, 它在时刻 $t$ 的坐标为 $x_j$, 瞬时速度为 $v_i(x_j, t)$. 与 $P$ 点相邻的质点 $P'$ 的坐标为 $x_j+dx_j$, 它相对于 $P$ 点的相对速度为\n$$\n\\begin{equation}\n\\label{eq216}\ndv_i = v_i(x_j + dx_j, t) - v_i(x_j, t) = \\frac{\\partial v_i}{\\partial x_j} dx_j\n\\end{equation}\n$$\n式中 $\\partial v_i/\\partial x_j$ 为**速度梯度张量**. 它可分解为对称部分和反对称部分之和, 即\n$$\n\\begin{equation}\n\\label{eq217}\n\\frac{\\partial v_i}{\\partial x_j} = \\frac{1}{2}\\left( \\frac{\\partial v_i}{\\partial x_j} - \\frac{\\partial v_j}{\\partial x_i} \\right) + \\frac{1}{2}\\left( \\frac{\\partial v_i}{\\partial x_j} + \\frac{\\partial v_j}{\\partial x_i} \\right)\\\\\n= \\Omega_{ij} + D_{ij}\n\\end{equation}\n$$\n式中\n$$\n\\begin{equation}\n\\label{eq218}\n\\Omega_{ij} = \\frac{1}{2}\\left( \\frac{\\partial v_i}{\\partial x_j} - \\frac{\\partial v_j}{\\partial x_i} \\right)\n\\end{equation}\n$$\n$$\n\\begin{equation}\n\\label{eq219}\nD_{ij} = \\frac{1}{2}\\left( \\frac{\\partial v_i}{\\partial x_j} + \\frac{\\partial v_j}{\\partial x_i} \\right)\n\\end{equation}\n$$\n分别为**旋律张量**和**变形率张量**. \n\n与速度梯度分解相似， 相对速度式 $(\\ref{eq216})$ 也可分解为\n$$\n\\begin{equation}\n\\label{eq220}\ndv_i = dv_i^* + dv_i^{**}\n\\end{equation}\n$$\n其中\n$$\n\\begin{equation}\n\\label{eq221}\ndv_i^* = \\Omega_{ij}dx_j, dv_i^{**} = D_{ij}dx_j\n\\end{equation}\n$$\n旋率张量 $\\Omega_{ij}$ 是反对称张量, 它只有 3 个独立的分量, 总存在一个对偶矢量(旋度矢量) $\\omega$, 使得\n$$\n\\begin{equation}\n\\label{eq222}\n\\Omega_{ij} = -e_{ijk}\\omega_k\n\\end{equation}\n$$\n将上式代入式 $(\\ref{eq221})$ 的第一式得\n$$\ndv^*_i = -e_{ijk} \\omega_k dx_j = (\\omega \\times dx)_i\n$$\n\n上式表明相对速度 $dv^*$ 等于 $\\omega$ 和 $dx$ 的矢量积. 在质点 $P$ 的邻域内, 相对速度 $dv^*$ 对应于这个邻域绕过 $P$ 点的某轴的一个刚体运动, 矢量 $\\omega$ 表示转动的角速度. \n\n可以证明, 变形张量 $D_{ij}$ 是相对于现时构形定义的柯西应变的速率, 也就是真实应变 $\\epsilon_{ij}$ 的速率 $\\dot{\\epsilon}_{ij}$, 即\n$$\n\\begin{equation}\n\\label{eq224}\nD_{ij} = \\dot{\\epsilon}_{ij}\n\\end{equation}\n$$\n\n### 2.4 柯西应力\n\n> 考虑物体在时刻 $t$ 的现时构形内的一个有向面元 $n\\Delta A$, 其法向单位向量 $n$ 在坐标轴 $e_k$ 上的投影记为  $n_k$. 面元 $n\\Delta A$ 两侧的介质通过面元相互作用以力元 $\\Delta T$, 这个力元除以面元的面积就定义了该面元上的应力矢量 $t^{(n)}$: \n\n$$\n\\begin{equation}\n\\label{eq225}\nt_i^{(n)} = \\lim_{\\Delta A \\rightarrow 0} \\frac{\\Delta T_i}{\\Delta A} = \\frac{dT_i}{dA}\n\\end{equation}\n$$\n面元 $n\\Delta A$ 与另外三个垂直于坐标轴的面元 $n^{(1)}\\Delta A_1$, $n^{(2)}\\Delta A_2$ 和 $n^{(3)}\\Delta A_3$ 构成一个四面体, 且有 $\\Delta A_k = \\Delta An_k$. 面元 $n^{(k)}\\Delta A_k$ 上的应力矢量记为 $t^{(k)}$, 由平衡条件可得\n$$\n\\begin{equation}\n\\label{eq226}\n\\Delta T_i = t_i^{(n)} \\Delta A = t_i^{(k)} \\Delta A_k = t_i^{(k)} \\Delta An_k = \\sigma_{ki} n_k \\Delta A\n\\end{equation}\n$$\n其中 $\\sigma_{ki} = t_i^{(k)}$ 是垂直于坐标轴 $x_k$ 的面元 $n^{(k)} \\Delta A_k$ 上的应力矢量 $t^{(k)}$ 在坐标轴 $x_i$ 上的分量. 由式$(\\ref{eq225})$和式$(\\ref{eq226})$得\n$$\n\\begin{equation}\n\\label{eq227}\nt_i^{(n)} = \\sigma_{ki}n_k \n\\end{equation}\n$$\n<img src=\"2024-07-12-mpm-bj1/20240721113930.png\" alt=\"image-20240721113927574\" style=\"zoom:50%;\" />\n\n​\t\t\t\t\t\t\t     (箭头朝外)\n\n由现时构形中垂直于坐标轴的三个面元上的应力矢量的九个分量 $\\sigma_{ij}$ 定义了一个张量, 称为**柯西应力张量**. 由微元体关于力矩的平衡条件可以证明柯西应力张量是对称的, 即\n$$\n\\begin{equation}\n\\label{eq228}\n\\sigma_{ij} = \\sigma{ji}\n\\end{equation}\n$$\n柯西应力是定义在现时构形每单位面积上的接触力, 它是与变形相关的真实应力. \n\n### 2.5 焦曼应力率\n\n>  考察一承受单向应力 $\\sigma$ 作用并绕 $x_3$ 轴作刚体转动的杆, 如图2.4所示. 在杆平行于 $x_1$ 的瞬时，$\\sigma_{11} = \\sigma$, $\\sigma_{22} = 0$, 而当杆转动到平行于 $x_2$ 轴的位置时, $\\sigma_{11} = 0$, $\\sigma_{22} = \\sigma$. 相对于在空间固定的坐标系 $Px_1x_2$ 而言, 虽然杆内应力状态并未变化, 但刚体转动改变了柯西应力张量的分量, 导致柯西应力 $\\sigma_{ij}$ 的变化率,无论是空间导数 $\\partial \\sigma_{ij}/\\partial t$ 还是物质导数 $\\dot{\\sigma}_{ij}$ 都不等于零. 因此在本构方程中使用与变形率 $D_{ij}$ 相关联的应力率时, 无论 $\\partial \\sigma_{ij}/\\partial t$ 还是 $\\dot{\\sigma}_{ij}$ 都不是一个适当的度量. 用于本构方程中的应力率必须不受刚体转动的影响, 即必须是客观张量. \n\n<img src=\"2024-07-12-mpm-bj1/20240721151003.png\" alt=\"image-20240721151001362\" style=\"zoom: 33%;\" />\n\n> 考虑包含 $P$ 点的一个作瞬时转动的物质元, 动坐标系 $P\\bar{x}_1\\bar{x}_2\\bar{x}_3$ 与物质元固连, 跟随物质元一起作瞬时刚体转动. 虽然柯西应力张量在空间固定坐标系 $Px_1x_2x_3$ 中的变化率不为零, 但它在动坐标系 $P\\bar{x}_1\\bar{x}_2\\bar{x}_3$ 中的变化率为零, 是一个客观张量. \n\n在所考察的时刻 $t$, 动坐标系与固定坐标系 $x_i$ 重合, 如图 2.5 所示. 在 $P$ 点附近的任一相邻质点 $Q$, 其在动坐标系中的坐标 $d\\bar{x}_i$ 不受刚体转动影响, 而它在固定坐标系中的坐标以速率\n$$\n\\begin{equation}\n\\label{eq229}\ndv_i = \\Omega_{ij}d\\bar{x}_j\n\\end{equation}\n$$\n变化. 在时刻 $t+dt$, 有\n$$\n\\begin{equation}\n\\label{eq230}\ndx_i = d\\bar{x}_i + dv_i dt = (\\delta_{ij} + \\Omega_{ij} dt)d\\bar{x}_j\n\\end{equation}\n$$\n<img src=\"2024-07-12-mpm-bj1/20240721154214.png\" alt=\"image-20240721154212456\" style=\"zoom:50%;\" />\n\n由式($\\ref{eq230}$)可知, 动坐标系和固定坐标系之间的坐标变换的变换系数为\n$$\n\\begin{equation}\n\\label{eq231}\nc_{ij} = \\delta_{ij} + \\Omega_{ij}dt\n\\end{equation}\n$$\n在动坐标系内定义应力率\n$$\n\\begin{equation}\n\\label{eq232}\n\\sigma_{ij}^{\\nabla}(t) = \\lim_{dt \\rightarrow 0} \\frac{1}{dt}[\\bar{\\sigma}_{ij}(t+dt) - \\bar{\\sigma}_{ij}(t)]\n\\end{equation}\n$$\n显然物质元作刚体运动时, $\\sigma_{ij}^{\\nabla}(t) = 0$. 质点 $P$ 在时刻 $t+dt$ 相对于固定坐标系的应力张量是\n$$\n\\begin{equation}\n\\label{eq233}\n\\sigma _{ij}(t_dt) = \\sigma_{ij}(t) + \\dot{\\sigma}_{ij}(t) dt\n\\end{equation}\n$$\n利用坐标变换将这个应力张量的分量变换到随体坐标系 $P\\bar{x}_1\\bar{x}_2\\bar{x}_3$ 中, 有\n$$\n\\begin{equation}\n\\begin{aligned}\n\\label{eq234}\n\\bar{\\sigma}_{ij}(t + dt) & = c_{pi} c_{qj} \\sigma_{pq}(t + dt)\\\\\n& = (\\delta_{pi} + \\Omega_{pi}dt)(\\delta_{qj} + \\Omega_{qj}dt)[\\sigma_{pq}(t) + \\dot{\\sigma}_{pq}(t)dt]\\\\\n& = \\sigma_{ij}(t) + (\\dot{\\sigma}_{ij} + \\sigma_{ip}\\Omega_{pj} + \\sigma_{pi}\\Omega_{pi})dt + O(dt^2)\n\\end{aligned}\n\\end{equation}\n$$\n将上式代入式$(\\ref{eq232})$, 并利用 $\\bar{\\sigma}_{ij}(t) = \\sigma_{ij}(t)$ 和 $\\Omega_{ij}$ 的反对称性, 最后得\n$$\n\\begin{equation}\n\\label{eq235}\n\\sigma_{ij}^{\\nabla} = \\dot{\\sigma}_{ij} - \\sigma_{ip}\\Omega_{jp} - \\sigma_{pj}\\Omega_{ip}\n\\end{equation}\n$$\n按上式定义的应力率叫**焦曼应力率**, 它是不受刚体转动影响的客观张量, 可以在本构方程中使用. \n\n","tags":["学习笔记","物质点法"],"categories":["MPM"]},{"title":"基于Hexo和Github部署个人博客完整教程","url":"/2024/06/4a79202d/","content":"\n\n\n## 安装流程\n\n1. 安装node.js\n\n2. [安装Git](https://fireflye.asia/2024/05/cbf708ce.html)\n\n3. 安装Hexo\n\n4. 创建Github仓库\n\n5. 安装上传插件\n\n6. 更改配置\n\n7. 上传网页\n\n\n\n## 1. 安装node.js\n\n打开node.js官网[Node.js — Run JavaScript Everywhere (nodejs.org)](https://nodejs.org/en)点击下载\n\n<img src=\"2024-06-16-hexo-github/20240616123133.png\" alt=\"image-20240616123122227\" style=\"zoom: 25%;\" />\n\n打开安装至**默认位置**即可\n\n<img src=\"2024-06-16-hexo-github/20240616133443.png\" alt=\"image-20240616133442122\" style=\"zoom:50%;\" />\n\n<img src=\"2024-06-16-hexo-github/20240616133515.png\" alt=\"image-20240616133513544\" style=\"zoom: 50%;\" />\n\n<img src=\"2024-06-16-hexo-github/20240616134516.png\" alt=\"image-20240616134514733\" style=\"zoom:50%;\" />\n\n<img src=\"2024-06-16-hexo-github/20240616134543.png\" alt=\"image-20240616134540912\" style=\"zoom:50%;\" />\n\n<img src=\"2024-06-16-hexo-github/20240616134642.png\" alt=\"image-20240616134640367\" style=\"zoom:50%;\" />\n\n自动安装一些工具, 可以选上, 然后安装. 等待安装完成\n\n<img src=\"2024-06-16-hexo-github/20240616134808.png\" alt=\"image-20240616134806827\" style=\"zoom:50%;\" />\n\n点击完成, 会弹出一些窗口\n\n<img src=\"2024-06-16-hexo-github/20240616134924.png\" alt=\"image-20240616134922113\" style=\"zoom:50%;\" />\n\n按**任意键**继续即可, 等待安装完成. \n\n<img src=\"2024-06-16-hexo-github/20240616135112.png\" alt=\"image-20240616135110217\" style=\"zoom:33%;\" />\n\n过程较长, 耐心等待安装完成. \n\n<img src=\"2024-06-16-hexo-github/20240616214419.png\" alt=\"image-20240616214328211\" style=\"zoom: 33%;\" />\n\n## 2. 安装Git\n\n查看往期教程[Git 安装及配置教程 | Firefly Blog | 萤火虫博客 (fireflye.asia)](https://fireflye.asia/2024/05/cbf708ce.html)\n\n## 3. 安装Hexo\n\n完成上面的安装后, 可以使用以下命令检查是否安装成功.\n\n打开`git bash`,输入\n\n```bash\nnode -v\nnpm -v\ngit -v\n```\n\n显示版本信息, 说明安装成功.\n\n![image-20240630103326908](2024-06-16-hexo-github/20240630103342.png)\n\n之后再输入以下命令安装hexo\n\n```bash\nnpm install -g hexo-cli\n```\n\n等待安装完成, 网络问题请自学寻找代理, 或寻找可用镜像源. 显示以下信息说明安装完成\n\n<img src=\"2024-06-16-hexo-github/20240630103804.png\" alt=\"image-20240630103802987\" style=\"zoom:50%;\" />\n\n还可以使用以下命令来查看安装情况\n\n```bash\nhexo -v\n```\n\n若显示版本信息, 说明已成功安装\n\n打开一个要存放网站文件的位置, 例如`F:\\web\\`. 打开此文件夹, 右键选择`open git bash here`\n\n> 或者 直接打开`git bash` 输入`cd f:\\web`. 路径替换为自己的路径. \n\n打开后会显示(我使用的虚拟机放在了桌面. 不建议这样做. 文件夹需要妥善保存.)\n\n<img src=\"2024-06-16-hexo-github/20240630111136.png\" alt=\"image-20240630111134467\" style=\"zoom:50%;\" />\n\n输入以下命令初始化hexo(一定要在刚刚的文件夹内-路径显示)\n\n```bash\nhexo init\n```\n\n保证网络畅通, 耐心等待初始化完成. \n\n<img src=\"2024-06-16-hexo-github/20240630111546.png\" alt=\"image-20240630111544780\" style=\"zoom: 67%;\" />\n\n到此, hexo初始化完成. 下面配置github仓库. \n\n## 4. 创建Github仓库\n\n打开[Github](https://github.com/)注册一个自己的账号\n\n<img src=\"2024-06-16-hexo-github/20240630135454.png\" alt=\"image-20240630104651171\" style=\"zoom: 33%;\" />\n\n输入自己的邮箱, 密码等\n\n<img src=\"2024-06-16-hexo-github/20240630105025.png\" alt=\"image-20240630104946194\" style=\"zoom:50%;\" />\n\n用户名建议设置简单易记一些, 待会创建的网站域名与自己的用户名有关\n\n<img src=\"2024-06-16-hexo-github/20240630105356.png\" alt=\"image-20240630105354804\" style=\"zoom:50%;\" />\n\n总览\n\n<img src=\"2024-06-16-hexo-github/20240630105538.png\" alt=\"image-20240630105536614\" style=\"zoom:50%;\" />\n\n点击继续, 通过验证码和邮箱数字验证就可以注册成功.\n\n<img src=\"2024-06-16-hexo-github/20240630110321.png\" alt=\"image-20240630110310020\" style=\"zoom: 25%;\" />\n\n点击左侧的绿色按钮新建仓库`Create repository`. \n\n<img src=\"2024-06-16-hexo-github/20240630112222.png\" alt=\"image-20240630112211721\" style=\"zoom: 33%;\" />\n\n到此, 仓库已经创建完成\n\n***\n\n接下来还需要配置一下上传的密钥对\n\n打开`git bash`, 输入以下命令 (\"email\"替换为自己的邮箱)\n\n```bash\nssh-keygen -t rsa -b 4096 -C \"email\"\n```\n\n然后按三下回车键, 即均保持默认不设置密码. 也可根据自己需要修改\n\n<img src=\"2024-06-16-hexo-github/20240630113042.png\" alt=\"image-20240630113030731\" style=\"zoom: 67%;\" />\n\n> 第一次是保存位置\n>\n> 第二次是密码\n>\n> 第三次是重复密码\n\n创建完成后, 打开保存的目录. 默认在`C:\\Users\\用户名\\.ssh`\n\n<img src=\"2024-06-16-hexo-github/20240630113309.png\" alt=\"image-20240630113306685\" style=\"zoom: 50%;\" />\n\n第一个是私钥, 自己一定要保存好, 不能给别人.\n\n将第二个pub结尾的用`记事本`打开, 将里面的内容复制出来.\n\n<img src=\"2024-06-16-hexo-github/20240630113557.png\" alt=\"image-20240630113555419\" style=\"zoom:50%;\" />\n\n复制好后, 返回Github\n\n<img src=\"2024-06-16-hexo-github/20240630113804.png\" alt=\"image-20240630113747970\" style=\"zoom: 33%;\" />\n\n<img src=\"2024-06-16-hexo-github/20240630113926.png\" alt=\"image-20240630113916419\" style=\"zoom:33%;\" />\n\n<img src=\"2024-06-16-hexo-github/20240630114019.png\" alt=\"image-20240630114006001\" style=\"zoom:33%;\" />\n\n<img src=\"2024-06-16-hexo-github/20240630114156.png\" alt=\"image-20240630114146715\" style=\"zoom:33%;\" />\n\n密钥添加完成\n\n## 5. 安装上传插件\n\n打开`git bash`\n\n```bash\nnpm install hexo-deployer-git --save\n```\n\n<img src=\"2024-06-16-hexo-github/20240630125113.png\" alt=\"image-20240630125111158\" style=\"zoom:50%;\" />\n\n安装完成\n\n## 6. 更改配置\n\n打开网站文件夹\n\n<img src=\"2024-06-16-hexo-github/20240630125231.png\" alt=\"image-20240630125228295\" style=\"zoom:50%;\" />\n\n用记事本打开`_config.yml`\n\n<img src=\"2024-06-16-hexo-github/20240630125343.png\" alt=\"image-20240630125338327\" style=\"zoom: 33%;\" />\n\n```\n# 配置说明, 不要复制. 按说明修改\n\n\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Hexo  # 网站的大标题\nsubtitle: ''  # 副标题\ndescription: '' # 描述\nkeywords:  # 网站的关键词\nauthor: John Doe # 作者\nlanguage: en  # 语言 中文 zh-CN\ntimezone: '' # 时区 Asia/Shanghai\n\n# URL\n## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'\nurl: https://fireflyblog.github.io # 改成自己网址 https://用户名.github.io # 注意是https\npermalink: :year/:month/:day/:title/  # 其他默认转到最后一项\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from permalinks\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link:\n  enable: true # Open external links in new tab\n  field: site # Apply to the whole site\n  exclude: ''\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nsyntax_highlighter: highlight.js\nhighlight:\n  line_number: true\n  auto_detect: false\n  tab_replace: ''\n  wrap: true\n  hljs: false\nprismjs:\n  preprocess: true\n  line_number: true\n  tab_replace: ''\n\n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Metadata elements\n## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta\nmeta_generator: true\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n## updated_option supports 'mtime', 'date', 'empty'\nupdated_option: 'mtime'\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Include / Exclude file(s)\n## include:/exclude: options only apply to the 'source/' folder\ninclude:\nexclude:\nignore:\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: landscape\n\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: ''\n\n```\n\n这一部分单拿出来修改(注意缩进为2个空格, 冒号后面一个空格)\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repository:\n  branch: main\n```\n\n仓库地址在[Github](https://github.com/dashboard), 打开找到自己的仓库\n\n<img src=\"2024-06-16-hexo-github/20240630131332.png\" alt=\"image-20240630131146011\" style=\"zoom: 33%;\" />\n\n复制好后粘贴到仓库参数后面, 完整的配置修改如下\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repository: git@github.com:fireflyblog/fireflyblog.github.io.git #替换为自己的链接\n  branch: main\n```\n\n## 7. 上传网页\n\n一切配置好之后, 打开网站文件夹. 右键选择`open git bash here`\n\n输入以下命令生成和上传网页\n\n```bash\nhexo g\nhexo d\n```\n\n<img src=\"2024-06-16-hexo-github/20240630132526.png\" alt=\"image-20240630132524270\" style=\"zoom:50%;\" />\n\n<img src=\"2024-06-16-hexo-github/20240630132738.png\" alt=\"image-20240630132736169\" style=\"zoom:50%;\" />\n\n上传成功之后, 等待一会. 就可以打开自己网页查看了(替换自己的用户名)\n\n```\nhttps://fireflyblog.github.io\n```\n\n<img src=\"2024-06-16-hexo-github/20240630133040.png\" alt=\"image-20240630132950741\" style=\"zoom:33%;\" />\n\n至此, 网站已经搭建完成\n\n***\n\n还有一些其他常使用的命令\n\n新建文章\n\n```bash\nhexo new \"title\"\n```\n\n本地部署预览\n\n```bash\nhexo s\n```\n\n清理生成文件(一般切换主题需要先清理再生成. 新建文章之类的不需要此操作.)\n\n```bash\nhexo clean\n```\n\n***\n\n文章保存在\n\n```\n网站文件夹\\source\\_posts\n```\n\n***\n\n文章格式说明以及主题美化待更新...\n","tags":["教程及说明","Git","Hexo","静态网页","Blog","博客"],"categories":["Github"]},{"title":"Fortran转C++的一些注意事项","url":"/2024/05/5a883584/","content":"\n\n\n## 一、命名\n\n在Fortran中, 所有的字符都是`不区分大小写`的. 在编译时, 全部使用小写字符. 但是, 在C++中是会`区分大小写`的. 因此, 在转换时要注意统一大小写. \n\n## 二、数据类型\n\n### 1. 可直接转换的参数类型\n\n- 整型: `integer`  = `int`\n- 浮点数: `real`  = `float`\n- 双浮点数: `real(8)`  = `double`\n- 逻辑: `logical` = `bool`\n\n> 对于科学计数法, Fortran中`d`表示双精度浮点数, 如`1.2d3`. 在C++中并不能直接识别, 但是C++中默认使用双精度浮点数. 因此可直接使用`1.2e3`来代替.\n\n### 2. 可代替的参数类型\n\n- 字符串`character`: 可使用`std::string`代替 (须`#indlude <string>`)\n\n> 在c++中`char`只能储存一个字符, 需要使用数组来保存字符串. 因此在使用上`character`和`string`更类似\n>\n> 对于字符串的连接, Fortran中使用`//`, C++中使用`+`\n\n- 复数`complex`: 可使用`std::complex`代替 (须`#include <complex>`)\n\n>C++的`std::complex`内提供了一些用于复数运算的函数, \n>\n>例如: \n>\n>`std::real`(获取复数的实部)\n>\n>`std::imag`(获取复数的虚部)\n>\n>`std::abs`(获取复数的模)\n>\n>`std::arg`(获取复数的辐角)\n>\n>`std::norm`(获取复数的模的平方)\n>\n>`std::conj`(获取复数的共轭复数)\n\n- 自定义类型`type`: 可使用结构体`struct`代替\n\n> 对于参数的访问, 在Fortran中使用`%`在c++中使用`.`\n\n- 动态数组`allocatable`: 可使用向量`vector`代替 (须`#include <vector>`)\n\n> 对于结构体类型的向量, 使用`vecname.assign(quantity, vecname());`来调整向量的大小. 但是注意这会清除向量中原有的内容\n>\n> 对于数值类型的向量, 使用`vecname.resize()`来调整大小\n>\n> 使用`vecname.size()`可以得到向量当前的大小\n\n- 动态`type`数组: 使用`std::vector<structname>`来定义\n\n> 对于动态type数组这类变量, 在Fortran中的初始化: \n>\n> ```fortran\n> !在Fortran2003以后的标准中, type可以直接给定默认值\n> type material\n> \treal :: mass = 0.0\n> \treal :: speed = 0.0\n> \treal :: Vx(3) = 0.0, Vy(3) = 0.0, Vz(3)=0.0\n> \n> type(material),allocatable::material_list(:)\n> allocate(material_list(3))\n> \n> !对于之前的标准, 或者没有定义默认值, 再或者需要再次初始化, 可以使用以下方式\n> type material\n> \treal mass\n> \treal speed\n> \treal Vx(3), Vy(3), Vz(3)\n> \n> type(material),allocatable::material_list(:)\n> allocate(material_list(3))\n> do i=1,3\n> \tmaterial_list(i)%mass = 0.0\n> \tmaterial_list(i)%speed = 0.0\n> \tmaterial_list(i)%Vx = (/0.0, 0.0, 0.0/)\n> \tmaterial_list(i)%Vy = (/0.0, 0.0, 0.0/)\n> \tmaterial_list(i)%Vz = (/0.0, 0.0, 0.0/)\n> end do\n> ! 特别的,在Fortran中,不加索引号会对数组内的全部元素赋值\n> type material\n> \treal mass\n> \treal speed\n> \treal Vx(3), Vy(3), Vz(3)\n> \n> type(material),allocatable::material_list(:)\n> allocate(material_list(3))\n> material_list%mass = 0.0\n> material_list%speed = 0.0\n> material_list%Vx = (/0.0, 0.0, 0.0/)\n> material_list%Vy = (/0.0, 0.0, 0.0/)\n> material_list%Vz = (/0.0, 0.0, 0.0/)\n> !与上面带索引号的方式,效果相同, C++中不能这样做\n> ```\n>\n> 在c++中: \n>\n> ```c++\n> //在C++11以后的标准中可以直接对结构体设置默认值\n> struct material //定义结构体\n> {\n>  float mass = 0.0f; //0.0默认是double类型, 浮点数的0.0要加上f\n>  float speed = 0.0f;\n>  float Vx[3] = {0.0f}, Vy[3] = {0.0f}, Vz[3] = {0.0f};//此处c++会将数组里的其他值也初始化为0.0f\n> };\n> std::vector<material> material_list; //创建结构体向量\n> material_list.assign(3,material()); //修改向量大小\n> \n> //对于之前的标准或者没有定义默认值, 再或者想要填充为其他值\n> material temp; \n> temp.mass = 0.0;\n> temp.speed = 0.0;\n> for (int i = 1; i < 3; i++ )\n> {\n>  temp.Vx[i] = 0.0;\n>  temp.Vy[i] = 0.0;\n>  temp.Vz[i] = 0.0;\n> };\n> material_list.assign(3,temp); \n> //assign函数会将material的大小调整为3, 并将所有值填充为temp\n> ```\n\n### 3. 需要注意的参数类型\n\n- 数组: 在Fortran中,数组的索引序号默认是从`1`开始, 而在C++中序号是从`0`开始. 这要求我们在使用循环操作数组时要注意索引序号. 其次, 在存储数据时, Fortran是使用列主序, 即一个二维数组(3,4)表示的是3列4行. 而在c++中二维数组[3,4]表示的是3行4列\n\n> Fortran和C++数组主要的区别：\n>\n> 1. **索引起始位置**：在Fortran中, 数组的索引默认从1开始, 并且可以自定义索引序号. 而在C++中, 数组的索引始终从0开始. \n> 2. **内存布局**：Fortran使用列优先(column-major)顺序存储多维数组, 而C++(和大多数其他C风格的语言)使用行优先(row-major)顺序存储多维数组. \n> 3. **动态数组**：在Fortran中, 可以很容易地创建动态数组, 而在C++中, 创建动态数组需要更多的工作. 不过, C++提供了`std::vector`这样的容器类, 可以方便地创建和管理动态数组. \n> 4. **数组作为函数参数**：在Fortran中, 当数组作为函数参数时, 会传递数组的引用, 而不是数组本身. 这意味着, 如果在函数内部修改了数组, 那么在函数外部的数组也会被修改. 在C++中, 如果你直接将数组作为函数参数, 那么实际上传递的是数组的指针, 如果你想要达到和Fortran相同的效果, 你需要显式地使用引用或者指针. \n> 5. **数组大小**：在Fortran中, 数组本身知道其大小, 而在C++中, 原生数组不知道其大小, 你需要自己保持对数组大小的跟踪. 不过, C++的`std::array`和`std::vector`等容器类知道它们的大小. \n\n- 数组的运算: 在Fortran中, 对于`数组`可以直接使用`+ - * / **`等运算符号, 其意义为数组中对应位置的元素相加, 减, 赋值. \n\n例如:\n\n```fortran\ninteger:: i(3),j(3)\ni = 1\ni = i + 1\nj = i\ni = i - j\n```\n\n在这段代码中, 定义了两个长度为3的一维数组. \n\n> 第2行, 将`i`中的元素全部赋值为`1`. \n>\n> 第3行, 将`i`中的每一个元素都加`1`, `i`中所有元素变为`2`.  \n>\n> 第4行, 将`i`中元素的值,对应赋值给`j`数组, `j`中元素也都变为了`2`.  \n>\n> 第5行, 将`i`中的元素对应减去`j`中的元素并赋值给`i`,  这时, `i`中的元素全部变为了`1`.  \n\n这些在C++中是无法直接做到的, 可以借助一些库或者使用循环或者STL中的一些标准函数来完成这些操作. \n\n- `copy`从一个数组复制到另一个数组 (std::copy(first,last,dest)前两个参数控制复制到数组的开始和结尾, 第三个为要复制的数组)\n\n- `fill`填充数组,用于数组的初始化 (std::fill(first,last,init)前两个控制范围,最后一个为填充值)\n\n- `transform`转换\n\n  > `transform`算法接受一个或两个输入范围, 以及一个输出范围, 并根据提供的一元函数对象或二元函数对象对\"输入范围内的元素\" 进行转换;\n  >\n  > - `InputIt first1`参数: 输入容器的起始迭代器(包含);\n  > - `InputIt last1`参数: 输入容器的终止迭代器(不包含);\n  > - `InputIt2 first2`参数: 第二个输入容器的起始迭代器(包含);\n  > - `OutputIt d_first`参数: 输出容器的开始迭代器, 输出元素个数根据输入元素的范围确定,transform会将变换结果存储到输出容器中;\n  > - `UnaryOperation unary_op`参数: 一元函数对象, 将输入容器的每个元素输入到该一元函数对象中, 将计算结果输出到输出容器中;\n\n## 三、运算符号\n\n- `+` `-` `*` `/` 都可以直接转换, 除了上面提到的应用在数组的计算上时\n\n- `**`幂乘运算在c++中可使用`#include <cmath>`库中的`pow`来代替\n\n> 用法: `std::pow(底数,指数)`\n\n- 求余`mod()`在c++中为`%`\n- 在c++中, 还有`--`和`++`等自减和自增运算, 注意其在使用时前缀和后缀的区别: 可以理解为`前缀既算值又变, 后缀只算值不变`. 当然这句话仅对其所在的一个语句生效, 无论是自增还是自减, 在这条语句结束后, 数值都发生了改变. \n\n> 例如: \n>\n> ```c++\n> int a=10;\n> int b;\n> b = ++a; //前缀自增a变为了11, 其参与计算的值也变为11, b=11, a=11\n> b = a++; //后缀自增a从上面的11变为了12, 但在这条语句中a参与计算的值还是11, b=11, a=11, 结束后a=12\n> b = a; //在上面的语句结束后a参与计算的值变为了12, b=12, a=12\n> ```\n>\n> 在上面的基础上, `b=++a--;`中的a b参与计算的值分别为多少? 该语句结束后a b的值又是多少? \n>\n> ```c++\n> b=13 a=13;\n> b=13 a=12;\n> ```\n>\n> 同时这两个运算符的优先级是要高于其它的\n>\n> ```c++\n> b = 1 + a--; //先计算a--再计算+1\n> ```\n>\n> 三个运算符相连时\n>\n> ```c++\n> b = a++-1; //等价于b=(a++)-1\n> b = a+++1; //等价于b=(a++)+1, 但不建议这样做\n> ```\n\nC++中内置了(cmath)一些数学运算函数, 下面是常用的一些函数:\n\n```c++\ndouble cos(double); //返回弧度角的余弦\ndouble sin(double); //正弦\ndouble tan(double); //正切\ndouble log(double); //返回输入参数的自然对数-ln\ndouble pow(double, double); //返回第一个参数的第二个参数次方\ndouble hypot(double, double); //返回两个参数平方和的平方根\ndouble sqrt(double); //返回参数的平方根\nint abs(int); //返回整数的绝对值\ndouble fabs(double); //返回浮点数的绝对值\ndouble floor(double); //返回小于或等于传入的参数的最大整数\n```\n\n\n\n## 四、控制结构\n\n### 1. 循环结构\n\n在Fortran中, 循环结构有两种`do`和`do while`. 分别对应着c++中的`for`和`while`. 除此之外, c++还有一种结构`do ... while`. 它与`while`的区别在于: `while`是先判断后执行, `do ... while`是先执行后判断. \n\n循环控制语句对应关系:\n\n- `exit`: 在c++中为`break`\n- `cycle`: 在c++中为`continue`\n\n> 此外, 在c++中还有一种控制语句`goto`即跳转到某一被标记的语句执行. 但是, 在程序中`不建议`使用该语句! \n\n### 2. 判断语句\n\n在Fortran中, 判断语句有`if-then`, `if-then-else` 和`if-else if-else`. 这与c++中的`if`, `if-else`以及`if-else if-else`是一一对应的. 他们的用法相同.\n\n需要注意的是, 在Fortran中的`select case`语句与c++中的`switch`语句有一些使用上的差别.\n\n> `select case`语句在运行选择的`case`后会结束`select`也就是只进行一次选择. 而在c++的`switch`语句中, 如果不使用`break`语句, 会一直进行`switch`. \n>\n> 相当于Fortran的选择语句中, 所有的`case`都带有一个`break`. \n\n> 如果将`do while(.true.)`与`select case()`语句结合, 当某个case中有一个`exit`语句, 它会结束do while的循环. 而在c++中, `while`和`switch`都使用`break`来打断, 所以case中的`break`只会结束switch而不会结束while(true). 因此, 在转换时需要增加while结束的条件.  \n>\n> 例如:\n>\n> ```fortran\n> do while(.true.)\n>     key = Keyord(kw,nbkw)\n>     select case(key)\n>         case(1)\n>         \texit\n>         case(2)\n>         \tcall GetString(Title)\n>         case(3)\n>         \tnb_particle = GetInt()\n>         \twrite(*,\"(a,i12)\") 'Number of particles = ',nb_particle\n>         \twrite(iomsg,\"(a,i12)\") 'Number of particles = ',nb_particle\n>        \t\tallocate(particle_list(nb_particle))\n>         \tcall InitParticle()\n>         case default\n>         \tstop 'STOP - Error encountered in reading data'\n>     end select\n> end do \n> ```\n>\n> 改为c++\n>\n> ```c++\n> while (true)\n> {\n>     key = KeyWord(kw, nbkw);\n>     switch (key + 1)\n>     {\n>         case 1:\n>             break;\n>         case 2:\n>             Title = GetString();\n>             break;\n>         case 3:\n>             nb_particle = GetInt();\n>             cout << \"Number of particles = \" << nb_particle << endl;\n>             outfile << \"Number of particles = \" << nb_particle << endl;\n>             particle_list.assign(nb_particle, Particle());\n>             break;\n>         default:\n>             cout << \"STOP - Error encountered in reading data\" << endl;\n>             exit(1);\n>     }\n>     if (key == 0) break;\n> }\n> ```\n>\n> 或者使用`do...while`\n>\n> ```c++\n> do\n> {\n> \tkey = KeyWord(kw, nbkw);\n>    \tswitch (key + 1)\n>     {\n>     \t//...\n>     }\n> }while(key != 0);\n> ```\n\n\n\n## 五、子程序和函数子程序\n\n对于独立的子程序 (不引用其他的module) 可直接使用`void`函数替代. 对于`function`函数子程序可以对应类型的函数替代, 即有返回值的函数. \n\n例子:\n\n```fortran\nsubroutine sum100(sum_)\n\timplicit none\n\tinteger,intent(out)::sum_\n\tinteger :: i\n\tsum_ = 0\n\tdo i=1,100\n\t\tsum_ = sum_ +i\n\tendo\nend subroutine sum100\n```\n\n这个程序会计算1~100的和并输出到sum这个量\n\n```fortran\ncall sum100(sum1)\n```\n\n转换成c++\n\n```c++\nint sum = 0;\nvoid sum100 (int &sum_)\n{\n\tfor (int i=1; i<=100; i++) //在循环体中Fortran判断结束的条件默认是小于等于\n\t{\n\t\tsum_ += i\n\t}\n}\nsum100(sum);\n```\n\n>  这类子程序的特点: 有明确的输入的输出, 全部工作都在子程序内完成, 不牵扯其他的module或子程序. \n\n***\n\n### 关于参数的传递\n\n在Fortran的子程序中, 参数的传递默认按照`引用`来传递. 即, 如果你在子程序内改变了这一变量(未规定为`in`类型), 外部的变量也会改变. 这与C++中使用`&`符号传递参数的作用相同.\n\n有些子程序, 在编写时, 未规定传入参数的类型为输入(`in`)还是输出(`out`). 在转换为C++时, 需要注意分辨是否需要改变外部的变量.\n\n> 在转换时, `in`类型的变量在子程序中是无法改变的, 因此我们在写c++的函数时, 不需要加`&`. 而对于`out`类型的变量, 必须要加上`&`, 否则不能改变外部的变量.\n>\n> 对于全局变量而言, 不需要作为传入参数. 可以直接使用并改变该变量的值.\n\n## 六、模块(Module)\n\n对于这类文件, 可以使用`头文件`+`全局变量`+`源文件`的模式\n\n对于`全局常量和结构体`, 只需要定义在`头文件`内即可. 在头文件中, 结构体的定义和常量的定义不使用`extern`声明. \n\n在编写代码时, 可以使用`namespace`对不同文件的参数作区分, 防止出现命名上的冲突 (可不使用). 在c++中, 还可以使用`class`来更好的组织和封装数据及函数. \n\n如果原模块没有私有变量, 可直接使用`namespace`.\n\n> ### 以下是GPT对两种方式的优缺点的判断: \n>\n> **使用`namespace`的优点：**\n>\n> 1. `namespace`可以用来避免命名冲突. 你可以在不同的`namespace`中定义同名的函数或变量, 而不会产生冲突. \n> 2. `namespace`可以嵌套, 这使得你可以更好地组织你的代码. \n> 3. `namespace`可以在多个文件中定义, 这使得你可以将相关的代码和数据分散在多个文件中. \n>\n> **使用`namespace`的缺点：**\n>\n> 1. `namespace`不能用来封装数据. 在`namespace`中定义的所有函数和变量都是公开的, 任何人都可以访问. \n> 2. `namespace`不能用来实现面向对象编程的特性, 如继承和多态. \n>\n> **使用`class`的优点：**\n>\n> 1. `class`可以用来封装数据和函数. 你可以控制哪些数据和函数是公开的(`public`), 哪些是私有的(`private`). \n> 2. `class`可以用来实现面向对象编程的特性, 如继承和多态. \n> 3. `class`可以用来创建对象, 这使得你可以在运行时动态地创建和销毁数据和函数. \n>\n> **使用`class`的缺点：**\n>\n> 1. `class`不能像`namespace`那样用来避免命名冲突. 在同一个`namespace`中, 不能有两个同名的`class`. \n> 2. `class`不能在多个文件中定义. 一个`class`的所有成员都必须在同一个文件中定义. \n\n\n\n***\n\n欢迎补充和指正\n","tags":["Fortran","学习笔记","C++","语言转换"],"categories":["编程语言"]},{"title":"Git 安装及配置教程","url":"/2024/05/cbf708ce/","content":"\n\n\n## 1. 下载安装包\n\n打开[Git官网](https://git-scm.com/downloads)下载安装包, 嫌速度慢可以使用下面的链接下载\n\n蓝奏云(不限速)：[https://wwt.lanzoul.com/b00rn0x92b](https://wwt.lanzoul.com/b00rn0x92b) 密码:gdo1\n\n百度云(会员)：[https://pan.baidu.com/s/1QRxu8qYWI0rAOFqX9PT01g?pwd=1111](https://pan.baidu.com/s/1QRxu8qYWI0rAOFqX9PT01g?pwd=1111) 提取码: 1111\n\n![image-20240507135225158](2024-05-07-git-install/202405071352070.png)\n\n![image-20240507135511255](2024-05-07-git-install/202405071355950.png)\n\n下载完成后，双击打开安装包\n\n## 2. 开始安装\n\n![image-20240507143702625](2024-05-07-git-install/202405071437531.png)\n\n![image-20240507143826832](2024-05-07-git-install/202405071438756.png)\n\n![image-20240507144255668](2024-05-07-git-install/202405071442644.png)\n\n![image-20240507144334722](2024-05-07-git-install/202405071443653.png)\n\n![image-20240507144644121](2024-05-07-git-install/202405071446143.png)\n\n![image-20240507144955949](2024-05-07-git-install/202405071449923.png)\n\n![image-20240507145114067](2024-05-07-git-install/202405071451220.png)\n\n![image-20240507145517679](2024-05-07-git-install/202405071455747.png)\n\n![image-20240507145603852](2024-05-07-git-install/202405071456870.png)\n\n![image-20240507150213743](2024-05-07-git-install/202405071502727.png)\n\n![image-20240507150434447](2024-05-07-git-install/202405071504531.png)\n\n![image-20240507151557254](2024-05-07-git-install/202405071515269.png)\n\n![image-20240507151819793](2024-05-07-git-install/202405071518820.png)\n\n![image-20240507152039835](2024-05-07-git-install/202405071520714.png)\n\n点击安装, 等待安装完成\n\n![image-20240507152351881](2024-05-07-git-install/202405071523934.png)\n\n## 3. 配置Git\n\n### (1). 配置用户信息\n\n输入以下命令配置用户信息, 修改成自己的信息\n\n```\ngit config --global user.name \"liudh\"\ngit config --global user.email \"xxxxxxx@xx.com\"\n```\n\n![image-20240507152545795](2024-05-07-git-install/202405071525435.png)\n\n\n\n可以使用以下命令查看配置信息\n\n```\ngit config user.name\ngit config user.email\n```\n\n### (2). 设置代理(需自备代理)\n\n在向`Github`推送时, 经常会遇到443等连接问题, 即时自己打开了代理软件依旧不能成功上传. 这是因为Git没有配置代理\n\n使用以下命令查看代理配置\n\n```\ngit config --global --get http.proxy\ngit config --global --get https.proxy\n```\n\n如果没有内容说明没有代理\n\n下面使用以下命令配置代理\n\n```\ngit config --global http.proxy 127.0.0.1:7890\ngit config --global https.proxy 127.0.0.1:7890\n```\n\n> 具体地址和端口在系统代理的位置查看\n\n![image-20240507153841415](2024-05-07-git-install/202405071538016.png)\n\n如果不想使用代理, 使用以下命令取消\n\n```\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n***\n\n至此, 就可以愉快地开始使用Git了\n","tags":["教程及说明","Git","安装教程","Windows"],"categories":["Git"]},{"title":"Ubuntu搭建Webdav","url":"/2024/05/e8755f24/","content":"\n\n\n参考文章: [Linux搭建WebDav服务 - Colzry's Blog](https://colzry.github.io/posts/linux服务/linux搭建webdav服务/)\n\n> 以下操作如出现无权限的情况, 可根据自己实际情况, 使用sudo提权解决\n\n## 步骤一: 安装WebDAV服务\n\n首先, 我们需要安装[WebDAV Server](https://github.com/hacdias/webdav), 打开页面下载合适的版本, 本文以[`linux-amd64-webdav.tar.gz`](https://github.com/hacdias/webdav/releases/download/v4.2.0/linux-amd64-webdav.tar.gz)为例, 其中`amd64`表示`x64`架构\n\n然后, 解压并移动文件到`/usr/bin/`, 其余的README和LICENSE文件可删除\n\n```\ntar -zxvf linux-amd64-webdav.tar.gz\nmv webdav /usr/bin/\n```\n\n## 步骤二: 配置WebDAV服务\n\n安装完成后, 我们需要对WebDAV服务进行配置. 首先, 我们需要创建一个目录用于存储WebDAV文件. 可以使用以下命令创建一个名为 `/home/liudh/webdav`的目录, 注意修改用户名`liudh`为自己的用户名\n\n```\nmkdir /home/liudh/webdav\n```\n\n然后, 我们需要编辑WebDAV服务的配置文件. 可以使用以下命令打开配置文件进行编辑\n\n```\nvim /opt/webdav_config.yaml\n```\n\n在配置文件中, 我们需要添加以下内容. \n\n> 注意根据自己的实际修改, 端口号可修改, 用户名, 密码, 用户空间均修改为自己的内容\n>\n> 注意缩进, `cors`和`users`后的参数均需要两个空格的缩进, 带`-`的参数需再缩进两个空格(四个)\n>\n> 每一个参数`:`后均有一个空格\n\n```\n# Server related settings\naddress: 0.0.0.0\nport: 10101\n# 如果无需验证填 false\nauth: true\n# 如果不需要 https 则填 false\ntls: false\n# https证书和密钥，如果 tls 为 false，cert 和 key 不需要\n# cert: cert_path\n# key: key_path\n# 访问前缀，建议默认\nprefix: /\ndebug: false\n# 如果 auth 为 false 生效，文件共享的路径\nscope: .\nmodify: true\nrules: []\n# 跨域设置\ncors:\n  enabled: true\n  credentials: true\n  allowed_headers:\n    - Depth\n  allowed_hosts:\n    - http://localhost:10101\n  allowed_methods:\n    - GET\n  exposed_headers:\n    - Content-Length\n    - Content-Range\n# 用户信息，如果 auth 为 true 生效\nusers:\n  - username: liudh\n    password: passwd\n    scope: /home/liudh/webdav/\n    # 是否允许修改\n    modify: true\n# 可以根据此模板继续添加其他用户\n```\n\n保存并关闭配置文件后, 使用以下命令启动服务, 显示地址和端口即为启动成功\n\n```\n/usr/bin/webdav -c /opt/webdav_config.yaml\n```\n\n## 步骤三: 添加守护进程\n\n```\nvim /usr/lib/systemd/system/webdav.service\n```\n\n将以下内容添加到文件中\n\n```\n[Unit]\nDescription=WebDAV server\nAfter=network.target\n[Service]\nType=simple\nUser=root\nExecStart=/usr/bin/webdav -c /opt/webdav_config.yaml\nRestart=on-failure\n[Install]\nWantedBy=multi-user.target\n```\n\n保存并关闭, 然后运行以下命令, 可能会要求输入用户密码验证\n\n```\nsystemctl daemon-reload\nsystemctl start webdav.service\nsystemctl status webdav.service\nsystemctl enable webdav.service\n```\n\n之后修改配置文件后, 可以使用以下命令重启服务\n\n```\nsystemctl restart webdav.service\n```\n\n## 步骤四: 挂载webdav测试服务\n\n使用任意webdav挂载软件, 挂载测试, 注意填写参数如下\n\n```\n协议: http # 如果配置了ssl证书就用https\n主机: # 设备的ip地址或域名, 如果是本地设备就填局域网的IP   !!!域名或IP结尾要加上 / 这个符号\n\t# 例如: 192.168.1.100:10101/  如果端口是单独填写就填: 192.168.1.100/\n端口: 10101 # 注意配置防火墙开放端口, 本地设备一般不需要\n用户名: liudh # 都改成自己的\n密码: passwd\n```\n\n之后就可以上传下载文件测试一下了, 如果有错误就用\n\n```\nsystemctl status webdav.service\n```\n\n查看错误日志. \n\n> 如果填对了账户还显示密码错误, 大概率是前面配置文件时缩进出错了, 回头检查一下\n","tags":["学习笔记","Webdav","云服务"],"categories":["Ubuntu"]},{"title":"Git撤销操作","url":"/2024/05/a2778edb/","content":"\n## Git 撤销操作\n\n学习视频：[十分钟学会常用git撤销操作，全面掌握git的时光机](https://www.bilibili.com/video/BV1ne4y1S7S9/?share_source=copy_web&vd_source=374d2addde246f63ad679abfc5ab707c) \n\n### 初始状态\n\n> - Disk\n>   + Init\n\n> - Staging(add)\n>   + Init\n\n> - Local-git(commit)\n>   + Init\n\n> - Remote-git(push)\n>   + Init\n\n## 情况一\n\n仅对文件做了修改但未add, 想要返回到初始状态\n\n状态如下\n\n> - Disk\n>   + Init -- change\n\n> - Staging(add)\n>   + Init\n\n> - Local-git(commit)\n>   + Init\n\n> - Remote-git(push)\n>   + Init\n\n想要删除此修改, 只需使用以下命令, `<filename>`表示要恢复的文件名\n\n```\ngit checkout <filename>\n或者\ngit restore <filename>\n```\n\n操作后恢复到原始状态\n\n> - Disk\n>   + Init~~ -- change~~\n\n> - Staging(add)\n>   + Init \n\n> - Local-git(commit)\n>   + Init\n\n> - Remote-git(push)\n>   + Init\n\n## 情况二\n\n若文件已经add\n\n状态如下\n\n> - Disk\n>   + Init -- change\n\n> - Staging(add)\n>   + Init -- change\n\n> - Local-git(commit)\n>   + Init\n\n> - Remote-git(push)\n>   + Init\n\n1. 若仅取消暂存, 可以使用下面的命令恢复\n\n```\ngit reset <filename>\n或者\ngit restore --staged <filename>\n```\n\n此操作仅会把文件重暂存区取出, 不会删除修改\n\n操作后恢复到以下状态\n\n> - Disk\n>   + Init -- change\n\n> - Staging(add)\n>   + Init~~ -- change~~\n\n> - Local-git(commit)\n>   + Init\n\n> - Remote-git(push)\n>   + Init\n\n2. 若想要连修改一起撤回, 使用以下命令\n\n```\ngit checkout HEAD <filename>\n```\n\n> `HEAD`表示最近的一次提交, 类似的`HEAD~1`表示倒数第二次提交\n\n## 情况三\n\n更改已经提交, 也就是如下状态\n\n> - Disk\n>   + Init -- change\n\n> - Staging(add)\n>   + Init -- change\n\n> - Local-git(commit)\n>   + Init -- change\n\n> - Remote-git(push)\n>   + Init\n\n1. 此时要想仅取消此提交不撤销更改, 使用以下命令\n\n```\ngit reset --soft HEAD~1\n```\n\n此时状态如下\n\n> - Disk\n>   + Init -- change\n\n> - Staging(add)\n>   + Init -- change\n\n> - Local-git(commit)\n>   + Init~~--change~~\n\n> - Remote-git(push)\n>   + Init\n\n2. 若想要将暂存一起取消, 则不使用`--soft`参数, 即\n\n```\ngit reset HEAD~1\n等价于\ngit reset --mixed HEAD~1\n```\n\n此时状态如下\n\n> - Disk\n>   + Init -- change\n\n> - Staging(add)\n>   + Init ~~-- change~~\n\n> - Local-git(commit)\n>   + Init~~--change~~\n\n> - Remote-git(push)\n>   + Init\n\n3. 若想完全回到上一次提交(本提交的前一次), 文件的修改也完全恢复到该次提交的状态. 使用以下命令\n\n```\ngit reset --hard HEAD~1\n```\n\n此时恢复到如下状态\n\n> - Disk\n>   + Init ~~-- change~~\n\n> - Staging(add)\n>   + Init ~~-- change~~\n\n> - Local-git(commit)\n>   + Init~~--change~~\n\n> - Remote-git(push)\n>   + Init\n\n***\n\n对于以上的恢复, 还有一种方式, 即在`change`的基础上加一个`-change`使文件在结果上恢复到上一次提交的状态\n\n使用以下命令可以实现\n\n```\ngit revert HEAD\n```\n\n效果如下\n\n> - Disk\n>   + Init -- change -- `-change`    ==  Init\n\n> - Staging(add)\n>   + Init -- change-- `-change`\n\n> - Local-git(commit)\n>   + Init--change-- `-change`\n\n> - Remote-git(push)\n>   + Init\n\n此命令还可以用于撤销之前的某一次提交的修改\n\n例如, 当前状态如下\n\n> - Disk\n>   + Init -- change1 --change2\n\n> - Staging(add)\n>   + Init -- change1 --change2\n\n> - Local-git(commit)\n>   + Init -- change1 --change2\n\n> - Remote-git(push)\n>   + Init\n\n使用如下命令, 撤销`change1`, `<hash>`指要撤销提交的hash值\n\n```\ngit revert HEAD~1\n或者\ngit revert <hash>\n```\n\n达到如下效果\n\n> - Disk\n>   + Init -- change1 --change2 --`-change1`\n\n> - Staging(add)\n>   + Init -- change1 --change2--`-change1`\n\n> - Local-git(commit)\n>   + Init -- change1 --change2--`-change1`\n\n> - Remote-git(push)\n>   + Init\n\n此命令在远程提交的撤销中起着重要作用, 见下文\n\n***\n\n## 情况四\n\n修改已经push到了Github上\n\n状态如下\n\n> - Disk\n>   + Init -- change\n\n> - Staging(add)\n>   + Init -- change\n\n> - Local-git(commit)\n>   + Init -- change\n\n> - Remote-git(push)\n>   + Init -- change\n\n1. 对于公有分支(不止一人使用该分支的情况), 只能使用`revert`\n\n```\ngit revert HEAD\n```\n\n恢复到如下状态\n\n> - Disk\n>   + Init -- change -- `-change` \n\n> - Staging(add)\n>   + Init -- change-- `-change`\n\n> - Local-git(commit)\n>   + Init--change-- `-change`\n\n> - Remote-git(push)\n>   + Init --change-- `-change`\n\n2. 对于个人分支, `reset`和`revert`均可, 但若使用`reset`恢复了提交, 在push时需要加上`-f`\n\n```\ngit push -f\n```\n\n> `-f`表示强制, 在共有分支应避免使用, 或者禁止使用\n\n","tags":["学习笔记","Git","Github","工作流程"],"categories":["Git"]},{"title":"Ubuntu22.04双系统安装教程","url":"/2024/05/deb026e9/","content":"\n## 准备工作\n\n> 良好的网络环境\n> \n> 一块8g以上的U盘(注意备份数据, 该U盘会被格式化)\n> \n> Windows电脑\n\n## 硬件要求\n\n> - 双核2 GHz处理器或更高\n> -  4 GB系统内存\n> - 25 GB磁盘存储空间\n\n## 装机需谨慎, 做好数据备份\n\n## 1. 系统镜像的下载\n\n打开[Ubuntu系统下载 | Ubuntu](https://cn.ubuntu.com/download) 此页面,点击**下载Ubuntu桌面版**, \n\n或者从网盘中下载: \n\n百度云：https://pan.baidu.com/s/1QRxu8qYWI0rAOFqX9PT01g?pwd=1111 提取码: 1111\n\n<img title=\"\" src=\"2024-05-04-ubuntu-22-04/202405051039370.png\" alt=\"\" data-align=\"center\">\n\n再选择Ubuntu22.04.4 LTS,点击**下载22.04.4**\n\n<img src=\"2024-05-04-ubuntu-22-04/202405051041029.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n将此文件下载保存至**易寻找的位置**, 以`F:/Ubuntu`为例, 稍后会使用. \n\n其他版本可在官网下载[Get Ubuntu | Download | Ubuntu](https://ubuntu.com/download) 安装步骤大致相同\n\n## 2. 安装写盘工具Rufus\n\n打开[Rufus - 轻松创建 USB 启动盘](https://rufus.ie/zh/) 页面, 找到下载,选择Windows x64平台的便携版, 下载打开即用. \n\n<img title=\"\" src=\"2024-05-04-ubuntu-22-04/202405051041560.png\" alt=\"Rufus\" width=\"427\" data-align=\"center\">\n\n插入U盘,打开软件\n\n<img title=\"\" src=\"2024-05-04-ubuntu-22-04/202405051042395.png\" alt=\"rufus\" data-align=\"center\" width=\"330\">\n\n点击选择, 设备选择刚刚插入的U盘, 镜像文件点击右侧**选择**, 选中刚刚下载的镜像文件, 我的是位于`F:/Ubuntu`, 选项如下图即可, 点击开始, 等待写入完成, 点击关闭, 弹出U盘\n\n<img title=\"\" src=\"2024-05-04-ubuntu-22-04/202405051042474.png\" alt=\"写盘例子\" data-align=\"center\" width=\"343\">\n\n## 3. 关闭Bitlocker或者备份Bitlocker恢复密钥\n\n如果硬盘设置了Bitlocker, 一定要提前找到恢复密钥, 可以先保存到手机上, 一般在微软账户里会有备份[恢复密钥](https://account.microsoft.com/devices/recoverykey)\n\n如果找不到了, 开始前一定要关闭Bitlocker. 改动引导顺序和安全启动选项会触发BitLocker, 要求输入恢复密钥. 否则你将无法打开Windows系统或已加密数据\n\n关闭过程时间可能较长\n\n## 4. 压缩硬盘空间(双系统需要,若全新安装不需要)\n\n打开Windows的磁盘管理工具, 右键开始菜单图标, 选择磁盘管理\n\n<img title=\"\" src=\"2024-05-04-ubuntu-22-04/202405051042717.png\" alt=\"磁盘管理\" data-align=\"center\" width=\"99\">\n\n找到需要压缩的分区, 右键点击压缩卷\n\n<img src=\"2024-05-04-ubuntu-22-04/202405051042369.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n输入合适的空间, 建议40GB以上, 最低不低于官网要求的25GB, 点击压缩即可\n\n<img title=\"\" src=\"2024-05-04-ubuntu-22-04/202405051042487.png\" alt=\"压缩盘\" data-align=\"center\" width=\"523\">\n\n## 5. 关闭安全启动, 设置U盘启动\n\n网络上搜索自己的电脑进入BIOS的方法, surface go系列是按音量加键, 一般电脑是按F2或者F10, 以自己的电脑为准, 进入BIOS,关闭安全启动, 设置启动顺序, 将**USB设备**设置到最上面, 由于每台设备情况不同, 此处设置请自行搜索自己电脑的教程. \n\n> surface go系列安全启动会有三个选项\n> \n> - 微软\n> \n> - 微软和第三方\n> \n> - 关闭\n> \n> 选择微软和第三方即可\n\n## 6. 插入U盘, 启动电脑\n\n在上一步设置完成之后, 若处于开机状态就插入U盘, 重启电脑, 引导位置选择\n\n>  Try or Install Ubuntu\n\n<img title=\"\" src=\"2024-05-04-ubuntu-22-04/202405051042783.png\" alt=\"\" data-align=\"center\" width=\"411\">\n\n等待进入安装界面, 选择中文\n\n<img src=\"2024-05-04-ubuntu-22-04/202405051042996.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n如果出现窗口显示不全, 点击试用Ubuntu,如果像我一样可以看到全部窗口, 就点击安装Ubuntu, 跳转到下面[开始安装](#开始安装)教程\n\n***\n\n点击试用之后, 会出现如下界面\n\n<img src=\"2024-05-04-ubuntu-22-04/202405051043674.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n点击该图标, 再打开设置, 找到显示器, 缩放比例选择100%, 点击保存(我使用的虚拟机没有该选项, 就在红框的位置. 保存在夜灯右边位置, 修改后会出现)\n\n<img src=\"2024-05-04-ubuntu-22-04/202405051043419.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n保存之后再选择安装Ubuntu就可以了\n\n***\n\n### 开始安装\n\n键盘布局默认即可\n\n<img src=\"2024-05-04-ubuntu-22-04/202405051043870.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n<img src=\"2024-05-04-ubuntu-22-04/202405051043577.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n<img src=\"2024-05-04-ubuntu-22-04/202405051043254.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n***\n\n双系统手动分区\n\n<img src=\"2024-05-04-ubuntu-22-04/202405051043453.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n建议分区\n\n1. 创建交换空间\n\n> 填写大小: 建议与内存大小相同, 4G 8G 16G都可\n> \n> 分区类型: 逻辑分区\n> \n> 新分区位置:空间起始分区(下面也都是这个不用改)\n> \n> 用于: 交换空间\n\n2. 创建根目录分区\n\n> 填写大小: 如果空间太小就把剩下的全给根目录, 方便后面扩容, 如果空间充足就给20GB以上均可,主要存放系统文件和安装软件\n> \n> 分区类型: 主分区\n> \n> 新分区位置:空间起始分区(下面也都是这个不用改)\n> \n> 用于: Ext4 日志文件系统\n> \n> 挂载点: /\n\n可选分区\n\n1. 创建引导分区(双系统同盘可不创建, 放置在Windows系统的引导分区里即可)\n\n> 填写大小: 建议200MB-1024MB根据个人情况来,这里我给了500MB\n> \n> 分区类型: 主分区\n> \n> 新分区位置: 空间起始分区(下面也都是这个不用改)\n> \n> 用于: EFI\n\n2.  如果空间充足可给/home分区单独设置, 后面想扩容之类的就上面三个分区就可以了, 后面扩容完可以再分\n\n> 填写大小: 20GB以上均可, 看个人使用情况, 存放用户文件, 类似Windows的Users目录\n> \n> 分区类型: 主分区\n> \n> 新分区位置:空间起始分区(下面也都是这个不用改)\n> \n> 用于: Ext4 日志文件系统\n> \n> 挂载点: /home\n\n最终效果如下\n\n<img src=\"2024-05-04-ubuntu-22-04/202405051043246.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n***\n\n 点击**现在安装**  --> **继续**, 时区选择上海, 点击**继续**\n\n<img src=\"2024-05-04-ubuntu-22-04/202405051043725.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n用户信息按自己的填写即可. 可以勾选自动登录, 每次开机不需要选择用户, 自动登录.\n\n<img src=\"2024-05-04-ubuntu-22-04/202405051043618.png\" title=\"\" alt=\"\" data-align=\"center\">\n\n点击**继续**即可安装, 安装之后选择重启, 根据提示会让你拔掉U盘, 按ENTER(回车键)\n\n***\n\n至此双系统就安装好了. 每次启动时, 系统会提示选择Ubuntu还是Windows系统一般是4个选项\n\n> Ubuntu\n> \n> Ubuntu高级设置\n> \n> Windows\n> \n> EFI\n\n顺序可能不同,名称仅为示例, 很容易识别\n\n> 若未关闭Bitlocker, 进入Windows系统需要输入一次恢复密钥, 下次进入就不需要了.\n\n如果安装没有什么问题, 之前下载的镜像文件就可以清理了\n","tags":["教程及说明","Ubuntu","系统安装","硬盘分区"],"categories":["Ubuntu"]},{"title":"Git 工作流程","url":"/2024/04/5dbdb580/","content":"\n## Git 工作流程——以Github为例\n\n**适用于个人和小团队的标准工作模式**\n\n学习视频：[十分钟学会正确的github工作流，和开源作者们使用同一套流程](https://www.bilibili.com/video/BV19e4y1q7JJ/?share_source=copy_web&vd_source=374d2addde246f63ad679abfc5ab707c)\n\n假设项目初始内容如下\n\n> - Github: \n>   - main(master) 分支 Init 内容\n\n> - Loacl git: \n>   - main(master) 分支 Init 内容\n\n> - DIsk: \n>   - main(master) 分支 Init 内容（仅作理解）\n\n## 1. 建立个人工作分支\n\n使用如下命令创建一个个人工作的分支并切换到该分支上\n\n```\ngit checkout -b my-feature\n```\n\n当前状态如下\n\n> - Github: \n>   - main(master) 分支 Init 内容\n\n> - Loacl git: \n>   - main(master) 分支 Init 内容\n>   - `my-feature分支 Init 内容`\n\n> - DIsk: \n>   - `my-feature分支` Init 内容\n\n## 2. 对本地内容进行修改、提交、推送\n\n### (1) 当前状态如下\n\n> - Github: \n>   - main(master) 分支 Init 内容\n\n> - Loacl git:  \n>   - main(master) 分支 Init 内容\n>   - my-feature分支 Init 内容\n\n> - DIsk: \n>   - my-feature分支 `Init-changes` 内容\n\n使用`git diff`可查看对比做出修改的内容\n\n### (2) 暂存更改内容\n\n使用`git add <filename>`暂存已做出的修改\n\n此时状态如下\n\n> - Github: \n>   - main(master) 分支 Init 内容\n\n> - Loacl git:  \n>   - main(master) 分支 Init 内容\n>   - my-feature分支 `Init-changes` 内容\n\n> - DIsk: \n>   - my-feature分支 Init-changes 内容\n\n### (3) 提交已暂存的更改\n\n使用`git commit`命令提交\n\n若想添加注释可使用如下命令\n\n```\ngit commit -m \"text\"\n```\n\n此时状态如下\n\n> - Github: \n>   - main(master) 分支 Init 内容\n\n> - Loacl git:  \n>   - main(master) 分支 Init 内容\n>   - my-feature分支 `Init-f-commit` 内容\n\n> - DIsk: \n>   - my-feature分支 Init-f-commit 内容\n\n### (4) 将内容`push`到Github上\n\n使用`git push origin my-feature`将内容push到Github中自己的分支\n\n此时状态如下\n\n> - Github:\n>   - main(master) 分支 Init 内容\n>   - my-feature分支 `Init-f-commit` 内容\n\n> - Loacl git:  \n>   - main(master) 分支 Init 内容\n>   - my-feature分支 Init-f-commit 内容\n\n> - DIsk: \n>   - my-feature分支 Init-f-commit 内容\n\n**若此时GitHub中的main(master)分支有其他的修改或提交，须进行第三步[处理主分支的改变](#处理主分支的改变)**\n\n此时状态如下\n\n> - Github:\n>   - main(master) 分支 `Init-update` 内容\n>   - my-feature分支 Init-f-commit 内容\n\n> - Loacl git:  \n>   - main(master) 分支 Init 内容\n>   - my-feature分支 Init-f-commit 内容\n\n> - DIsk: \n>   - my-feature分支 Init-f-commit 内容\n\n## 3. 处理主分支的改变\n\n### (1) 本地返回main(master)分支\n\n```\ngit checkout main\n```\n\n此时状态如下\n\n> - Github:\n>   - main(master) 分支 Init-update 内容\n>   - my-feature分支 Init-f-commit 内容\n\n> - Loacl git:  \n>   - main(master) 分支 Init 内容\n>   - my-feature分支 Init-f-commit 内容\n\n> - DIsk: \n>   - `main(master)分支 Init 内容`\n\n### (2) 拉取远程改变\n\n```\ngit pull origin main\n```\n\n此时状态如下\n\n> - Github:\n>   - main(master) 分支 Init-update 内容\n>   - my-feature分支 Init-f-commit 内容\n\n> - Loacl git:  \n>   - main(master) 分支 `Init-update` 内容\n>   - my-feature分支 Init-f-commit 内容\n\n> - DIsk: \n>   - main(master)分支 `Init-update` 内容\n\n### (3) 切换回my-feature分支并合并代码\n\n使用以下命令切换回`my-feature`分支\n\n```\ngit checkout my-feature\n```\n\n再使用以下命令合并代码\n\n```\ngit rebase main\n```\n\n此时可能会出现`rebase conflict`，需要手动选择要保留的代码\n\n此时状态如下\n\n> - Github:\n>   - main(master) 分支 Init-update 内容\n>   - my-feature分支 Init-f-commit 内容\n\n> - Loacl git:  \n>   - main(master) 分支 Init-update 内容\n>   - my-feature分支 Init-f-commit 内容\n\n> - DIsk: \n>   - `my-feature`分支 `Init-update-f-commit` 内容\n\n### (4) 推送`my-feature`分支\n\n使用以下命令推送\n\n```\ngit push -f origin my-feature\n```\n\n**`-f`表示强制，切忌在push`main`分支时使用，须谨慎谨慎再谨慎!!!!!!!!!**\n\n此时状态如下\n\n> - Github:\n>   - main(master) 分支 Init-update 内容\n>   - my-feature分支 `Init-update-f-commit` 内容\n\n> - Loacl git:  \n>   - main(master) 分支 Init-update 内容\n>   - my-feature分支 Init-f-commit 内容\n\n> - DIsk: \n>   - my-feature分支 Init-update-f-commit 内容\n\n### (5) 审查并合并到`main`分支\n\n**此时生成新的`pull request`,项目管理员审查代码之后`Squash and merge`合并分支的改变并同步到`main`分支，简化提交内容，此时状态如下**\n\n> - Github:\n>   - main(master) 分支 `Init-update-update2` 内容\n>   - ~~`my-feature 分支`~~\n\n> - Loacl git:  \n>   - main(master) 分支 Init-uodate 内容\n>   - my-feature分支 Init-f-commit 内容\n\n> - DIsk: \n>   - my-feature分支 Init-update-f-commit 内容\n\n### (6) 清理本地分支\n\na. 切换到main(master)分支\n\n```\ngit checkout main\n```\n\nb. 删除my-feature分支\n\n```\ngit branch -D my-feature\n```\n\n**`-D`表示强制删除，切忌使用在main分支上，须谨慎谨慎再谨慎!!!!!!!!**\n\n此时状态如下\n\n> - Github:\n>   - main(master) 分支 Init-update-update2 内容\n\n> - Loacl git:  \n>   - main(master) 分支 Init-update 内容\n>   - ~~`my-feature分支 Init-f-commit 内容`~~\n\n> - DIsk: \n>   - `main(master)分支 Init-update 内容`\n\nc. 拉取最新main(master)分支\n\n```\ngit pull origin main\n```\n\n此时状态如下\n\n> - Github:\n>   - main(master) 分支 Init-update-update2 内容\n\n> - Loacl git:  \n>   - main(master) 分支 Init-update`-update2` 内容\n\n> - DIsk: \n>   - main(master)分支 Init-update`-update2` 内容\n\n至此一个工作环节结束\n","tags":["学习笔记","Git","Github","工作流程"],"categories":["Git"]},{"title":"学习笔记——流体力学基本方程 (一)","url":"/2024/04/98e90823/","content":"\n## 学习视频\n\n### [Bilibili-流体力学基础科普-北斗导航Compass](https://www.bilibili.com/video/BV1Ty4y1M7Fx/?share_source=copy_web&vd_source=374d2addde246f63ad679abfc5ab707c)\n\n参考教材：[Fundamentals of AERODYNAMICS by John D. Anderson, Jr.](https://pan.baidu.com/s/1fbj6e9Xk6LmWW2Vjmu0oIw?pwd=eavw)\n\n## 一、基本概念\n\n### 1. 什么是流体？\n\n- 对比固体和流体的区别\n\n> 对于固体剪切力与**形变量**成正比\n\n> 对于流体剪切力与**形变量的时间变化率**成正比\n\n- 解释流体为什么能流起来？\n\n> 对于流体如果流体中的**剪切力**是常数，则其形变量的时间变化率也应为常数，即流体一直发生形变（流动）\n\n- 流体在抗压时可以静止，在抗剪时一定在运动\n\n### 2. 流体质点\n\n将流体看作无穷多的质点的结合，符合连续介质假设\n\n### 3. 描述流体的物理量\n\n> 包括速度、密度、压强、温度等等\n\n- 压强(压力) Pressure 单位Pa\n\n$$\nP=\\frac{F}{A}\\ \\ \\ \\ 当A\\rightarrow0时\\ \\ \\ P=frac{dF}{dA}\n$$\n\n- 密度 单位 $kg/m^3$ \n\n$$\n\\rho=\\frac{m}{V}\\ \\ \\ 当V\\rightarrow0时\\ \\ \\ \\rho=\\frac{dm}{dV}\n$$\n\n- 温度 单位K\n\n$$\n0°C=273.15K\n$$\n\n### 4. 描述流体运动的方法\n\n- 拉格朗日法\n\n> 以质点为研究对象,跟踪质点的运动\n\n- 欧拉法\n\n> 以确定空间为研究对象,研究某一空间点不同时间下,在此空间点的质点的运动\n\n|       | 积分方法 | 微分方法 |\n|:-----:|:----:|:----:|\n| 拉格朗日法 | 一坨流体 | 质点   |\n| 欧拉法   | 控制体  | 空间点  |\n\n## 二、基本方程\n\n### 1. 质量守恒方程(连续方程)\n\n **控制体内流体总质量的增量 = 流入控制体的流体质量**\n\n欧拉法连续方程的微分形式\n\n$$\n\\frac{\\partial \\rho}{\\partial t}+\\frac{\\partial (\\rho u)}{\\partial x}+\\frac{\\partial (\\rho v)}{\\partial y}+\\frac{\\partial (\\rho w)}{\\partial z}=0\n$$\n\n其中 $\\rho,u,v,w$ 均是 $x,y,z,t$ 的函数,如 $\\rho(x,y,z,t)$ \n\n**方程左边:** 单位时间 控制体内流体总质量的增量(为负数就是减量)\n\n首先,表示总质量\n\n$$\nm={\\iiint}_{cv}\\rho dV\n$$\n\n对时间t求偏导,得\n\n$$\n\\frac{\\partial m}{\\partial t}=\\frac{\\partial ({\\iiint}_{cv}\\rho dV)}{\\partial t}={\\iiint}_{cv}\\frac{\\partial \\rho}{\\partial t}\\ dV\n$$\n\n**方程右边:** 单位时间 流入控制体的流体质量\n\n<img src=\"2024-04-22-study-note-001/202405051038892.png\" alt=\"\" style=\"zoom:50%;\" center/>\n\n> 质量=密度*体积\n\n$$\nh=v*\\Delta t\\cos\\theta\n$$\n\n$$\nV=Sh=Sv*\\Delta t\\cos\\theta\n$$\n\n则 $\\Delta t$ 时间范围内\n\n$$\nm=\\rho V=\\rho Sv\\Delta t\\cos\\theta\n$$\n\n$$\nm|_{单位时间}=\\rho Sv\\cos\\theta\n$$\n\n对控制体边界面积分\n\n$$\n{\\iint}_{cs}\\rho \\vec{v}\\cdot d\\vec{S}\n$$\n\n规定控制体表面的外法线方向为正,则方程右边应为添加负号\n\n即\n\n$$\n-{\\iint}_{cs}\\rho \\vec{v}\\cdot d\\vec{S}\n$$\n\n则可得到积分形式的质量守恒方程\n\n$$\n{\\iiint}_{cv}\\frac{\\partial \\rho}{\\partial t}\\ dV=-{\\iint}_{cs}\\rho \\vec{v}\\cdot d\\vec{S}\n$$\n\n也即\n\n$$\n{\\iiint}_{cv}\\frac{\\partial \\rho}{\\partial t}\\ dV+{\\iint}_{cs}\\rho \\vec{v}\\cdot d\\vec{S}=0\n$$\n\n根据高斯定理\n\n$$\n{\\iint}_{cs}\\rho \\vec{v}\\cdot d\\vec{S}={\\iiint}_{cv}[\\frac{\\partial(\\rho u)}{\\partial x}+\\frac{\\partial(\\rho v)}{\\partial y}+\\frac{\\partial(\\rho w)}{\\partial z}]dV\n$$\n\n则积分形式的质量守恒方程可以合并为\n\n$$\n{\\iiint}_{cv}[\\frac{\\partial \\rho}{\\partial t}+\\frac{\\partial(\\rho u)}{\\partial x}+\\frac{\\partial(\\rho v)}{\\partial y}+\\frac{\\partial(\\rho w)}{\\partial z}]dV=0\n$$\n\n可得微分形式的质量守恒方程\n\n$$\n\\frac{\\partial \\rho}{\\partial t}+\\frac{\\partial(\\rho u)}{\\partial x}+\\frac{\\partial(\\rho v)}{\\partial y}+\\frac{\\partial(\\rho w)}{\\partial z}=0\n$$\n\n用哈密顿算子表示,可写为\n\n$$\n\\frac{\\partial \\rho}{\\partial t}+\\vec{\\nabla}\\cdot(\\rho\\vec{v})=0\n$$\n\n下期内容：\n\n### 2. 动量守恒方程\n\n **控制体内流体总动量的增量 = 流入控制体的流体动量 + 外界的力产生的动量增量**\n\n### 3. 能量守恒方程\n\n **控制体内流体的总能量的增量 = 流入控制体的流体能量 + 外界的作用产生的能量增量**\n","tags":["学习笔记","流体力学","质量守恒方程"],"categories":["流体力学"]},{"title":"非饱和土手动迭代计算程序修改说明","url":"/2024/04/863a85e0/","content":"\n## 修改内容\n\n### 1、输入参数改变\n\nt(nl) 每层层底沉积年代(37 行)\n土水特征参数 a、m、n 随沉积年代模型参数(54、55 行)\n内摩擦角 粘聚力 重度 随沉积年代模型非线性(56、57 行)\n水位位置（坡顶为 0，y 方向为负值）(58 行)\n非饱和抗剪强度公式中 κ(59 行)\n\n### 2、输入所有节点孔压(53 行)\n\n```fortran\nREAD(12,*)inpore  !所有节点孔压\n```\n\n### 3、输出 prop(nprops,np_types)(98-85 行)\n\n```fortran\nnprops=10 !分别为内摩擦角、粘聚力、剪胀角、干密度、弹模、泊松比、a、m、n、饱和体积含水率\n\nCALL g_prop(a1,a2,a3,a4,b1,a5,a6,a7,b2,b3,b4,c1,c2,c3,c4,d1,c5,c6,c7,d2,d3,d5,la_rwt1,   &\n  la_rwt2,lm_rwt1,lm_rwt2,ln_rwt1,ln_rwt2,theta_r,zero,gam_w,np_types,nprops,nl,ny,t,   &\n  nx1,nx2,ny1,ny2,nye,nod,nels,g_num,num,nn,h,inpore,prop,prop1,theta_w,pa_rwt1,        &\n  pa_rwt2,pm_rwt1,pm_rwt2,pm_rwt3,pn_rwt1,pn_rwt2,pn_rwt3)\n```\n\n```\n首先，求prop1：一列单元的参数(其中重度为干重度)\n其次，求prop：所有单元参数(其中重度为干重度)\n之后，判断孔压正负，计算天然体积含水率/使用饱和体积含水率\n最后，利用含水率计算天然重度\n```\n\n### 4、输出 surf(2,nosurf) (79 行)\n\n根据水位计算水位线上各节点坐标\n\n```fortran\ncall WTpoints(zero,nx1,nx2,nn,ny1,ny2,nod,nels,g_num,gam_w,inpore,g_coord,nosurf,surf,ndim)\n```\n\n### 5、绘制网格划分时，将所有网格设置为具有不同参数(81-85 行)\n\n### 6、坡外水位所导致的重度荷载的变化，输出 gravlo(0:neq) (119 行)\n\n```fortran\nCALL water_loads\n```\n\n### 7、对于孔压 inpore 的处理\n\n```\n首先，单元循环内提取该单元所有节点的孔压(172行)\n其次，利用Vanapalli公式计算吸应力suc_sig (174-176行)\n之后，高斯循环中计算高斯点吸应力pore (181行)\n最后，修正正应力(186-188行)\n```\n\n### 8、若收敛，对应力进行恢复(193-195 行)\n\n### 9、奇偶分层下的变形图(224 行)\n\n```fortran\nCALL dismsh\n```\n\n## 输入说明\n\n```fortran\nw1   s1   w2   h1   h2   nl !分层数  用于划分黄土古土壤序列情况\n8    4     4    14   8    4\nh(nl) !每层层底距坡顶距离\n4   12   16   22\nny(nl) !每层划分网格数\n2    4    2   3\nt(nl) !每层层底沉积年代\n8   12   18   33\nnx1    nx2   ny1    ny2\n4       2     7    4\n!土水特征参数a、m、n随沉积年代模型参数\n0.044     7.062      -0.0000724      0.3318              -0.000161      1.5092\n24.4397   -113.0186   0.000000176   -0.0000591   0.2077   0.000000331   -0.000128   1.2664\n!内摩擦角     粘聚力        剪胀角     重度                    弹模 泊松比  比重\n0  18.5       0.17    0      0.0        1.25   0.018    0.4623   1.0e5   0.3  2.71\n0  18.5       3.56   500     0.0        1.39   0.0035   0.6489   1.0e5   0.3  2.72\n!水位位置（坡顶为0，y方向为负值）\n-100\n!非饱和抗剪强度公式中κ\n1.4\n!收敛准则  计算次数\n0.0001   500\n!折减次数\n9\n!折减系数\n0.8  0.9  1.0  1.1  1.2  1.3  1.4  1.5  1.6\n```\n\n***\n\n非本人原创内容\n","tags":["教程及说明","边坡稳定性","Fortran","有限元","孔压"],"categories":["边坡"]},{"title":"非饱和土边坡稳定性计算程序说明文件","url":"/2024/04/71e392b0/","content":"\n## 一、数据文件\n\n### 注意：以下文件内不要输入注释文字\n\n#### 1. dat文件\n\n```fortran\n!dx  h2v\n1.0  2.0\n!nx1 nx2 ny1 ny2\n20  20  10  5\n!树荷载的左列和右列数，树荷载kN(各单元格相同)\n27 32 10.0\n!内摩擦角，粘聚力，剪胀角，重度，弹性模量，泊松比, a, m, n, theta_s 其中,重度=ρ_d*gam_w,theta_s=1-ρ_d/G_s\n20.0  15.0  0.0  20.0  1.0e5  0.3 15 0.2 4 0.907749\n!水位位置（坡顶为0，y方向为负值）\n-20\n!非饱和抗剪强度公式中κ\n2\n!收敛准则  计算次数\n0.0001 500\n!折减次数\n6\n!折减系数\n1.2  1.3  1.4  1.5  1.55 1.6\n```\n\n![模型](2024-04-20-p64-load-pore/202405051034316.png)\n\n其中,第三行表示荷载的加荷位置和大小\n\n```fortran\n27 ! 表示起点在第27列（从左至右）\n32 ! 表示终点在第32列（从左至右）\n30 ! 表示荷载为30kN\n```\n\n对应下图中的红色位置\n\n![加载位置](2024-04-20-p64-load-pore/202405051036737.png)\n\n#### 2. 孔压文件x_f.txt\n\n```fortran\n按节点列依次输入节点处的孔压\n每个单元格有3列共8个节点，呈323分布，如下图所示，阴影部分为一个单元格，黄色为单元格号\n按照节点的1234...顺序竖向填写x_f.txt文件，每节点占一行 \n```\n\n![17143576814081714357680903png](2024-04-20-p64-load-pore/202405051036959.png)\n\n## 二、源代码\n\n本程序单元格序号是从上至下，从左至右依次排序,如下例\n\n```fortran\n    1 6 \n    2 7  11\n    3 8  12 15\n    4 9  13 16 18 20\n    5 10 14 17 19 21\n```\n\n在叠加荷载时，因为所有单元格的g都是按照3 2 1 4 6 7 8 5 的顺序保存，因此我们仅需找到对应的单元格号以及146号节点的相对位置\n\n146号节点的相对位置为g(6), g(8), g(10),下文有介绍\n\n接下来只需找到单元格号即可。\n\n### 计算单元号\n\n```fortran\nif (tree_load/=0) then !荷载不为零再进行运算\n  allocate(tree_nodes(nx1+nx2+ny1*ngrad))\n\n  tree_nodes=0\n   ! tree_nodes(nx1+nx2+ny1*ngrad)是储存表面单元格的单元号\n\n  itree = 2 !用于计数，记录需加荷的单元格数量\n  tree_nodes(1)=1 \n\n  ! 顶面和斜面前ngrad行\n  do i=2,nx1+ngrad \n     tree_nodes(itree) = (i-1)*nye+1\n     itree = itree + 1\n  end do\n\n  ! 斜面ngrad行以后\n  do i=1,ny1-1\n    do j=1,ngrad\n       if (j==1) then\n          tree_nodes(itree) = tree_nodes(itree-1)+nye-i+1\n       else\n          tree_nodes(itree) = tree_nodes(itree-1)+nye-i\n       end if\n       itree = itree + 1\n    end do\n  end do\n\n  ! 底面第一列\n  tree_nodes(itree) = tree_nodes(itree-1)+ny2+1\n  itree = itree + 1\n\n  ! 底面以后\n  do i=2,nx2\n     tree_nodes(itree) = tree_nodes(itree-1)+ny2\n     itree = itree + 1\n  end do\n\n  tree_nodes_= tree_nodes(nel_left:nel_right) ! 储存实际需要加荷的单元格的序号\n```\n\n### 分配荷载到节点\n\n```fortran\n  ALLOCATE(weight_load(8),tree(ndof))\n  !荷载在节点上的分布权重\n  weight_load = (/0.166667,0.0,0.0,0.666667,0.0,0.166667,0.0,0.0/)\n\n  !计算各节点荷载大小\n  tree=zero\n  tree(6)=tree_load*weight_load(1)\n  tree(8)=tree_load*weight_load(4)\n  tree(10)=tree_load*weight_load(6)\n\n  ! 此处注意区分(见下图)\n  ! g数组按3x 3y 2x 2y 1x 1y 4x 4y 6x 6y 7x 7y 8x 8y 5x 5y的顺序保存\n  ! weight_load按1 2 3 4 5 6 7 8来保存\n  ! 则1 4 6号节点的y方向对应g(6),g(8),g(10)\n\nend if\n```\n\n<img src=\"2024-04-20-p64-load-pore/202405051036468.png\" title=\"\" alt=\"单元节点\" data-align=\"center\">\n\n### 叠加荷载\n\n```fortran\n   itree=1 ! 作tree_nodes_数组的索引，将序号依次读出\n\n   elements_2: DO iel=1,nels\n\n      ...\n\n      gravlo(g)=gravlo(g)-eld*prop(4,etype(iel))\n\n      if (tree_load.ne.0.0) then !荷载不为零时计算\n\n         if ((iel==tree_nodes_(itree)).and.(itree.le.size(tree_nodes_))) then !判断是否为需加荷的单元\n\n            gravlo(g) = gravlo(g) - tree !根据自由度编号加到指定位置\n\n            itree=itree+1\n         end if\n      end if\n\n   END DO elements_2\n```\n\n---\n\n### 叠加外部水荷载\n\n叠加外部水荷载的方式与上方叠加外部荷载的方法类似，将水的压力 $\\gamma_w*h$ 叠加到相应的表面节点上\n\n```fortran\nIF(wl>g_coord(2,1))THEN  ! 水位淹没整个边坡\n      p3=(wl-g_coord(2,1))*gam_w\n      DO i=1,nx1\n         gravlo(nf(2,g_num(3,tree_nodes(i))))=gravlo(nf(2,g_num(3,tree_nodes(i))))-dx*p3/d6\n         gravlo(nf(2,g_num(4,tree_nodes(i))))=gravlo(nf(2,g_num(4,tree_nodes(i))))-dx*two*p3/d3\n         gravlo(nf(2,g_num(5,tree_nodes(i))))=gravlo(nf(2,g_num(5,tree_nodes(i))))-dx*p3/d6\n      END DO\n      DO i=nx1+1,nx1+ny1*ngrad\n         if (mod(i-nx1,ngrad)/=0)then\n            y5=g_coord(1,g_num(5,tree_nodes(i)))\n            p5=(wl-y5)*gam_w\n            gravlo(nf(2,g_num(3,tree_nodes(i))))=gravlo(nf(2,g_num(3,tree_nodes(i))))-dx*p5/d6\n            gravlo(nf(2,g_num(4,tree_nodes(i))))=gravlo(nf(2,g_num(4,tree_nodes(i))))-dx*two*p5/d3\n            gravlo(nf(2,g_num(5,tree_nodes(i))))=gravlo(nf(2,g_num(5,tree_nodes(i))))-dx*p5/d6\n         else\n            y5=g_coord(2,g_num(5,tree_nodes(i)))\n            p5=(wl-y5)*gam_w\n            y7=g_coord(2,g_num(7,tree_nodes(i)))\n            p7=(wl-y7)*gam_w\n            gravlo(nf(2,g_num(3,tree_nodes(i))))=gravlo(nf(2,g_num(3,tree_nodes(i))))-dx*p5/d6\n            gravlo(nf(2,g_num(4,tree_nodes(i))))=gravlo(nf(2,g_num(4,tree_nodes(i))))-dx*two*p5/d3\n            gravlo(nf(2,g_num(5,tree_nodes(i))))=gravlo(nf(2,g_num(5,tree_nodes(i))))-dx*p5/d6\n            gravlo(nf(1,g_num(5,tree_nodes(i))))=gravlo(nf(1,g_num(5,tree_nodes(i))))-dx*p5/d6\n            gravlo(nf(1,g_num(6,tree_nodes(i))))=gravlo(nf(1,g_num(6,tree_nodes(i))))-dx*(p5+p7)/d3\n            gravlo(nf(1,g_num(7,tree_nodes(i))))=gravlo(nf(1,g_num(7,tree_nodes(i))))-dx*p7/d6\n         end if\n      END DO\n\n      IF(ny2>0)THEN ! 如果有破角台阶\n         p3=(wl-g_coord(2,nn-2*ny2))*gam_w !p3==p5\n         DO i=nx1+ny1*ngrad+1,nx1+ny1*ngrad+nx2\n            gravlo(nf(2,g_num(3,tree_nodes(i))))=gravlo(nf(2,g_num(3,tree_nodes(i))))-dx*p3/d6\n            gravlo(nf(2,g_num(4,tree_nodes(i))))=gravlo(nf(2,g_num(4,tree_nodes(i))))-dx*two*p3/d3\n            gravlo(nf(2,g_num(5,tree_nodes(i))))=gravlo(nf(2,g_num(5,tree_nodes(i))))-dx*p3/d6\n         END DO\n      END IF\n   ELSE IF(wl>g_coord(2,nn-2*ny2))THEN ! 水面在斜面位置(低于坡顶,高于坡脚)\n      nw=int((-wl)/dx)\n      do i=nx1+nw*ngrad+ngrad,nx1+ny1*ngrad\n         y5=g_coord(2,g_num(5,tree_nodes(i)))\n         y7=g_coord(2,g_num(7,tree_nodes(i)))\n         p5=(wl-y5)*gam_w\n         p7=(wl-y7)*gam_w\n         if(i==nx1+nw*ngrad+ngrad)then ! 如果水面恰好穿过某行单元格\n            cx=y5-wl\n            cy=cx\n            gravlo(nf(1,g_num(5,tree_nodes(i))))=gravlo(nf(1,g_num(5,tree_nodes(i))))           &\n               +p7*cy*(cy**2-two*cy*dx+dx**2)/(d6*dx**2)\n            gravlo(nf(1,g_num(6,tree_nodes(i))))=gravlo(nf(1,g_num(6,tree_nodes(i))))           &\n               -p7*(cy**3-cy**2*dx-cy*dx**2+dx**3)/(d3*dx**2)\n            gravlo(nf(1,g_num(7,tree_nodes(i))))=gravlo(nf(1,g_num(7,tree_nodes(i))))           &\n               -p7*(dx**3-cy**3)/(d6*dx*dx)\n         else if(mod(i-nx1,ngrad)/=0)then ! 方格斜面台阶内部(仅有上表面接触水)\n            gravlo(nf(2,g_num(3,tree_nodes(i))))=gravlo(nf(2,g_num(3,tree_nodes(i))))-dx*p5/d6\n            gravlo(nf(2,g_num(4,tree_nodes(i))))=gravlo(nf(2,g_num(4,tree_nodes(i))))-dx*two*p5/d3\n            gravlo(nf(2,g_num(5,tree_nodes(i))))=gravlo(nf(2,g_num(5,tree_nodes(i))))-dx*p5/d6\n         else ! 方格斜面台阶最外部的单元格(上表面和右表面接触水)\n            gravlo(nf(2,g_num(3,tree_nodes(i))))=gravlo(nf(2,g_num(3,tree_nodes(i))))-dx*p5/d6\n            gravlo(nf(2,g_num(4,tree_nodes(i))))=gravlo(nf(2,g_num(4,tree_nodes(i))))-dx*two*p5/d3\n            gravlo(nf(2,g_num(5,tree_nodes(i))))=gravlo(nf(2,g_num(5,tree_nodes(i))))-dx*p5/d6\n            gravlo(nf(1,g_num(5,tree_nodes(i))))=gravlo(nf(1,g_num(5,tree_nodes(i))))-dx*p5/d6\n            gravlo(nf(1,g_num(6,tree_nodes(i))))=gravlo(nf(1,g_num(6,tree_nodes(i))))-dx*(p5+p7)/d3\n            gravlo(nf(1,g_num(7,tree_nodes(i))))=gravlo(nf(1,g_num(7,tree_nodes(i))))-dx*p7/d6\n         end if\n      END DO\n      IF(ny2>0)THEN \n         p3=(wl-g_coord(2,nn-2*ny2))*gam_w\n         DO i=nx1+ny1*ngrad+1,nx1+ny1*ngrad+nx2\n            gravlo(nf(2,g_num(3,tree_nodes(i))))=gravlo(nf(2,g_num(3,tree_nodes(i))))-dx*p3/d6\n            gravlo(nf(2,g_num(4,tree_nodes(i))))=gravlo(nf(2,g_num(4,tree_nodes(i))))-dx*two*p3/d3\n            gravlo(nf(2,g_num(5,tree_nodes(i))))=gravlo(nf(2,g_num(5,tree_nodes(i))))-dx*p3/d6\n         END DO\n      END IF\n   END IF\n```\n\n### 叠加孔压\n\n根据Vanapalli公式, 使用体积含水率、孔压等参数计算出基质吸力项, 叠加到正应力上\n\n![17143599364091714359936244png](2024-04-20-p64-load-pore/202405051036317.png)\n\n```fortran\nelements_3: DO iel=1,nels\n            bload=zero\n            phi=prop(1,iel)\n            tnph=TAN(phi*pi/d180)\n            phif=ATAN(tnph/srf(iy))*d180/pi\n            psi=prop(3,iel)\n            tnps=TAN(psi*pi/d180)\n            psif=ATAN(tnps/srf(iy))*d180/pi\n            cf=prop(2,iel)/srf(iy)\n            e=prop(5,iel)\n            v=prop(6,iel)\n            CALL deemat(dee,e,v)\n            num=g_num(:,iel)\n            coord=TRANSPOSE(g_coord(:,num))\n            do i=1,nod\n               call Vanapalli(i,iel,nprops,kapa,prop,theta_w,suc_sig,n_inpore) ! 计算基质吸力项\n            end do\n            g=g_g(:,iel)\n            eld=loads(g)\n            gauss_pts_2: DO i=1,nip\n               call shape_fun(fun,points,i)\n               pore(iel,i)=dot_product(fun,suc_sig)\n               CALL bee8(bee,coord,points(i,1),points(i,2),det)\n               eps=MATMUL(bee,eld)\n               eps=eps-evpt(:,i,iel)\n               sigma=MATMUL(dee,eps)\n               sigma(1)=sigma(1)-pore(iel,i) ! 此处124为正应力项, 3为剪应力项\n               sigma(2)=sigma(2)-pore(iel,i)\n               sigma(4)=sigma(4)-pore(iel,i)\n               CALL invar(sigma,sigm,dsbar,lode_theta)\n               !-----------------------check whether yield is violated-------------------\n               CALL mocouf(phif,cf,sigm,dsbar,lode_theta,f)\n               IF(f>fmax)fmax=f\n               IF(converged.OR.iters==limit)THEN\n                  sigma(1)=sigma(1)+pore(iel,i)\n                  sigma(2)=sigma(2)+pore(iel,i)\n                  sigma(4)=sigma(4)+pore(iel,i)\n                  devp=sigma\n               ELSE\n                  IF(f>=zero.OR.(converged.OR.iters==limit))THEN\n                     CALL mocouq(psif,dsbar,lode_theta,dq1,dq2,dq3)\n                     CALL formm(sigma,m1,m2,m3)\n                     flow=f*(m1*dq1+m2*dq2+m3*dq3)\n                     erate=MATMUL(flow,sigma)\n                     evp=erate*dt\n                     evpt(:,i,iel)=evpt(:,i,iel)+evp\n                     devp=MATMUL(dee,evp)\n                  END IF\n               END IF\n               IF(f>=zero)THEN\n                  eload=MATMUL(devp,bee)\n                  bload=bload+eload*det*weights(i)\n               END IF\n            END DO gauss_pts_2\n            !-----------------------compute the total bodyloads vector----------------\n            bdylds(g)=bdylds(g)+bload\n            bdylds(0)=zero\n         END DO elements_3\n```\n","tags":["教程及说明","非饱和土","边坡稳定性","方形网格","Fortran","有限元"],"categories":["边坡"]},{"title":"可靠度分析程序说明文件","url":"/2024/04/74b4d97f/","content":"\n## 非饱和黄土边坡失效概率计算程序\n\n本程序是基于有限元的边坡可靠度分析程序，改进自[Griffith教授](https://inside.mines.edu/~vgriffit) 的非饱和黄土边坡稳定性计算程序\n\n本程序使用强度折减法计算稳定系数，使用Monte-Carlo法计算失效概率；\n\n将计算作业量，分成**线程数量**的段数，将作业量平均分配给每一个线程；\n\n**本程序使用MPI实现并行运算**\n\n**程序文件**\n\n```\nslope_new/Subroutine.py\nslope_new/slope2.f90\n```\n\n**示例数据文件**\n\n```\nexmaple/1.dat\nexmaple/1_c.txt\nexmaple/1_phi.txt\nexample/1_gamma.txt !未给出\nexmaple/1_mstd.txt\nexmaple/1_grid.txt\n```\n\n**结果文件** 未给出\n\n```\n1_fs.res\n1_fail.res\n```\n\n### 前置安装教程\n\n1. Fortran程序前置安装：[OpenCoarrays](https://github.com/sourceryinstitute/OpenCoarrays)\n\n以Ubuntu22.04安装Open-coarrays 2.9.2为例：\n\n```\nsudo apt-get update\nsudo apt-get install cmake gfortran\nwget https://github.com/sourceryinstitute/OpenCoarrays/archive/refs/tags/2.9.2.tar.gz\ntar xf 2.9.2.tar.gz\ncd OpenCoarrays-2.9.2\nmakedir build\ncd build\ncmake ..\nmake\nsudo make install\n```\n\n！若[OpenCoarrays2.9.2](https://github.com/sourceryinstitute/OpenCoarrays/archive/refs/tags/2.9.2.tar.gz) 下载失败可手动下载并上传到`/home/username/`再解压编译安装\n\n2. 可选安装--后台运行[Screen](https://www.gnu.org/software/screen/)\n\n```\n安装：\nsudo apt-get install screen\n列出全部会话：\nscreen -ls\n新建：\nscreen\nscreen -S name\n删除：\nscreen -S name -X quit ! 或在窗口内使用快捷键ctrl + D\n放置后台：\n使用快捷键ctrl+A再ctrl+D \n返回窗口：\nscreen -R\nscreen -r name \n```\n\n3. Python程序须安装[Python3.x](https://www.python.org/downloads/) ！无须安装在服务器中，仅做数据处理工作，在本地使用即可\n\n程序运行依赖`numpy`库，可使用pip安装：\n\n```\npip install numpy\n```\n\n### 程序使用教程\n\n1. 运行[Subroutine.py](https://github.com/liudh56/Slope/blob/main/Slope_new/Subroutine.py)\n\n```\ncd 代码所在目录\npython ./Subroutine.py\n```\n\n 根据提示操作即可[使用教程](https://github.com/liudh56/Slope/tree/main/example)\n\n2. 将生成文件与`slope2.f90`放在同一文件夹内（本文件夹即要上传的文件夹）\n\n文件包括：\n\n```\nxxx.dat\nxxx_c.txt xxx_phi.txt xxx_gamma.txt #具体文件数量与设为随机的参数有关\n```\n\n[dat文件详细](https://github.com/liudh56/Slope/blob/main/example/1.dat) \n\n其他python程序使用文件（无需上传）：\n\n```\nxxx_mstd.txt\nxxx_grid.txt\n```\n\n#### Fortran程序--在服务器中运行\n\n1. 将上文中的文件夹上传至服务器并打开目录\n\n2. 编译命令：\n\n```\ncaf slope2.f90 -o slope\n```\n\n3. 运行：\n\n```\ncafrun -n 4 slope\n！ 4代表线程数，可更改，若线程数报错改用下面的命令\n```\n\n 或者：使用下面命令适用于多主机的情况，根据主机实际情况分配线程数。\n\n```\nmpirun --host host1:40 host2:40 -n 80 filename\nmpirun --host hostfile -n 80 filename !使用该命令须先创建hostfile文件\n```\n\n4. 保存结果文件到本地与Subroutine.py文件放置在同一文件内\n\n运行Subroutine.py程序并选择功能3计算失效概率，结果保存在`xxx_fail.res`文件内。\n\n## Subroutine.py程序使用方式\n\n### 1. 输入项目名称xxx。\n\n### 2. 选择功能（输入序号）。\n\n```\n1. （首次使用）引导填写并重新生成xxx.dat和xxx_mstd.txt文件\n   \n2. 根据xxx_mstd.txt生成phi、c和gamma的值\n   \n3. 计算失效概率,并生成xxx_fail.res文件,储存失效概率\n   \n4. 生成xxx_grid.txt文件,储存网格点的序号(多层土的情况使用)\n   \n5. 根据xxx_mstd.txt重新生成某参数值\n\n0. 退出程序(默认)\n```\n\n### 功能使用教程\n\n1. 第一次使用选择`1`填写`xxx.dat`和`xxx_mstd.txt`文件（也可直接修改示例文件来使用）\n\n**建议先查看示例文件**\n\n**若填写过程中出现填写错误，可继续填写，等待填写完成再从生成文件内修改错误**\n\n**功能4，可协助填写`xxx.dat`文件，后文介绍**\n\n2. 再选择`2`根据提示进行选择（以内摩擦角和粘聚力为随机参数为例）\n\n```\n请输入模拟次数:10000\n请输入参数类型(10:内摩擦角,20:粘聚力,30:重度) 10\n请输入分布类型(0:定值（默认）,1:正态分布,2:对数正态分布) 1\n已生成xxx_c.txt文件!\n请输入参数类型(10:内摩擦角,20:粘聚力,30:重度) 20\n请输入分布类型(0:定值（默认）,1:正态分布,2:对数正态分布): 1\n已生成xxx_phi.txt文件!\n```\n\n3. 文件上传计算\n\n4. 计算完成后，将结果文件`xxx_fs.res`放置与本程序在同一文件夹内，运行程序选择`3`，结果保存在`xxx_fail.res`文件\n\n**功能4介绍（单层土不需要使用）**\n\n```\n！根据自己划分的每层土的单元格数（不是高度）填写即可，注意与ny1和ny2区分\n请输入第1层土的厚度(竖向单元格数): 16\n请输入第2层土的厚度(竖向单元格数): 5\n已生成xxx_grid.txt文件!\n```\n\n`xxx_grid.txt`的内容复制到`xxx.dat`文件的以下位置：\n\n```\n\"Choose whether to set it as a random variable (the order is: phi c gamma,1 is random)\"\n1 1 0\n\n\"Property group assigned to each element (etype, data not needed if np_types=1)\"\n（--------此位置--------）\n\n\"Pseudo-static analysis: Horizontal acceleration factor (k_h)\"\n0.0\n```\n\n\n\n","tags":["教程及说明","边坡稳定性","Fortran","有限元","失效概率","Monte-Carlo","Python"],"categories":["边坡"]}]